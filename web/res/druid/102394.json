[{"authorTime":"2019-07-30 08:06:33","codes":[{"authorDate":"2019-07-30 08:06:33","commitOrder":9,"curCode":"  public static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","date":"2019-07-30 08:06:33","endLine":401,"groupId":"6046","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"bindTaskConfigAndClients","params":"(Binderbinder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/4a/6c2d8ace771e49d2b06fd4d3927f33fd08ba22.src","preCode":"  public static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliPeon.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":385,"status":"B"},{"authorDate":"2019-07-30 08:06:33","commitOrder":9,"curCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeType.OVERLORD).build()\n            );\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceTaskLogsModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","date":"2019-07-30 08:06:33","endLine":351,"groupId":"9297","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getModules","params":"(finalbooleanstandalone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d8/a6ec91e8a0fb498064305a414386673b0e84b6.src","preCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeType.OVERLORD).build()\n            );\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceTaskLogsModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliOverlord.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":159,"status":"MB"}],"commitId":"640b7afc1cee911a27de7bf938dda24a85ba1510","commitMessage":"@@@Add CliIndexer process type and initial task runner implementation (#8107)\n\n* Add CliIndexer process type and initial task runner implementation\n\n* Fix HttpRemoteTaskRunnerTest\n\n* Remove batch sanity check on PeonAppenderatorsManager\n\n* Fix paralle index tests\n\n* PR comments\n\n* Adjust Jersey resource logging\n\n* Additional cleanup\n\n* Fix SystemSchemaTest\n\n* Add comment to LocalDataSegmentPusherTest absolute path test\n\n* More PR comments\n\n* Use Server annotated with RemoteChatHandler\n\n* More PR comments\n\n* Checkstyle\n\n* PR comments\n\n* Add task shutdown to stopGracefully\n\n* Small cleanup\n\n* Compile fix\n\n* Address PR comments\n\n* Adjust TaskReportFileWriter and fix nits\n\n* Remove unnecessary closer\n\n* More PR comments\n\n* Minor adjustments\n\n* PR comments\n\n* ThreadingTaskRunner: cancel  task run future not shutdownFuture and remove thread from workitem\n","date":"2019-07-30 08:06:33","modifiedFileCount":"64","status":"M","submitter":"Jonathan Wei"},{"authorTime":"2019-08-03 11:30:05","codes":[{"authorDate":"2019-07-30 08:06:33","commitOrder":10,"curCode":"  public static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","date":"2019-07-30 08:06:33","endLine":401,"groupId":"6046","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"bindTaskConfigAndClients","params":"(Binderbinder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/4a/6c2d8ace771e49d2b06fd4d3927f33fd08ba22.src","preCode":"  public static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliPeon.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":385,"status":"N"},{"authorDate":"2019-08-03 11:30:05","commitOrder":10,"curCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeType.OVERLORD).build()\n            );\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceTaskLogsModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","date":"2019-08-03 11:30:05","endLine":353,"groupId":"9297","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getModules","params":"(finalbooleanstandalone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/00/377a37e0ae26ee941dcd178611774ffc5f7a97.src","preCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeType.OVERLORD).build()\n            );\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceTaskLogsModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliOverlord.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"}],"commitId":"1ee828ff498638ace7d12d0d3d5023b08506271d","commitMessage":"@@@Add a cluster-wide configuration to force timeChunk lock and add a doc for segment locking (#8173)\n\n* Add a cluster-wide configuration to force timeChunk lock and add a doc for segment locking\n\n* add more test\n\n* javadoc for missingIntervalsInOverwriteMode\n\n* Fix test\n\n* Address comments\n\n* avoid spotbugs\n","date":"2019-08-03 11:30:05","modifiedFileCount":"9","status":"M","submitter":"Jihoon Son"},{"authorTime":"2019-08-27 10:27:41","codes":[{"authorDate":"2019-08-27 10:27:41","commitOrder":11,"curCode":"  public static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","date":"2019-08-27 10:27:41","endLine":405,"groupId":"6046","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"bindTaskConfigAndClients","params":"(Binderbinder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/df/e5f1049304f862fcc5b955d63599cc83dad650.src","preCode":"  public static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliPeon.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":389,"status":"M"},{"authorDate":"2019-08-27 10:27:41","commitOrder":11,"curCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeType.OVERLORD).build()\n            );\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceTaskLogsModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","date":"2019-08-27 10:27:41","endLine":353,"groupId":"9297","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getModules","params":"(finalbooleanstandalone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/e3/ab2ef5adab3db162c1994463fd7f870f79e405.src","preCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeType.OVERLORD).build()\n            );\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceTaskLogsModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliOverlord.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"}],"commitId":"e5ef5ddafa632256fe8a387a117557c415bee7df","commitMessage":"@@@Fix the shuffle with TLS enabled for parallel indexing; add an integration test; improve unit tests (#8350)\n\n* Fix shuffle with tls enabled; add an integration test; improve unit tests\n\n* remove debug log\n\n* fix tests\n\n* unused import\n\n* add javadoc\n\n* rename to getContent\n","date":"2019-08-27 10:27:41","modifiedFileCount":"37","status":"M","submitter":"Jihoon Son"},{"authorTime":"2019-12-06 08:50:00","codes":[{"authorDate":"2019-08-27 10:27:41","commitOrder":12,"curCode":"  public static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","date":"2019-08-27 10:27:41","endLine":405,"groupId":"6046","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"bindTaskConfigAndClients","params":"(Binderbinder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/df/e5f1049304f862fcc5b955d63599cc83dad650.src","preCode":"  public static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliPeon.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":389,"status":"N"},{"authorDate":"2019-12-06 08:50:00","commitOrder":12,"curCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeType.OVERLORD).build()\n            );\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","date":"2019-12-06 08:50:00","endLine":347,"groupId":"9297","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"getModules","params":"(finalbooleanstandalone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/23/e985e01dac0c6cf7a1939aef0e3606493faca1.src","preCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeType.OVERLORD).build()\n            );\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceTaskLogsModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliOverlord.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"}],"commitId":"c949a252105a61db64849abdf38648f92b49d30b","commitMessage":"@@@Add DruidInputSource (replacement for IngestSegmentFirehose) (#8982)\n\n* Add Druid input source and format\n\n* Inherit dims/metrics from segment\n\n* Add ingest segment firehose reindexing test\n\n* Remove unnecessary module\n\n* Fix unit tests.  checkstyle\n\n* Add doc entry\n\n* Fix dimensionExclusions handling.  add parallel index integration test\n\n* Add spelling exclusion\n\n* Address some PR comments\n\n* Checkstyle\n\n* wip\n\n* Address rest of PR comments\n\n* Address PR comments\n","date":"2019-12-06 08:50:00","modifiedFileCount":"20","status":"M","submitter":"Jonathan Wei"},{"authorTime":"2019-12-08 23:47:58","codes":[{"authorDate":"2019-12-08 23:47:58","commitOrder":13,"curCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","date":"2019-12-08 23:47:58","endLine":412,"groupId":"6046","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"bindTaskConfigAndClients","params":"(Binderbinder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/1e/82c6ded5ee8eed6bc2b593c26600d985d757a0.src","preCode":"  public static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliPeon.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":396,"status":"M"},{"authorDate":"2019-12-08 23:47:58","commitOrder":13,"curCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            binder.bind(NodeRole.class).annotatedWith(Self.class).toInstance(NodeRole.OVERLORD);\n\n            bindAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","date":"2019-12-08 23:47:58","endLine":354,"groupId":"0","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"getModules","params":"(finalbooleanstandalone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/6e/00ba9d99a92ad721515afa1621c0b5fe9c6d37.src","preCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeType.OVERLORD).build()\n            );\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliOverlord.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"M"}],"commitId":"1c62987783e85867856f567b04aad807a26bb2e3","commitMessage":"@@@Add SelfDiscoveryResource; rename org.apache.druid.discovery.No? (#6702)\n\n* Add SelfDiscoveryResource\n\n* Rename org.apache.druid.discovery.NodeType to NodeRole. Refactor CuratorDruidNodeDiscoveryProvider. Make SelfDiscoveryResource to listen to updates only about a single node (itself).\n\n* Extended docs\n\n* Fix brace\n\n* Remove redundant throws in Lifecycle.Handler.stop()\n\n* Import order\n\n* Remove unresolvable link\n\n* Address comments\n\n* tmp\n\n* tmp\n\n* Rollback docker changes\n\n* Remove extra .sh files\n\n* Move filter\n\n* Fix SecurityResourceFilterTest\n","date":"2019-12-08 23:47:58","modifiedFileCount":"54","status":"M","submitter":"Roman Leventov"},{"authorTime":"2019-12-12 07:56:36","codes":[{"authorDate":"2019-12-08 23:47:58","commitOrder":14,"curCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","date":"2019-12-08 23:47:58","endLine":412,"groupId":"6046","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"bindTaskConfigAndClients","params":"(Binderbinder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/1e/82c6ded5ee8eed6bc2b593c26600d985d757a0.src","preCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliPeon.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":396,"status":"N"},{"authorDate":"2019-12-12 07:56:36","commitOrder":14,"curCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","date":"2019-12-12 07:56:36","endLine":351,"groupId":"9297","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"getModules","params":"(finalbooleanstandalone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f8/4a5e18ee27f68046382f3c075fbbf6b8a1ec0f.src","preCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            binder.bind(NodeRole.class).annotatedWith(Self.class).toInstance(NodeRole.OVERLORD);\n\n            bindAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliOverlord.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"M"}],"commitId":"e5e1e9c4eed5aa844911454a24d712390f690945","commitMessage":"@@@Fix broken master (#9005)\n\n* Multibinding for NodeRole\n\n* Fix endpoints\n\n* fix doc\n\n* fix test\n","date":"2019-12-12 07:56:36","modifiedFileCount":"10","status":"M","submitter":"Jihoon Son"},{"authorTime":"2020-01-22 05:56:54","codes":[{"authorDate":"2019-12-08 23:47:58","commitOrder":15,"curCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","date":"2019-12-08 23:47:58","endLine":412,"groupId":"6046","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"bindTaskConfigAndClients","params":"(Binderbinder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/1e/82c6ded5ee8eed6bc2b593c26600d985d757a0.src","preCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliPeon.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":396,"status":"N"},{"authorDate":"2020-01-22 05:56:54","commitOrder":15,"curCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new IndexingServiceTuningConfigModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","date":"2020-01-22 05:56:54","endLine":353,"groupId":"9297","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"getModules","params":"(finalbooleanstandalone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f6/3c68e951b60205765bf5d41106033e01a0ed8c.src","preCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliOverlord.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"M"}],"commitId":"d541cbe436bf97779a03eca0ec848fe911768884","commitMessage":"@@@Support both IndexTuningConfig and ParallelIndexTuningConfig for compaction task (#9222)\n\n* Support both IndexTuningConfig and ParallelIndexTuningConfig for compaction task\n\n* tuningConfig module\n\n* fix tests\n","date":"2020-01-22 05:56:54","modifiedFileCount":"10","status":"M","submitter":"Jihoon Son"},{"authorTime":"2020-02-17 05:00:12","codes":[{"authorDate":"2020-02-17 05:00:12","commitOrder":16,"curCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n    binder.bind(ShuffleClient.class).to(HttpShuffleClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","date":"2020-02-17 05:00:12","endLine":412,"groupId":"3621","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"bindTaskConfigAndClients","params":"(Binderbinder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/11/60eb9240c14c0a43c8f1705a5a4567089cea1f.src","preCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliPeon.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":395,"status":"M"},{"authorDate":"2020-02-17 05:00:12","commitOrder":16,"curCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            }).toProvider(Providers.of(null));\n            binder.bind(ShuffleClient.class).toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new IndexingServiceTuningConfigModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","date":"2020-02-17 05:00:12","endLine":354,"groupId":"14140","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"getModules","params":"(finalbooleanstandalone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/21/ffa9a8bff2dfe8056b5935d80c38e11231dbb7.src","preCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            })\n                  .toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new IndexingServiceTuningConfigModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliOverlord.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"M"}],"commitId":"3bb9e7e53af4d5926995931e05294f83f756d85c","commitMessage":"@@@Inject things instead of subclassing everything for parallel task testing (#9353)\n\n* Inject things instead of subclassing everything for parallel task\ntesting\n\n* javadoc\n\n* fix compilation\n\n* fix wrong merge\n\n* Address comments\n","date":"2020-02-17 05:00:12","modifiedFileCount":"33","status":"M","submitter":"Jihoon Son"},{"authorTime":"2020-06-10 03:55:20","codes":[{"authorDate":"2020-02-17 05:00:12","commitOrder":17,"curCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n    binder.bind(ShuffleClient.class).to(HttpShuffleClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","date":"2020-02-17 05:00:12","endLine":412,"groupId":"3621","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"bindTaskConfigAndClients","params":"(Binderbinder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/11/60eb9240c14c0a43c8f1705a5a4567089cea1f.src","preCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n    binder.bind(ShuffleClient.class).to(HttpShuffleClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliPeon.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":395,"status":"N"},{"authorDate":"2020-06-10 03:55:20","commitOrder":17,"curCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            }).toProvider(Providers.of(null));\n            binder.bind(ShuffleClient.class).toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new IndexingServiceTuningConfigModule(),\n        new InputSourceModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","date":"2020-06-10 03:55:20","endLine":356,"groupId":"14140","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"getModules","params":"(finalbooleanstandalone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/4b/af155d229c7ba45b29ca00ba7584616695c86c.src","preCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            }).toProvider(Providers.of(null));\n            binder.bind(ShuffleClient.class).toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new IndexingServiceTuningConfigModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliOverlord.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":157,"status":"M"}],"commitId":"17cf8ea8f2cc6a4fe8e2c6e29e3b9f066a6ccc2b","commitMessage":"@@@Add Sql InputSource (#9449)\n\n* Add Sql InputSource\n\n* Add spelling\n\n* Use separate DruidModule\n\n* Change module name\n\n* Fix docs\n\n* Use sqltestutils for tests\n\n* Add additional tests\n\n* Fix inspection\n\n* Add module test\n\n* Fix md in docs\n\n* Remove annotation\n\nCo-authored-by: Atul Mohan <atulmohan@yahoo-inc.com>","date":"2020-06-10 03:55:20","modifiedFileCount":"9","status":"M","submitter":"Atul Mohan"},{"authorTime":"2020-08-27 08:08:12","codes":[{"authorDate":"2020-02-17 05:00:12","commitOrder":18,"curCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n    binder.bind(ShuffleClient.class).to(HttpShuffleClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","date":"2020-02-17 05:00:12","endLine":412,"groupId":"3621","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"bindTaskConfigAndClients","params":"(Binderbinder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/11/60eb9240c14c0a43c8f1705a5a4567089cea1f.src","preCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n    binder.bind(ShuffleClient.class).to(HttpShuffleClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliPeon.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":395,"status":"N"},{"authorDate":"2020-08-27 08:08:12","commitOrder":18,"curCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            }).toProvider(Providers.of(null));\n            binder.bind(ShuffleClient.class).toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(new NoopChatHandlerProvider()));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new IndexingServiceTuningConfigModule(),\n        new InputSourceModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","date":"2020-08-27 08:08:12","endLine":357,"groupId":"23323","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"getModules","params":"(finalbooleanstandalone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/8e/f1eca003b432bce1b307e2624fb274e02eea5b.src","preCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            }).toProvider(Providers.of(null));\n            binder.bind(ShuffleClient.class).toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(null));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new IndexingServiceTuningConfigModule(),\n        new InputSourceModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliOverlord.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":158,"status":"M"}],"commitId":"f82fd22fa7de175200b7127c34c2eb2900bf7317","commitMessage":"@@@Move tools for indexing to TaskToolbox instead of injecting them in constructor (#10308)\n\n* Move tools for indexing to TaskToolbox instead of injecting them in constructor\n\n* oops.  other changes\n\n* fix test\n\n* unnecessary new file\n\n* fix test\n\n* fix build","date":"2020-08-27 08:08:12","modifiedFileCount":"67","status":"M","submitter":"Jihoon Son"},{"authorTime":"2020-09-29 14:50:38","codes":[{"authorDate":"2020-02-17 05:00:12","commitOrder":19,"curCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n    binder.bind(ShuffleClient.class).to(HttpShuffleClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","date":"2020-02-17 05:00:12","endLine":412,"groupId":"3621","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"bindTaskConfigAndClients","params":"(Binderbinder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/11/60eb9240c14c0a43c8f1705a5a4567089cea1f.src","preCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n    binder.bind(ShuffleClient.class).to(HttpShuffleClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliPeon.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":395,"status":"N"},{"authorDate":"2020-09-29 14:50:38","commitOrder":19,"curCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n            binder.bind(TaskSlotCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            }).toProvider(Providers.of(null));\n            binder.bind(ShuffleClient.class).toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(new NoopChatHandlerProvider()));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new IndexingServiceTuningConfigModule(),\n        new InputSourceModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","date":"2020-09-29 14:50:38","endLine":359,"groupId":"23323","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"getModules","params":"(finalbooleanstandalone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/50/cef33b0a72069277689780979cafb9436f2dac.src","preCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            }).toProvider(Providers.of(null));\n            binder.bind(ShuffleClient.class).toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(new NoopChatHandlerProvider()));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new IndexingServiceTuningConfigModule(),\n        new InputSourceModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliOverlord.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":159,"status":"M"}],"commitId":"8168e14e9224c9459efda07b038269815975cf50","commitMessage":"@@@Adding task slot count metrics to Druid Overlord (#10379)\n\n* Adding more worker metrics to Druid Overlord\n\n* Changing the nomenclature from worker to peon as that represents the metrics that we want to monitor better\n\n* Few more instance of worker usage replaced with peon\n\n* Modifying the peon idle count logic to only use eligible workers available capacity\n\n* Changing the naming to task slot count instead of peon\n\n* Adding some unit test coverage for the new test runner apis\n\n* Addressing Review Comments\n\n* Modifying the TaskSlotCountStatsProvider apis so that overlords which are not leader do not emit these metrics\n\n* Fixing the spelling issue in the docs\n\n* Setting the annotation Nullable on the TaskSlotCountStatsProvider methods","date":"2020-09-29 14:50:38","modifiedFileCount":"14","status":"M","submitter":"Mainak Ghosh"},{"authorTime":"2021-05-08 05:29:48","codes":[{"authorDate":"2020-02-17 05:00:12","commitOrder":20,"curCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n    binder.bind(ShuffleClient.class).to(HttpShuffleClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","date":"2020-02-17 05:00:12","endLine":412,"groupId":"3621","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"bindTaskConfigAndClients","params":"(Binderbinder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/11/60eb9240c14c0a43c8f1705a5a4567089cea1f.src","preCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n    binder.bind(ShuffleClient.class).to(HttpShuffleClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliPeon.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":395,"status":"N"},{"authorDate":"2021-05-08 05:29:48","commitOrder":20,"curCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task.default\", DefaultTaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n            binder.bind(TaskSlotCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            }).toProvider(Providers.of(null));\n            binder.bind(ShuffleClient.class).toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(new NoopChatHandlerProvider()));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new IndexingServiceTuningConfigModule(),\n        new InputSourceModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","date":"2021-05-08 05:29:48","endLine":361,"groupId":"23323","id":24,"instanceNumber":2,"isCurCommit":1,"methodName":"getModules","params":"(finalbooleanstandalone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/84/b2512df949ac164442862f132b295341488397.src","preCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n            binder.bind(TaskSlotCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            }).toProvider(Providers.of(null));\n            binder.bind(ShuffleClient.class).toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(new NoopChatHandlerProvider()));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new IndexingServiceTuningConfigModule(),\n        new InputSourceModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliOverlord.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"}],"commitId":"2df42143aec6c50e9ac31d89cd75749d10d37a3d","commitMessage":"@@@Fix idempotence of segment allocation and task report apis in native batch ingestion (#11189)\n\n* Fix idempotence of segment allocation and task report apis in native\nbatch ingestion\n\n* better error and javadoc\n\n* checkstyle and dependency\n\n* fix tests and add more tests\n\n* task config instead of context; add doc\n\n* unused import and dependency\n\n* typo in doc\n\n* fix unintended changes\n\n* fix wrong import\n\n* remove unnecessary error handling\n\n* add task context back\n\n* default task context\n\n* fix test and doc\n\n* address comments\n\n* unused imports","date":"2021-05-08 05:29:48","modifiedFileCount":"72","status":"M","submitter":"Jihoon Son"},{"authorTime":"2021-05-08 05:29:48","codes":[{"authorDate":"2021-07-27 12:29:43","commitOrder":21,"curCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","date":"2021-07-27 12:29:43","endLine":435,"groupId":"102394","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"bindTaskConfigAndClients","params":"(Binderbinder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/8c/1fb005b61b87c45f4651db002eee552777ddd0.src","preCode":"  static void bindTaskConfigAndClients(Binder binder)\n  {\n    binder.bind(TaskToolboxFactory.class).in(LazySingleton.class);\n\n    JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n    JsonConfigProvider.bind(binder, \"druid.peon.taskActionClient.retry\", RetryPolicyConfig.class);\n\n    configureTaskActionClient(binder);\n    binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n    binder.bind(ShuffleClient.class).to(HttpShuffleClient.class).in(LazySingleton.class);\n\n    binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>(){})\n          .to(ParallelIndexTaskClientFactory.class)\n          .in(LazySingleton.class);\n\n    binder.bind(RetryPolicyFactory.class).in(LazySingleton.class);\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliPeon.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":419,"status":"M"},{"authorDate":"2021-05-08 05:29:48","commitOrder":21,"curCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task.default\", DefaultTaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n            binder.bind(TaskSlotCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            }).toProvider(Providers.of(null));\n            binder.bind(ShuffleClient.class).toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(new NoopChatHandlerProvider()));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new IndexingServiceTuningConfigModule(),\n        new InputSourceModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","date":"2021-05-08 05:29:48","endLine":361,"groupId":"102394","id":26,"instanceNumber":2,"isCurCommit":1,"methodName":"getModules","params":"(finalbooleanstandalone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/84/b2512df949ac164442862f132b295341488397.src","preCode":"  protected List<? extends Module> getModules(final boolean standalone)\n  {\n    return ImmutableList.of(\n        new Module()\n        {\n          @Override\n          public void configure(Binder binder)\n          {\n            if (standalone) {\n              binder.bindConstant()\n                    .annotatedWith(Names.named(\"serviceName\"))\n                    .to(IndexingServiceSelectorConfig.DEFAULT_SERVICE_NAME);\n              binder.bindConstant().annotatedWith(Names.named(\"servicePort\")).to(8090);\n              binder.bindConstant().annotatedWith(Names.named(\"tlsServicePort\")).to(8290);\n            }\n\n            JsonConfigProvider.bind(binder, \"druid.coordinator.asOverlord\", CoordinatorOverlordServiceConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.queue\", TaskQueueConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.tasklock\", TaskLockConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task\", TaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.task.default\", DefaultTaskConfig.class);\n            JsonConfigProvider.bind(binder, \"druid.indexer.auditlog\", TaskAuditLogConfig.class);\n\n            binder.bind(TaskMaster.class).in(ManageLifecycle.class);\n            binder.bind(TaskCountStatsProvider.class).to(TaskMaster.class);\n            binder.bind(TaskSlotCountStatsProvider.class).to(TaskMaster.class);\n\n            binder.bind(TaskLogStreamer.class).to(SwitchingTaskLogStreamer.class).in(LazySingleton.class);\n            binder.bind(\n                new TypeLiteral<List<TaskLogStreamer>>()\n                {\n                }\n            )\n                  .toProvider(\n                      new ListProvider<TaskLogStreamer>()\n                          .add(TaskRunnerTaskLogStreamer.class)\n                          .add(TaskLogs.class)\n                  )\n                  .in(LazySingleton.class);\n\n            binder.bind(TaskActionClientFactory.class).to(LocalTaskActionClientFactory.class).in(LazySingleton.class);\n            binder.bind(TaskActionToolbox.class).in(LazySingleton.class);\n            binder.bind(TaskLockbox.class).in(LazySingleton.class);\n            binder.bind(TaskStorageQueryAdapter.class).in(LazySingleton.class);\n            binder.bind(IndexerMetadataStorageAdapter.class).in(LazySingleton.class);\n            binder.bind(SupervisorManager.class).in(LazySingleton.class);\n\n            binder.bind(IndexingServiceClient.class).to(HttpIndexingServiceClient.class).in(LazySingleton.class);\n            binder.bind(new TypeLiteral<IndexTaskClientFactory<ParallelIndexSupervisorTaskClient>>()\n            {\n            }).toProvider(Providers.of(null));\n            binder.bind(ShuffleClient.class).toProvider(Providers.of(null));\n            binder.bind(ChatHandlerProvider.class).toProvider(Providers.of(new NoopChatHandlerProvider()));\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.task.rowIngestionMeters.type\",\n                Key.get(RowIngestionMetersFactory.class),\n                Key.get(DropwizardRowIngestionMetersFactory.class)\n            );\n            final MapBinder<String, RowIngestionMetersFactory> rowIngestionMetersHandlerProviderBinder =\n                PolyBind.optionBinder(binder, Key.get(RowIngestionMetersFactory.class));\n            rowIngestionMetersHandlerProviderBinder\n                .addBinding(\"dropwizard\")\n                .to(DropwizardRowIngestionMetersFactory.class)\n                .in(LazySingleton.class);\n            binder.bind(DropwizardRowIngestionMetersFactory.class).in(LazySingleton.class);\n\n            configureTaskStorage(binder);\n            configureAutoscale(binder);\n            configureRunners(binder);\n            configureOverlordHelpers(binder);\n\n            binder.bind(AuditManager.class)\n                  .toProvider(AuditManagerProvider.class)\n                  .in(ManageLifecycle.class);\n\n            if (standalone) {\n              binder.bind(RedirectFilter.class).in(LazySingleton.class);\n              binder.bind(RedirectInfo.class).to(OverlordRedirectInfo.class).in(LazySingleton.class);\n              binder.bind(JettyServerInitializer.class)\n                    .to(OverlordJettyServerInitializer.class)\n                    .in(LazySingleton.class);\n            }\n\n            Jerseys.addResource(binder, OverlordResource.class);\n            Jerseys.addResource(binder, SupervisorResource.class);\n            Jerseys.addResource(binder, HttpRemoteTaskRunnerResource.class);\n\n\n            binder.bind(AppenderatorsManager.class)\n                  .to(DummyForInjectionAppenderatorsManager.class)\n                  .in(LazySingleton.class);\n\n            if (standalone) {\n              LifecycleModule.register(binder, Server.class);\n            }\n\n            bindNodeRoleAndAnnouncer(\n                binder,\n                IndexingService.class,\n                DiscoverySideEffectsProvider.builder(NodeRole.OVERLORD).build()\n            );\n\n            Jerseys.addResource(binder, SelfDiscoveryResource.class);\n            LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource.class));\n          }\n\n          private void configureTaskStorage(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.storage\", TaskStorageConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.storage.type\",\n                Key.get(TaskStorage.class),\n                Key.get(HeapMemoryTaskStorage.class)\n            );\n            final MapBinder<String, TaskStorage> storageBinder =\n                PolyBind.optionBinder(binder, Key.get(TaskStorage.class));\n\n            storageBinder.addBinding(\"local\").to(HeapMemoryTaskStorage.class);\n            binder.bind(HeapMemoryTaskStorage.class).in(LazySingleton.class);\n\n            storageBinder.addBinding(\"metadata\").to(MetadataTaskStorage.class).in(ManageLifecycle.class);\n            binder.bind(MetadataTaskStorage.class).in(LazySingleton.class);\n          }\n\n          private void configureRunners(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.worker\", WorkerConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.runner.type\",\n                Key.get(TaskRunnerFactory.class),\n                Key.get(ForkingTaskRunnerFactory.class)\n            );\n            final MapBinder<String, TaskRunnerFactory> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(TaskRunnerFactory.class)\n            );\n\n            IndexingServiceModuleHelper.configureTaskRunnerConfigs(binder);\n            biddy.addBinding(\"local\").to(ForkingTaskRunnerFactory.class);\n            binder.bind(ForkingTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(RemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(RemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(RemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            biddy.addBinding(HttpRemoteTaskRunnerFactory.TYPE_NAME)\n                 .to(HttpRemoteTaskRunnerFactory.class)\n                 .in(LazySingleton.class);\n            binder.bind(HttpRemoteTaskRunnerFactory.class).in(LazySingleton.class);\n\n            JacksonConfigProvider.bind(binder, WorkerBehaviorConfig.CONFIG_KEY, WorkerBehaviorConfig.class, null);\n          }\n\n          private void configureAutoscale(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", ProvisioningSchedulerConfig.class);\n            JsonConfigProvider.bind(\n                binder,\n                \"druid.indexer.autoscale\",\n                PendingTaskBasedWorkerProvisioningConfig.class\n            );\n            JsonConfigProvider.bind(binder, \"druid.indexer.autoscale\", SimpleWorkerProvisioningConfig.class);\n\n            PolyBind.createChoice(\n                binder,\n                \"druid.indexer.autoscale.strategy.type\",\n                Key.get(ProvisioningStrategy.class),\n                Key.get(SimpleWorkerProvisioningStrategy.class)\n            );\n            final MapBinder<String, ProvisioningStrategy> biddy = PolyBind.optionBinder(\n                binder,\n                Key.get(ProvisioningStrategy.class)\n            );\n            biddy.addBinding(\"simple\").to(SimpleWorkerProvisioningStrategy.class);\n            biddy.addBinding(\"pendingTaskBased\").to(PendingTaskBasedWorkerProvisioningStrategy.class);\n          }\n\n          private void configureOverlordHelpers(Binder binder)\n          {\n            JsonConfigProvider.bind(binder, \"druid.indexer.logs.kill\", TaskLogAutoCleanerConfig.class);\n            Multibinder.newSetBinder(binder, OverlordHelper.class)\n                       .addBinding()\n                       .to(TaskLogAutoCleaner.class);\n          }\n        },\n        new IndexingServiceFirehoseModule(),\n        new IndexingServiceInputSourceModule(),\n        new IndexingServiceTaskLogsModule(),\n        new IndexingServiceTuningConfigModule(),\n        new InputSourceModule(),\n        new SupervisorModule(),\n        new LookupSerdeModule(),\n        new SamplerModule()\n    );\n  }\n","realPath":"services/src/main/java/org/apache/druid/cli/CliOverlord.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"N"}],"commitId":"c068906fca4082737e059418d369eb0711500c07","commitMessage":"@@@Make intermediate store for shuffle tasks an extension point (#11492)\n\n* add interface\n\n* add docs\n\n* fix errors\n\n* fix injection\n\n* fix injection\n\n* update javadoc","date":"2021-07-27 12:29:43","modifiedFileCount":"9","status":"M","submitter":"Maytas Monsereenusorn"}]
