[{"authorTime":"2019-04-24 10:40:29","codes":[{"authorDate":"2019-04-24 10:40:29","commitOrder":1,"curCode":"  @Test public void writeTagField_matchesWire() {\n    MapEntry<String, String> entry = entry(\"clnt/finagle.version\", \"6.45.0\");\n    TagField field = new TagField(TAG_KEY);\n    Buffer zipkinBytes = Buffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.toByteArray())\n      .containsExactly(oneField.encode());\n  }\n","date":"2019-04-24 10:40:29","endLine":225,"groupId":"1308","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"writeTagField_matchesWire","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/77/37103cecd764f7747cfacb454e54548d859ae2.src","preCode":"  @Test public void writeTagField_matchesWire() {\n    MapEntry<String, String> entry = entry(\"clnt/finagle.version\", \"6.45.0\");\n    TagField field = new TagField(TAG_KEY);\n    Buffer zipkinBytes = Buffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.toByteArray())\n      .containsExactly(oneField.encode());\n  }\n","realPath":"benchmarks/src/test/java/zipkin2/internal/Proto3CodecInteropTest.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":216,"status":"B"},{"authorDate":"2019-04-24 10:40:29","commitOrder":1,"curCode":"  @Test public void writeTagField_matchesWire_emptyValue() {\n    MapEntry<String, String> entry = entry(\"error\", \"\");\n    TagField field = new TagField(TAG_KEY);\n    Buffer zipkinBytes = Buffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.toByteArray())\n      .containsExactly(oneField.encode());\n  }\n","date":"2019-04-24 10:40:29","endLine":236,"groupId":"1308","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"writeTagField_matchesWire_emptyValue","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/77/37103cecd764f7747cfacb454e54548d859ae2.src","preCode":"  @Test public void writeTagField_matchesWire_emptyValue() {\n    MapEntry<String, String> entry = entry(\"error\", \"\");\n    TagField field = new TagField(TAG_KEY);\n    Buffer zipkinBytes = Buffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.toByteArray())\n      .containsExactly(oneField.encode());\n  }\n","realPath":"benchmarks/src/test/java/zipkin2/internal/Proto3CodecInteropTest.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":227,"status":"B"}],"commitId":"50a65e2b3229efd0868d0f94120284576de54f9d","commitMessage":"@@@Replaces fragile proto test setup with Square Wire (#2532)\n\nSquare Wire is a lot simpler setup.  and it doesn't require installation\nof binaries to compile proto files. This helps us and also anyone who\nwill be doing ASF source verification.\n\n","date":"2019-04-24 10:40:29","modifiedFileCount":"2","status":"B","submitter":"Adrian Cole"},{"authorTime":"2019-05-11 14:36:24","codes":[{"authorDate":"2019-05-11 14:36:24","commitOrder":2,"curCode":"  @Test public void writeTagField_matchesWire() {\n    MapEntry<String, String> entry = entry(\"clnt/finagle.version\", \"6.45.0\");\n    TagField field = new TagField(TAG_KEY);\n    Buffer zipkinBytes = Buffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.toByteArrayUnsafe())\n      .containsExactly(oneField.encode());\n  }\n","date":"2019-05-11 15:51:24","endLine":225,"groupId":"1308","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"writeTagField_matchesWire","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/2a/213790cc9ccdba813ed6b340275f15dbb16a43.src","preCode":"  @Test public void writeTagField_matchesWire() {\n    MapEntry<String, String> entry = entry(\"clnt/finagle.version\", \"6.45.0\");\n    TagField field = new TagField(TAG_KEY);\n    Buffer zipkinBytes = Buffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.toByteArray())\n      .containsExactly(oneField.encode());\n  }\n","realPath":"benchmarks/src/test/java/zipkin2/internal/Proto3CodecInteropTest.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":216,"status":"M"},{"authorDate":"2019-05-11 14:36:24","commitOrder":2,"curCode":"  @Test public void writeTagField_matchesWire_emptyValue() {\n    MapEntry<String, String> entry = entry(\"error\", \"\");\n    TagField field = new TagField(TAG_KEY);\n    Buffer zipkinBytes = Buffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.toByteArrayUnsafe())\n      .containsExactly(oneField.encode());\n  }\n","date":"2019-05-11 15:51:24","endLine":236,"groupId":"1308","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"writeTagField_matchesWire_emptyValue","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/2a/213790cc9ccdba813ed6b340275f15dbb16a43.src","preCode":"  @Test public void writeTagField_matchesWire_emptyValue() {\n    MapEntry<String, String> entry = entry(\"error\", \"\");\n    TagField field = new TagField(TAG_KEY);\n    Buffer zipkinBytes = Buffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.toByteArray())\n      .containsExactly(oneField.encode());\n  }\n","realPath":"benchmarks/src/test/java/zipkin2/internal/Proto3CodecInteropTest.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":227,"status":"M"}],"commitId":"f2ac83c90ab12cfdf8761306f75dc6c9f00f5fd6","commitMessage":"@@@Remove array copy when decoding UTF-8 field.\n","date":"2019-05-11 15:51:24","modifiedFileCount":"17","status":"M","submitter":"Anuraag Agrawal"},{"authorTime":"2019-05-12 08:07:34","codes":[{"authorDate":"2019-05-12 08:07:34","commitOrder":3,"curCode":"  @Test public void writeTagField_matchesWire() {\n    MapEntry<String, String> entry = entry(\"clnt/finagle.version\", \"6.45.0\");\n    TagField field = new TagField(TAG_KEY);\n    UnsafeBuffer zipkinBytes = UnsafeBuffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.unwrap())\n      .containsExactly(oneField.encode());\n  }\n","date":"2019-05-12 08:07:34","endLine":225,"groupId":"1308","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"writeTagField_matchesWire","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/d4/755387228892f1c7c5ae6894420018c7ad937f.src","preCode":"  @Test public void writeTagField_matchesWire() {\n    MapEntry<String, String> entry = entry(\"clnt/finagle.version\", \"6.45.0\");\n    TagField field = new TagField(TAG_KEY);\n    Buffer zipkinBytes = Buffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.toByteArrayUnsafe())\n      .containsExactly(oneField.encode());\n  }\n","realPath":"benchmarks/src/test/java/zipkin2/internal/Proto3CodecInteropTest.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":216,"status":"M"},{"authorDate":"2019-05-12 08:07:34","commitOrder":3,"curCode":"  @Test public void writeTagField_matchesWire_emptyValue() {\n    MapEntry<String, String> entry = entry(\"error\", \"\");\n    TagField field = new TagField(TAG_KEY);\n    UnsafeBuffer zipkinBytes = UnsafeBuffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.unwrap())\n      .containsExactly(oneField.encode());\n  }\n","date":"2019-05-12 08:07:34","endLine":236,"groupId":"1308","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"writeTagField_matchesWire_emptyValue","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/d4/755387228892f1c7c5ae6894420018c7ad937f.src","preCode":"  @Test public void writeTagField_matchesWire_emptyValue() {\n    MapEntry<String, String> entry = entry(\"error\", \"\");\n    TagField field = new TagField(TAG_KEY);\n    Buffer zipkinBytes = Buffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.toByteArrayUnsafe())\n      .containsExactly(oneField.encode());\n  }\n","realPath":"benchmarks/src/test/java/zipkin2/internal/Proto3CodecInteropTest.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":227,"status":"M"}],"commitId":"09a441f4b4e8734058e8d023367f826b845e9dea","commitMessage":"@@@Folds Buffer tree into UnsafeBuffer to improve performance (#2586)\n\nRecent optimizations required peeking at the underlying byte array. This\nchange formalizes the buffer as one that is specialized for being array\nbacked (and writes are unsafe eg not bounds checked).\n\nThe results are now almost the same as google's proto library.  despite\nthis library being smaller and including proto.  json and thrift codecs\nand a functional Zipkin storage engine:\n\nComparison\n```\nProtoCodecBenchmarks.bytes_protobufDecoder:bytes_protobufDecoder?p0.99       sample            1953.710                us/op\nProtoCodecBenchmarks.bytes_protobufDecoder:?gc.alloc.rate.norm               sample     15  2023206.265 ?     32.203    B/op\nProtoCodecBenchmarks.bytes_wireDecoder:bytes_wireDecoder?p0.99               sample            2351.104                us/op\nProtoCodecBenchmarks.bytes_wireDecoder:?gc.alloc.rate.norm                   sample     15  2435408.568 ?     53.612    B/op\n```\n\nBefore\n```\nProtoCodecBenchmarks.bytes_zipkinDecoder:bytes_zipkinDecoder?p0.99           sample            2162.688                us/op\nProtoCodecBenchmarks.bytes_zipkinDecoder:?gc.alloc.rate.norm                 sample     15  2095172.026 ?     45.379    B/op\n```\n\nAfter\n```\nProtoCodecBenchmarks.bytes_zipkinDecoder:bytes_zipkinDecoder?p0.99           sample            1996.800                us/op\nProtoCodecBenchmarks.bytes_zipkinDecoder:?gc.alloc.rate.norm                 sample     15  2095168.617 ?     36.985    B/op\n```\n\nFYI: While this is array backed.  it doesn't imply allocating a new array\nper span. Those looking to read large amounts of data can use this by\nslicing a buffer and filling for each length-prefixed byte string.","date":"2019-05-12 08:07:34","modifiedFileCount":"24","status":"M","submitter":"Adrian Cole"},{"authorTime":"2019-05-15 14:21:45","codes":[{"authorDate":"2019-05-15 14:21:45","commitOrder":4,"curCode":"  @Test public void writeTagField_matchesWire() {\n    MapEntry<String, String> entry = entry(\"clnt/finagle.version\", \"6.45.0\");\n    TagField field = new TagField(TAG_KEY);\n    byte[] zipkinBytes = new byte[field.sizeInBytes(entry)];\n    field.write(WriteBuffer.wrap(zipkinBytes, 0), entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes)\n      .containsExactly(oneField.encode());\n  }\n","date":"2019-05-15 14:21:45","endLine":225,"groupId":"10307","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"writeTagField_matchesWire","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/64/d50038bc5ef94f5914acf5c0520a8f243b2eaa.src","preCode":"  @Test public void writeTagField_matchesWire() {\n    MapEntry<String, String> entry = entry(\"clnt/finagle.version\", \"6.45.0\");\n    TagField field = new TagField(TAG_KEY);\n    UnsafeBuffer zipkinBytes = UnsafeBuffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.unwrap())\n      .containsExactly(oneField.encode());\n  }\n","realPath":"benchmarks/src/test/java/zipkin2/internal/Proto3CodecInteropTest.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":216,"status":"M"},{"authorDate":"2019-05-15 14:21:45","commitOrder":4,"curCode":"  @Test public void writeTagField_matchesWire_emptyValue() {\n    MapEntry<String, String> entry = entry(\"error\", \"\");\n    TagField field = new TagField(TAG_KEY);\n    byte[] zipkinBytes = new byte[field.sizeInBytes(entry)];\n    field.write(WriteBuffer.wrap(zipkinBytes, 0), entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes)\n      .containsExactly(oneField.encode());\n  }\n","date":"2019-05-15 14:21:45","endLine":236,"groupId":"10307","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"writeTagField_matchesWire_emptyValue","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/64/d50038bc5ef94f5914acf5c0520a8f243b2eaa.src","preCode":"  @Test public void writeTagField_matchesWire_emptyValue() {\n    MapEntry<String, String> entry = entry(\"error\", \"\");\n    TagField field = new TagField(TAG_KEY);\n    UnsafeBuffer zipkinBytes = UnsafeBuffer.allocate(field.sizeInBytes(entry));\n    field.write(zipkinBytes, entry);\n\n    Span oneField = new Span.Builder().tags(singletonMap(entry.key, entry.value)).build();\n    assertThat(zipkinBytes.unwrap())\n      .containsExactly(oneField.encode());\n  }\n","realPath":"benchmarks/src/test/java/zipkin2/internal/Proto3CodecInteropTest.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":227,"status":"M"}],"commitId":"feb151f2f9e5a1a10020c8c7eb5c6129112663da","commitMessage":"@@@Makes SpanBytesDecoder work on ByteBuffer (#2589)\n\n* Makes SpanBytesDecoder work on ByteBuffer\n\nInternally.  this also covers InputStream.\n\nThis was easier (though not easy) due to splitting how we handle\nencoding from decoding.\n\nIncidentally.  the jar size of zipkin is smaller still vs the last\nrelease.\n\nFixes #2435\n\n* whoops forgot the important parts\n\n* de-optimizes for thrift in order to increase clarity\n\n* bug\n\n* Adds json comparison benchmarks\n\n* just review feedback\n\n* mah endian\n\n* less code\n\n* bench\n","date":"2019-05-15 14:21:45","modifiedFileCount":"37","status":"M","submitter":"Adrian Cole"}]
