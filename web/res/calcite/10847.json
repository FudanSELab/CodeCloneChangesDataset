[{"authorTime":"2014-11-14 09:39:29","codes":[{"authorDate":"2014-11-14 09:39:29","commitOrder":1,"curCode":"  @Test public void testBackTickIdentifier() {\n    quoting = Quoting.BACK_TICK;\n    checkExp(\"ab\", \"`AB`\");\n    checkExp(\"     `a  \\\" b!c`\", \"`a  \\\" b!c`\");\n    checkExpFails(\"     ^\\\"^a  \\\"\\\" b!c\\\"\", \"(?s).*Encountered.*\");\n\n    checkExpFails(\"^\\\"^x`y`z\\\"\", \"(?s).*Encountered.*\");\n    checkExp(\"`x``y``z`\", \"`x``y``z`\");\n\n    checkExp(\"myMap[field] + myArray[1 + 2]\",\n        \"(`MYMAP`[`FIELD`] + `MYARRAY`[(1 + 2)])\");\n  }\n","date":"2014-11-14 09:39:34","endLine":860,"groupId":"10035","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testBackTickIdentifier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/1a/e977745bb2356d254a45d8c8d3748b6dec754f.src","preCode":"  @Test public void testBackTickIdentifier() {\n    quoting = Quoting.BACK_TICK;\n    checkExp(\"ab\", \"`AB`\");\n    checkExp(\"     `a  \\\" b!c`\", \"`a  \\\" b!c`\");\n    checkExpFails(\"     ^\\\"^a  \\\"\\\" b!c\\\"\", \"(?s).*Encountered.*\");\n\n    checkExpFails(\"^\\\"^x`y`z\\\"\", \"(?s).*Encountered.*\");\n    checkExp(\"`x``y``z`\", \"`x``y``z`\");\n\n    checkExp(\"myMap[field] + myArray[1 + 2]\",\n        \"(`MYMAP`[`FIELD`] + `MYARRAY`[(1 + 2)])\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":849,"status":"B"},{"authorDate":"2014-11-14 09:39:29","commitOrder":1,"curCode":"  @Test public void testBracketIdentifier() {\n    quoting = Quoting.BRACKET;\n    checkExp(\"ab\", \"`AB`\");\n    checkExp(\"     [a  \\\" b!c]\", \"`a  \\\" b!c`\");\n    checkExpFails(\"     ^`^a  \\\" b!c`\", \"(?s).*Encountered.*\");\n    checkExpFails(\"     ^\\\"^a  \\\"\\\" b!c\\\"\", \"(?s).*Encountered.*\");\n\n    checkExp(\"[x`y`z]\", \"`x``y``z`\");\n    checkExpFails(\"^\\\"^x`y`z\\\"\", \"(?s).*Encountered.*\");\n    checkExpFails(\"^`^x``y``z`\", \"(?s).*Encountered.*\");\n\n    checkExp(\"[anything [even brackets]] is].[ok]\",\n        \"`anything [even brackets] is`.`ok`\");\n\n    \r\n    \r\n    check(\"select * from myMap[field], myArray[1 + 2]\",\n        \"SELECT *\\n\"\n        + \"FROM `MYMAP` AS `field`,\\n\"\n        + \"`MYARRAY` AS `1 + 2`\");\n    check(\"select * from myMap [field], myArray [1 + 2]\",\n        \"SELECT *\\n\"\n        + \"FROM `MYMAP` AS `field`,\\n\"\n        + \"`MYARRAY` AS `1 + 2`\");\n  }\n","date":"2014-11-14 09:39:34","endLine":886,"groupId":"16460","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testBracketIdentifier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/1a/e977745bb2356d254a45d8c8d3748b6dec754f.src","preCode":"  @Test public void testBracketIdentifier() {\n    quoting = Quoting.BRACKET;\n    checkExp(\"ab\", \"`AB`\");\n    checkExp(\"     [a  \\\" b!c]\", \"`a  \\\" b!c`\");\n    checkExpFails(\"     ^`^a  \\\" b!c`\", \"(?s).*Encountered.*\");\n    checkExpFails(\"     ^\\\"^a  \\\"\\\" b!c\\\"\", \"(?s).*Encountered.*\");\n\n    checkExp(\"[x`y`z]\", \"`x``y``z`\");\n    checkExpFails(\"^\\\"^x`y`z\\\"\", \"(?s).*Encountered.*\");\n    checkExpFails(\"^`^x``y``z`\", \"(?s).*Encountered.*\");\n\n    checkExp(\"[anything [even brackets]] is].[ok]\",\n        \"`anything [even brackets] is`.`ok`\");\n\n    \r\n    \r\n    check(\"select * from myMap[field], myArray[1 + 2]\",\n        \"SELECT *\\n\"\n        + \"FROM `MYMAP` AS `field`,\\n\"\n        + \"`MYARRAY` AS `1 + 2`\");\n    check(\"select * from myMap [field], myArray [1 + 2]\",\n        \"SELECT *\\n\"\n        + \"FROM `MYMAP` AS `field`,\\n\"\n        + \"`MYARRAY` AS `1 + 2`\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":862,"status":"B"}],"commitId":"a611d645ad754844a39f3d98f5f814f13dbd9404","commitMessage":"@@@[CALCITE-296] Re-organize package structure;\n[CALCITE-419] Naming convention for planner rules\n\nThis change only renames files (and deletes some obsolete files). There are no content changes.\n","date":"2014-11-14 09:39:34","modifiedFileCount":"0","status":"B","submitter":"Julian Hyde"},{"authorTime":"2018-12-06 17:33:55","codes":[{"authorDate":"2018-12-06 17:33:55","commitOrder":2,"curCode":"  @Test public void testBackTickIdentifier() {\n    quoting = Quoting.BACK_TICK;\n    checkExp(\"ab\", \"`AB`\");\n    checkExp(\"     `a  \\\" b!c`\", \"`a  \\\" b!c`\");\n    checkExpFails(\"     ^\\\"^a  \\\"\\\" b!c\\\"\", \"(?s).*Encountered.*\");\n\n    checkExpFails(\"^\\\"^x`y`z\\\"\", \"(?s).*Encountered.*\");\n    checkExp(\"`x``y``z`\", \"`x``y``z`\");\n\n    checkExp(\"myMap[field] + myArray[1 + 2]\",\n        \"(`MYMAP`[`FIELD`] + `MYARRAY`[(1 + 2)])\");\n\n    getTester().checkNode(\"VALUES a\", isQuoted(0, false));\n    getTester().checkNode(\"VALUES `a`\", isQuoted(0, true));\n  }\n","date":"2019-03-08 15:45:55","endLine":1867,"groupId":"10035","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testBackTickIdentifier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b5/3df4d67affd2e0407070797bfcf39a2e1fc9e5.src","preCode":"  @Test public void testBackTickIdentifier() {\n    quoting = Quoting.BACK_TICK;\n    checkExp(\"ab\", \"`AB`\");\n    checkExp(\"     `a  \\\" b!c`\", \"`a  \\\" b!c`\");\n    checkExpFails(\"     ^\\\"^a  \\\"\\\" b!c\\\"\", \"(?s).*Encountered.*\");\n\n    checkExpFails(\"^\\\"^x`y`z\\\"\", \"(?s).*Encountered.*\");\n    checkExp(\"`x``y``z`\", \"`x``y``z`\");\n\n    checkExp(\"myMap[field] + myArray[1 + 2]\",\n        \"(`MYMAP`[`FIELD`] + `MYARRAY`[(1 + 2)])\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1853,"status":"M"},{"authorDate":"2018-12-06 17:33:55","commitOrder":2,"curCode":"  @Test public void testBracketIdentifier() {\n    quoting = Quoting.BRACKET;\n    checkExp(\"ab\", \"`AB`\");\n    checkExp(\"     [a  \\\" b!c]\", \"`a  \\\" b!c`\");\n    checkExpFails(\"     ^`^a  \\\" b!c`\", \"(?s).*Encountered.*\");\n    checkExpFails(\"     ^\\\"^a  \\\"\\\" b!c\\\"\", \"(?s).*Encountered.*\");\n\n    checkExp(\"[x`y`z]\", \"`x``y``z`\");\n    checkExpFails(\"^\\\"^x`y`z\\\"\", \"(?s).*Encountered.*\");\n    checkExpFails(\"^`^x``y``z`\", \"(?s).*Encountered.*\");\n\n    checkExp(\"[anything [even brackets]] is].[ok]\",\n        \"`anything [even brackets] is`.`ok`\");\n\n    \r\n    \r\n    check(\"select * from myMap[field], myArray[1 + 2]\",\n        \"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n    check(\"select * from myMap [field], myArray [1 + 2]\",\n        \"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n\n    getTester().checkNode(\"VALUES a\", isQuoted(0, false));\n    getTester().checkNode(\"VALUES [a]\", isQuoted(0, true));\n  }\n","date":"2019-03-08 15:45:55","endLine":1896,"groupId":"16460","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testBracketIdentifier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b5/3df4d67affd2e0407070797bfcf39a2e1fc9e5.src","preCode":"  @Test public void testBracketIdentifier() {\n    quoting = Quoting.BRACKET;\n    checkExp(\"ab\", \"`AB`\");\n    checkExp(\"     [a  \\\" b!c]\", \"`a  \\\" b!c`\");\n    checkExpFails(\"     ^`^a  \\\" b!c`\", \"(?s).*Encountered.*\");\n    checkExpFails(\"     ^\\\"^a  \\\"\\\" b!c\\\"\", \"(?s).*Encountered.*\");\n\n    checkExp(\"[x`y`z]\", \"`x``y``z`\");\n    checkExpFails(\"^\\\"^x`y`z\\\"\", \"(?s).*Encountered.*\");\n    checkExpFails(\"^`^x``y``z`\", \"(?s).*Encountered.*\");\n\n    checkExp(\"[anything [even brackets]] is].[ok]\",\n        \"`anything [even brackets] is`.`ok`\");\n\n    \r\n    \r\n    check(\"select * from myMap[field], myArray[1 + 2]\",\n        \"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n    check(\"select * from myMap [field], myArray [1 + 2]\",\n        \"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1869,"status":"M"}],"commitId":"870d5f48de16d44e44a09891018ba2c138980f68","commitMessage":"@@@[CALCITE-2674] Column name with escape character should not be verified as a function when the column name is same with it (Danny Chan)\n\nFix-ups (Julian Hyde):\n* Make SqlParserPos immutable.  and create a sub-class for quoted identifiers;\n* Add case to SqlParserTest;\n* Convert 'assert' to 'assertThat' in a test.\n\nClose apache/calcite#958\n","date":"2019-03-08 15:45:55","modifiedFileCount":"5","status":"M","submitter":"yuzhao.cyz"},{"authorTime":"2019-09-07 07:51:19","codes":[{"authorDate":"2019-09-07 07:51:19","commitOrder":3,"curCode":"  @Test public void testBackTickIdentifier() {\n    quoting = Quoting.BACK_TICK;\n    expr(\"ab\").ok(\"`AB`\");\n    expr(\"     `a  \\\" b!c`\").ok(\"`a  \\\" b!c`\");\n    expr(\"     ^\\\"^a  \\\"\\\" b!c\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"^\\\"^x`y`z\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"`x``y``z`\").ok(\"`x``y``z`\");\n\n    expr(\"myMap[field] + myArray[1 + 2]\")\n        .ok(\"(`MYMAP`[`FIELD`] + `MYARRAY`[(1 + 2)])\");\n\n    getTester().checkNode(\"VALUES a\", isQuoted(0, false));\n    getTester().checkNode(\"VALUES `a`\", isQuoted(0, true));\n  }\n","date":"2019-09-24 02:59:18","endLine":2077,"groupId":"16517","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testBackTickIdentifier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6b/18efc30e26712f7989a0e69015daabf5819bf3.src","preCode":"  @Test public void testBackTickIdentifier() {\n    quoting = Quoting.BACK_TICK;\n    checkExp(\"ab\", \"`AB`\");\n    checkExp(\"     `a  \\\" b!c`\", \"`a  \\\" b!c`\");\n    checkExpFails(\"     ^\\\"^a  \\\"\\\" b!c\\\"\", \"(?s).*Encountered.*\");\n\n    checkExpFails(\"^\\\"^x`y`z\\\"\", \"(?s).*Encountered.*\");\n    checkExp(\"`x``y``z`\", \"`x``y``z`\");\n\n    checkExp(\"myMap[field] + myArray[1 + 2]\",\n        \"(`MYMAP`[`FIELD`] + `MYARRAY`[(1 + 2)])\");\n\n    getTester().checkNode(\"VALUES a\", isQuoted(0, false));\n    getTester().checkNode(\"VALUES `a`\", isQuoted(0, true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2061,"status":"M"},{"authorDate":"2019-09-07 07:51:19","commitOrder":3,"curCode":"  @Test public void testBracketIdentifier() {\n    quoting = Quoting.BRACKET;\n    expr(\"ab\").ok(\"`AB`\");\n    expr(\"     [a  \\\" b!c]\").ok(\"`a  \\\" b!c`\");\n    expr(\"     ^`^a  \\\" b!c`\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"     ^\\\"^a  \\\"\\\" b!c\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"[x`y`z]\").ok(\"`x``y``z`\");\n    expr(\"^\\\"^x`y`z\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"^`^x``y``z`\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"[anything [even brackets]] is].[ok]\")\n        .ok(\"`anything [even brackets] is`.`ok`\");\n\n    \r\n    \r\n    sql(\"select * from myMap[field], myArray[1 + 2]\")\n        .ok(\"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n    sql(\"select * from myMap [field], myArray [1 + 2]\")\n        .ok(\"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n\n    getTester().checkNode(\"VALUES a\", isQuoted(0, false));\n    getTester().checkNode(\"VALUES [a]\", isQuoted(0, true));\n  }\n","date":"2019-09-24 02:59:18","endLine":2110,"groupId":"3382","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testBracketIdentifier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6b/18efc30e26712f7989a0e69015daabf5819bf3.src","preCode":"  @Test public void testBracketIdentifier() {\n    quoting = Quoting.BRACKET;\n    checkExp(\"ab\", \"`AB`\");\n    checkExp(\"     [a  \\\" b!c]\", \"`a  \\\" b!c`\");\n    checkExpFails(\"     ^`^a  \\\" b!c`\", \"(?s).*Encountered.*\");\n    checkExpFails(\"     ^\\\"^a  \\\"\\\" b!c\\\"\", \"(?s).*Encountered.*\");\n\n    checkExp(\"[x`y`z]\", \"`x``y``z`\");\n    checkExpFails(\"^\\\"^x`y`z\\\"\", \"(?s).*Encountered.*\");\n    checkExpFails(\"^`^x``y``z`\", \"(?s).*Encountered.*\");\n\n    checkExp(\"[anything [even brackets]] is].[ok]\",\n        \"`anything [even brackets] is`.`ok`\");\n\n    \r\n    \r\n    check(\"select * from myMap[field], myArray[1 + 2]\",\n        \"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n    check(\"select * from myMap [field], myArray [1 + 2]\",\n        \"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n\n    getTester().checkNode(\"VALUES a\", isQuoted(0, false));\n    getTester().checkNode(\"VALUES [a]\", isQuoted(0, true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2079,"status":"M"}],"commitId":"405614f87b75eb515e767b78a2c47481a0efc701","commitMessage":"@@@[CALCITE-3327] Simplify SqlValidatorTest and SqlParserTest by making test methods fluent\n\nReplace 'boolean typeCoercion' parameter with fluent method 'Sql.withTypeCoercion(boolean)'.\n\nDeprecate various checkXxx methods. For example. \ncheckExp(sql.  expected) becomes expr(sql).ok();\ncheckExpFails(sql.  e) becomes expr(s).fails(e).\n\nRename SqlParserTest.exp to expr.\n","date":"2019-09-24 02:59:18","modifiedFileCount":"16","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":4,"curCode":"  @Test void testBackTickIdentifier() {\n    quoting = Quoting.BACK_TICK;\n    expr(\"ab\").ok(\"`AB`\");\n    expr(\"     `a  \\\" b!c`\").ok(\"`a  \\\" b!c`\");\n    expr(\"     ^\\\"^a  \\\"\\\" b!c\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"^\\\"^x`y`z\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"`x``y``z`\").ok(\"`x``y``z`\");\n\n    expr(\"myMap[field] + myArray[1 + 2]\")\n        .ok(\"(`MYMAP`[`FIELD`] + `MYARRAY`[(1 + 2)])\");\n\n    getTester().checkNode(\"VALUES a\", isQuoted(0, false));\n    getTester().checkNode(\"VALUES `a`\", isQuoted(0, true));\n  }\n","date":"2020-04-06 04:57:49","endLine":2079,"groupId":"16517","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testBackTickIdentifier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/df/6c18087114449f5c2ca4ff32ab24aa6a84eed3.src","preCode":"  @Test public void testBackTickIdentifier() {\n    quoting = Quoting.BACK_TICK;\n    expr(\"ab\").ok(\"`AB`\");\n    expr(\"     `a  \\\" b!c`\").ok(\"`a  \\\" b!c`\");\n    expr(\"     ^\\\"^a  \\\"\\\" b!c\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"^\\\"^x`y`z\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"`x``y``z`\").ok(\"`x``y``z`\");\n\n    expr(\"myMap[field] + myArray[1 + 2]\")\n        .ok(\"(`MYMAP`[`FIELD`] + `MYARRAY`[(1 + 2)])\");\n\n    getTester().checkNode(\"VALUES a\", isQuoted(0, false));\n    getTester().checkNode(\"VALUES `a`\", isQuoted(0, true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2063,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":4,"curCode":"  @Test void testBracketIdentifier() {\n    quoting = Quoting.BRACKET;\n    expr(\"ab\").ok(\"`AB`\");\n    expr(\"     [a  \\\" b!c]\").ok(\"`a  \\\" b!c`\");\n    expr(\"     ^`^a  \\\" b!c`\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"     ^\\\"^a  \\\"\\\" b!c\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"[x`y`z]\").ok(\"`x``y``z`\");\n    expr(\"^\\\"^x`y`z\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"^`^x``y``z`\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"[anything [even brackets]] is].[ok]\")\n        .ok(\"`anything [even brackets] is`.`ok`\");\n\n    \r\n    \r\n    sql(\"select * from myMap[field], myArray[1 + 2]\")\n        .ok(\"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n    sql(\"select * from myMap [field], myArray [1 + 2]\")\n        .ok(\"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n\n    getTester().checkNode(\"VALUES a\", isQuoted(0, false));\n    getTester().checkNode(\"VALUES [a]\", isQuoted(0, true));\n  }\n","date":"2020-04-06 04:57:49","endLine":2112,"groupId":"3382","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testBracketIdentifier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/df/6c18087114449f5c2ca4ff32ab24aa6a84eed3.src","preCode":"  @Test public void testBracketIdentifier() {\n    quoting = Quoting.BRACKET;\n    expr(\"ab\").ok(\"`AB`\");\n    expr(\"     [a  \\\" b!c]\").ok(\"`a  \\\" b!c`\");\n    expr(\"     ^`^a  \\\" b!c`\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"     ^\\\"^a  \\\"\\\" b!c\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"[x`y`z]\").ok(\"`x``y``z`\");\n    expr(\"^\\\"^x`y`z\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"^`^x``y``z`\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"[anything [even brackets]] is].[ok]\")\n        .ok(\"`anything [even brackets] is`.`ok`\");\n\n    \r\n    \r\n    sql(\"select * from myMap[field], myArray[1 + 2]\")\n        .ok(\"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n    sql(\"select * from myMap [field], myArray [1 + 2]\")\n        .ok(\"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n\n    getTester().checkNode(\"VALUES a\", isQuoted(0, false));\n    getTester().checkNode(\"VALUES [a]\", isQuoted(0, true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2081,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-09-10 07:48:24","codes":[{"authorDate":"2020-09-10 07:48:24","commitOrder":5,"curCode":"  @Test void testBackTickIdentifier() {\n    quoting = Quoting.BACK_TICK;\n    expr(\"ab\").ok(\"`AB`\");\n    expr(\"     `a  \\\" b!c`\").ok(\"`a  \\\" b!c`\");\n    expr(\"     ^\\\"^a  \\\"\\\" b!c\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"^\\\"^x`y`z\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"`x``y``z`\").ok(\"`x``y``z`\");\n\n    expr(\"myMap[field] + myArray[1 + 2]\")\n        .ok(\"(`MYMAP`[`FIELD`] + `MYARRAY`[(1 + 2)])\");\n\n    sql(\"VALUES a\").node(isQuoted(0, false));\n    sql(\"VALUES `a`\").node(isQuoted(0, true));\n  }\n","date":"2020-09-18 10:35:30","endLine":2105,"groupId":"10847","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testBackTickIdentifier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6c/d1a9613e189238221e85788dafc7e38ba16391.src","preCode":"  @Test void testBackTickIdentifier() {\n    quoting = Quoting.BACK_TICK;\n    expr(\"ab\").ok(\"`AB`\");\n    expr(\"     `a  \\\" b!c`\").ok(\"`a  \\\" b!c`\");\n    expr(\"     ^\\\"^a  \\\"\\\" b!c\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"^\\\"^x`y`z\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"`x``y``z`\").ok(\"`x``y``z`\");\n\n    expr(\"myMap[field] + myArray[1 + 2]\")\n        .ok(\"(`MYMAP`[`FIELD`] + `MYARRAY`[(1 + 2)])\");\n\n    getTester().checkNode(\"VALUES a\", isQuoted(0, false));\n    getTester().checkNode(\"VALUES `a`\", isQuoted(0, true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2089,"status":"M"},{"authorDate":"2020-09-10 07:48:24","commitOrder":5,"curCode":"  @Test void testBracketIdentifier() {\n    quoting = Quoting.BRACKET;\n    expr(\"ab\").ok(\"`AB`\");\n    expr(\"     [a  \\\" b!c]\").ok(\"`a  \\\" b!c`\");\n    expr(\"     ^`^a  \\\" b!c`\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"     ^\\\"^a  \\\"\\\" b!c\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"[x`y`z]\").ok(\"`x``y``z`\");\n    expr(\"^\\\"^x`y`z\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"^`^x``y``z`\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"[anything [even brackets]] is].[ok]\")\n        .ok(\"`anything [even brackets] is`.`ok`\");\n\n    \r\n    \r\n    sql(\"select * from myMap[field], myArray[1 + 2]\")\n        .ok(\"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n    sql(\"select * from myMap [field], myArray [1 + 2]\")\n        .ok(\"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n\n    sql(\"VALUES a\").node(isQuoted(0, false));\n    sql(\"VALUES [a]\").node(isQuoted(0, true));\n  }\n","date":"2020-09-18 10:35:30","endLine":2138,"groupId":"10847","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testBracketIdentifier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6c/d1a9613e189238221e85788dafc7e38ba16391.src","preCode":"  @Test void testBracketIdentifier() {\n    quoting = Quoting.BRACKET;\n    expr(\"ab\").ok(\"`AB`\");\n    expr(\"     [a  \\\" b!c]\").ok(\"`a  \\\" b!c`\");\n    expr(\"     ^`^a  \\\" b!c`\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"     ^\\\"^a  \\\"\\\" b!c\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"[x`y`z]\").ok(\"`x``y``z`\");\n    expr(\"^\\\"^x`y`z\\\"\")\n        .fails(\"(?s).*Encountered.*\");\n    expr(\"^`^x``y``z`\")\n        .fails(\"(?s).*Encountered.*\");\n\n    expr(\"[anything [even brackets]] is].[ok]\")\n        .ok(\"`anything [even brackets] is`.`ok`\");\n\n    \r\n    \r\n    sql(\"select * from myMap[field], myArray[1 + 2]\")\n        .ok(\"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n    sql(\"select * from myMap [field], myArray [1 + 2]\")\n        .ok(\"SELECT *\\n\"\n            + \"FROM `MYMAP` AS `field`,\\n\"\n            + \"`MYARRAY` AS `1 + 2`\");\n\n    getTester().checkNode(\"VALUES a\", isQuoted(0, false));\n    getTester().checkNode(\"VALUES [a]\", isQuoted(0, true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2107,"status":"M"}],"commitId":"0c5bb1a345f39cab3eaa3b95a77c1e8831e667e1","commitMessage":"@@@Refactor SqlParserTest\n\nStore StringAndPos rather than the SQL string in a test. This\nmakes it easier to write positive and negative tests on same\nSQL string.  because we don't have to keep the carets (that\nindicate the error position) in the SQL string. If you want\nreal carets in a SQL string.  you can now write \"^^\". Remove\nthe sansCarets() method.  as it is no longer necessary.\n\nPass SqlDialect into negative and expression tests.\n\nAdd constants in SqlParserTest for common dialects.\n","date":"2020-09-18 10:35:30","modifiedFileCount":"4","status":"M","submitter":"Julian Hyde"}]
