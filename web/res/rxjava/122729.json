[{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.addThrowable(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.addThrowable(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.addThrowable(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":350,"groupId":"10762","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/6a/ea36d5d202b81502d6c76986670a366bdefb34.src","preCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.addThrowable(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.addThrowable(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.addThrowable(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":252,"status":"B"},{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"        public void run() {\n\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n\n                    boolean d = done;\n\n                    if (d && !veryEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.addThrowable(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        Publisher<? extends R> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n\n                            upstream.cancel();\n                            errors.addThrowable(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            Supplier<R> supplier = (Supplier<R>) p;\n\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.addThrowable(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":548,"groupId":"6214","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"run","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/41/cda15f8936e61960644f937e0febe75c343dd2.src","preCode":"        public void run() {\n\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n\n                    boolean d = done;\n\n                    if (d && !veryEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.addThrowable(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        Publisher<? extends R> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n\n                            upstream.cancel();\n                            errors.addThrowable(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            Supplier<R> supplier = (Supplier<R>) p;\n\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.addThrowable(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapScheduler.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":441,"status":"B"}],"commitId":"a1693ecc9215027a7a3eae75272979ebb4d79a27","commitMessage":"@@@3.x: Refactor to io.reactivex.rxjava3.** (#6621)\n\n* 3.x: Refactor to io.reactivex.rxjava3.**\n\n* fix javadoc cleanup gradle\n\n* javadoc gradle again\n\n* Fix package location in text\n","date":"2019-08-16 20:51:17","modifiedFileCount":"0","status":"B","submitter":"David Karnok"},{"authorTime":"2019-08-28 22:07:44","codes":[{"authorDate":"2019-08-28 22:07:44","commitOrder":2,"curCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2019-08-28 22:07:44","endLine":345,"groupId":"1995","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/a1/1f206dde79a1961d4fc6713c4d0ad6407b23e9.src","preCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.addThrowable(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.addThrowable(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.addThrowable(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":247,"status":"M"},{"authorDate":"2019-08-28 22:07:44","commitOrder":2,"curCode":"        public void run() {\n\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n\n                    boolean d = done;\n\n                    if (d && !veryEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.tryAddThrowableOrReport(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        Publisher<? extends R> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            Supplier<R> supplier = (Supplier<R>) p;\n\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.tryAddThrowableOrReport(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-08-28 22:07:44","endLine":539,"groupId":"9817","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"run","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/82/8bb5a5fac0bbb6ee0787f6e4a7d06682cb0dc6.src","preCode":"        public void run() {\n\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n\n                    boolean d = done;\n\n                    if (d && !veryEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.addThrowable(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        Publisher<? extends R> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n\n                            upstream.cancel();\n                            errors.addThrowable(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            Supplier<R> supplier = (Supplier<R>) p;\n\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.addThrowable(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapScheduler.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":432,"status":"M"}],"commitId":"a07c45eeeb68b1cfc24f913c75edbc2820aadb76","commitMessage":"@@@3.x: Cleanup addThrowable.  \"2.x\" and null-value error messages (#6639)\n\n","date":"2019-08-28 22:07:44","modifiedFileCount":"106","status":"M","submitter":"David Karnok"},{"authorTime":"2019-12-18 03:06:44","codes":[{"authorDate":"2019-12-18 03:06:44","commitOrder":3,"curCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2019-12-18 03:06:44","endLine":345,"groupId":"1995","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/f7/57fb5f3b073fb3c67d838593ad7eb04355823d.src","preCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":247,"status":"M"},{"authorDate":"2019-12-18 03:06:44","commitOrder":3,"curCode":"        public void run() {\n\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n\n                    boolean d = done;\n\n                    if (d && !veryEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.tryAddThrowableOrReport(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        Publisher<? extends R> p;\n\n                        try {\n                            p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            Supplier<R> supplier = (Supplier<R>) p;\n\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.tryAddThrowableOrReport(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-18 03:06:44","endLine":539,"groupId":"9817","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"run","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/05/c984b5335db193dc983e60bdf7a1a2fc152807.src","preCode":"        public void run() {\n\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n\n                    boolean d = done;\n\n                    if (d && !veryEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.tryAddThrowableOrReport(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        Publisher<? extends R> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            Supplier<R> supplier = (Supplier<R>) p;\n\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.tryAddThrowableOrReport(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapScheduler.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":432,"status":"M"}],"commitId":"6ba932c9a3752c6d85d65bd2292c3a47cab64fd6","commitMessage":"@@@Replace ObjectHelper.requireNonNull with Objects.requireNonNull (#6771)\n\n","date":"2019-12-18 03:06:44","modifiedFileCount":"199","status":"M","submitter":"Jake Wharton"},{"authorTime":"2019-12-28 03:01:34","codes":[{"authorDate":"2019-12-28 03:01:34","commitOrder":4,"curCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2019-12-28 03:01:34","endLine":345,"groupId":"1995","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/98/d8ea44107c656bcd6646a41ba0ae9d64258ce8.src","preCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":247,"status":"M"},{"authorDate":"2019-12-28 03:01:34","commitOrder":4,"curCode":"        public void run() {\n\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n\n                    boolean d = done;\n\n                    if (d && !veryEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.tryAddThrowableOrReport(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        Publisher<? extends R> p;\n\n                        try {\n                            p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            Supplier<R> supplier = (Supplier<R>) p;\n\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.tryAddThrowableOrReport(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-28 03:01:34","endLine":539,"groupId":"9817","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"run","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/d5/9677efa1ecab4f33daecf135b14ac9d2811d59.src","preCode":"        public void run() {\n\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n\n                    boolean d = done;\n\n                    if (d && !veryEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.tryAddThrowableOrReport(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        Publisher<? extends R> p;\n\n                        try {\n                            p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            Supplier<R> supplier = (Supplier<R>) p;\n\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.tryAddThrowableOrReport(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapScheduler.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":432,"status":"M"}],"commitId":"79f8e6dde6446b1aa33c146eaedbb958086daf56","commitMessage":"@@@3.x: Fix diamonds.  spelling.  unnecessary code (#6804)\n\n","date":"2019-12-28 03:01:34","modifiedFileCount":"463","status":"M","submitter":"David Karnok"},{"authorTime":"2020-02-12 23:26:52","codes":[{"authorDate":"2020-02-12 23:26:52","commitOrder":5,"curCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (!HalfSerializer.onNext(downstream, vr, this, errors)) {\n                                        return;\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2020-02-12 23:26:52","endLine":325,"groupId":"1995","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/ae/a261f5aaba92ce5fd5b709acdae927562d149c.src","preCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":231,"status":"M"},{"authorDate":"2020-02-12 23:26:52","commitOrder":5,"curCode":"        public void run() {\n\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n\n                    boolean d = done;\n\n                    if (d && !veryEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.tryAddThrowableOrReport(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        Publisher<? extends R> p;\n\n                        try {\n                            p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            Supplier<R> supplier = (Supplier<R>) p;\n\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.tryAddThrowableOrReport(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null || cancelled) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2020-02-12 23:26:52","endLine":543,"groupId":"9817","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"run","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/3d/fcd38b9df6d6baeb496a2e3554a50b54c24c6c.src","preCode":"        public void run() {\n\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n\n                    boolean d = done;\n\n                    if (d && !veryEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.tryAddThrowableOrReport(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        Publisher<? extends R> p;\n\n                        try {\n                            p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            Supplier<R> supplier = (Supplier<R>) p;\n\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.tryAddThrowableOrReport(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapScheduler.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":436,"status":"M"}],"commitId":"b3ad0752de398f4536bb88a7b1c77b0b9fbecb87","commitMessage":"@@@3.x: Add missing coverage.  fix unused/inconsistent ops (#6901)\n\n* 3.x: Add missing coverage.  fix unused/inconsistent ops\n\n* More coverage improvements and cleanup\n\n* Some more coverage\n\n* Observable coverage and cleanup\n\n* Improve Flowable internals and coverage\n\n* More Flowable operator coverage and fixes\n\n* Last set of coverage & cleanup for Flowable operators\n\n* Fix wrong use of j.u.Observable\n","date":"2020-02-12 23:26:52","modifiedFileCount":"219","status":"M","submitter":"David Karnok"},{"authorTime":"2020-10-05 20:07:15","codes":[{"authorDate":"2020-10-05 20:07:15","commitOrder":6,"curCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (!HalfSerializer.onNext(downstream, vr, this, errors)) {\n                                        return;\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2020-10-05 20:07:15","endLine":325,"groupId":"122729","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/94/09bc7a2e17e23d1d2b16a7052bcb4781d0e8c9.src","preCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (!HalfSerializer.onNext(downstream, vr, this, errors)) {\n                                        return;\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":231,"status":"M"},{"authorDate":"2020-10-05 20:07:15","commitOrder":6,"curCode":"        public void run() {\n\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n\n                    boolean d = done;\n\n                    if (d && !veryEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.tryAddThrowableOrReport(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        Publisher<? extends R> p;\n\n                        try {\n                            p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            Supplier<R> supplier = (Supplier<R>) p;\n\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.tryAddThrowableOrReport(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null || cancelled) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2020-10-05 20:07:15","endLine":543,"groupId":"122729","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"run","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/fb/a627c7ed7deb15cbba681d4fea0048889055df.src","preCode":"        public void run() {\n\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n\n                    boolean d = done;\n\n                    if (d && !veryEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.tryAddThrowableOrReport(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        Publisher<? extends R> p;\n\n                        try {\n                            p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            Supplier<R> supplier = (Supplier<R>) p;\n\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.tryAddThrowableOrReport(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null || cancelled) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapScheduler.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":436,"status":"M"}],"commitId":"0668d042b47d3585f856af831bd3b1e1742c080f","commitMessage":"@@@3.x: Fix Flowable.concatMap backpressure w/ scalars (#7089)\n\n","date":"2020-10-05 20:07:15","modifiedFileCount":"4","status":"M","submitter":"David Karnok"}]
