[{"authorTime":"2018-02-02 02:27:59","codes":[{"authorDate":"2018-01-30 09:48:53","commitOrder":2,"curCode":"    private void doTestJoin(final StreamsBuilder builder,\n                            final int[] expectedKeys,\n                            final MockProcessorSupplier<Integer, String> processor,\n                            final KTable<Integer, String> joined) {\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir, Serdes.Integer(), Serdes.String());\n        driver.setTime(0L);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult();\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"1:XX1+Y1\");\n        checkJoinedValues(getter, kv(0, \"XX0+Y0\"), kv(1, \"XX1+Y1\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+YY0\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+YY0\"), kv(1, \"XX1+YY1\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:null\", \"1:null\");\n        checkJoinedValues(getter, kv(0, null), kv(1, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        driver.process(topic1, null, \"XX\" + 1);\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n    }\n","date":"2018-01-30 09:48:53","endLine":154,"groupId":"13654","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestJoin","params":"(finalStreamsBuilderbuilder@finalint[]expectedKeys@finalMockProcessorSupplier<Integer@String>processor@finalKTable<Integer@String>joined)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/b8/90e2f991db13e6dc179d02d8d9c44d431ea894.src","preCode":"    private void doTestJoin(final StreamsBuilder builder,\n                            final int[] expectedKeys,\n                            final MockProcessorSupplier<Integer, String> processor,\n                            final KTable<Integer, String> joined) {\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir, Serdes.Integer(), Serdes.String());\n        driver.setTime(0L);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult();\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"1:XX1+Y1\");\n        checkJoinedValues(getter, kv(0, \"XX0+Y0\"), kv(1, \"XX1+Y1\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+YY0\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+YY0\"), kv(1, \"XX1+YY1\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:null\", \"1:null\");\n        checkJoinedValues(getter, kv(0, null), kv(1, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        driver.process(topic1, null, \"XX\" + 1);\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableInnerJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"NB"},{"authorDate":"2018-02-02 02:27:59","commitOrder":2,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-02-02 02:27:59","endLine":102,"groupId":"15879","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/75/07d7a4def24a0ae9a49086b2796e32476ede74.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"B"}],"commitId":"86de4a86b87c1b45732303c07d263e317ffd0ebf","commitMessage":"@@@KAFKA-6378: For KStream-GlobalKTable joins let null KeyValueMapper results indicate no match (#4494)\n\nReviewers: Damian Guy <damian@confluent.io>.  Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-02-02 02:27:59","modifiedFileCount":"4","status":"M","submitter":"Andy Bryant"},{"authorTime":"2018-02-02 02:27:59","codes":[{"authorDate":"2018-04-18 04:13:15","commitOrder":3,"curCode":"    private void doTestJoin(final StreamsBuilder builder,\n                            final int[] expectedKeys,\n                            final MockProcessorSupplier<Integer, String> processor,\n                            final KTable<Integer, String> joined) {\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir, Serdes.Integer(), Serdes.String());\n        driver.setTime(0L);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult();\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"1:XX1+Y1\");\n        checkJoinedValues(getter, kv(0, \"XX0+Y0\"), kv(1, \"XX1+Y1\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+YY0\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+YY0\"), kv(1, \"XX1+YY1\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:null\", \"1:null\");\n        checkJoinedValues(getter, kv(0, null), kv(1, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        driver.process(topic1, null, \"XX\" + 1);\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n    }\n","date":"2018-04-18 04:13:15","endLine":154,"groupId":"13654","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestJoin","params":"(finalStreamsBuilderbuilder@finalint[]expectedKeys@finalMockProcessorSupplier<Integer@String>processor@finalKTable<Integer@String>joined)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/98/d3e5225749ce0a9f342cab4bc09276b278f0b0.src","preCode":"    private void doTestJoin(final StreamsBuilder builder,\n                            final int[] expectedKeys,\n                            final MockProcessorSupplier<Integer, String> processor,\n                            final KTable<Integer, String> joined) {\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir, Serdes.Integer(), Serdes.String());\n        driver.setTime(0L);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult();\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"1:XX1+Y1\");\n        checkJoinedValues(getter, kv(0, \"XX0+Y0\"), kv(1, \"XX1+Y1\"));\n\n        \r\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+YY0\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+YY0\"), kv(1, \"XX1+YY1\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:null\", \"1:null\");\n        checkJoinedValues(getter, kv(0, null), kv(1, null));\n\n        \r\n\n        for (int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        driver.process(topic1, null, \"XX\" + 1);\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableInnerJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"M"},{"authorDate":"2018-02-02 02:27:59","commitOrder":3,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-02-02 02:27:59","endLine":102,"groupId":"15879","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/75/07d7a4def24a0ae9a49086b2796e32476ede74.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"N"}],"commitId":"ac9c3ed0b43ee848e6e555a01c55ea2eee78540a","commitMessage":"@@@KAFKA-6376: preliminary cleanup (#4872)\n\nGeneral cleanup of Streams code.  mostly resolving compiler warnings and re-formatting.\n\nThe regular testing suite should be sufficient.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>.  Guozhang Wang <wangguoz@gmail.com>","date":"2018-04-18 04:13:15","modifiedFileCount":"57","status":"M","submitter":"John Roesler"},{"authorTime":"2018-02-02 02:27:59","codes":[{"authorDate":"2018-05-04 23:42:01","commitOrder":4,"curCode":"    private void doTestJoin(final StreamsBuilder builder,\n                            final int[] expectedKeys,\n                            final MockProcessorSupplier<Integer, String> supplier,\n                            final KTable<Integer, String> joined) {\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir, Serdes.Integer(), Serdes.String());\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult();\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"1:XX1+Y1\");\n        checkJoinedValues(getter, kv(0, \"XX0+Y0\"), kv(1, \"XX1+Y1\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+YY0\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+YY0\"), kv(1, \"XX1+YY1\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:null\", \"1:null\");\n        checkJoinedValues(getter, kv(0, null), kv(1, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        driver.process(topic1, null, \"XX\" + 1);\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n    }\n","date":"2018-05-04 23:42:01","endLine":163,"groupId":"13654","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestJoin","params":"(finalStreamsBuilderbuilder@finalint[]expectedKeys@finalMockProcessorSupplier<Integer@String>supplier@finalKTable<Integer@String>joined)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/0c/a388f6ab94f0d341528fae1aef8d7693cea60f.src","preCode":"    private void doTestJoin(final StreamsBuilder builder,\n                            final int[] expectedKeys,\n                            final MockProcessorSupplier<Integer, String> processor,\n                            final KTable<Integer, String> joined) {\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir, Serdes.Integer(), Serdes.String());\n        driver.setTime(0L);\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult();\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"1:XX1+Y1\");\n        checkJoinedValues(getter, kv(0, \"XX0+Y0\"), kv(1, \"XX1+Y1\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+YY0\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+YY0\"), kv(1, \"XX1+YY1\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:null\", \"1:null\");\n        checkJoinedValues(getter, kv(0, null), kv(1, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        driver.process(topic1, null, \"XX\" + 1);\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableInnerJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"M"},{"authorDate":"2018-02-02 02:27:59","commitOrder":4,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-02-02 02:27:59","endLine":102,"groupId":"15879","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/75/07d7a4def24a0ae9a49086b2796e32476ede74.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"N"}],"commitId":"af983267be7a2d0f81527f5a348af377f30caee4","commitMessage":"@@@MINOR: Removed deprecated schedule function (#4908)\n\nWhile working on this.  I also refactored the MockProcessor out of the MockProcessorSupplier to cleanup the unit test paths.\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2018-05-04 23:42:01","modifiedFileCount":"62","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-05-18 02:28:45","codes":[{"authorDate":"2018-05-18 02:28:45","commitOrder":5,"curCode":"    private void doTestJoin(final StreamsBuilder builder,\n                            final int[] expectedKeys,\n                            final MockProcessorSupplier<Integer, String> supplier,\n                            final KTable<Integer, String> joined) {\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir, Serdes.Integer(), Serdes.String());\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult();\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"1:XX1+Y1\");\n        checkJoinedValues(getter, kv(0, \"XX0+Y0\"), kv(1, \"XX1+Y1\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+YY0\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+YY0\"), kv(1, \"XX1+YY1\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:null\", \"1:null\");\n        checkJoinedValues(getter, kv(0, null), kv(1, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        driver.process(topic1, null, \"XX\" + 1);\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n    }\n","date":"2018-05-18 02:28:45","endLine":168,"groupId":"13654","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestJoin","params":"(finalStreamsBuilderbuilder@finalint[]expectedKeys@finalMockProcessorSupplier<Integer@String>supplier@finalKTable<Integer@String>joined)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/2e/fdd8523f0496cf82cd5f42e0129cc9b290e8a1.src","preCode":"    private void doTestJoin(final StreamsBuilder builder,\n                            final int[] expectedKeys,\n                            final MockProcessorSupplier<Integer, String> supplier,\n                            final KTable<Integer, String> joined) {\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir, Serdes.Integer(), Serdes.String());\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult();\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"1:XX1+Y1\");\n        checkJoinedValues(getter, kv(0, \"XX0+Y0\"), kv(1, \"XX1+Y1\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+YY0\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+YY0\"), kv(1, \"XX1+YY1\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:null\", \"1:null\");\n        checkJoinedValues(getter, kv(0, null), kv(1, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        driver.process(topic1, null, \"XX\" + 1);\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableInnerJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"M"},{"authorDate":"2018-05-18 02:28:45","commitOrder":5,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-05-18 02:28:45","endLine":107,"groupId":"15879","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/98/fc5001789d214925fd49bee5a8aefba5759d0e.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = StreamsBuilderTest.getCopartitionedGroups(builder);\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"M"}],"commitId":"1a324d784cfc53288730b7c1b5c1bde0685e4686","commitMessage":"@@@KAFKA-6729: Reuse source topics for source KTable's materialized store's changelog (#5017)\n\n1. In InternalTopologyBuilder#topicGroups.  which is used in StreamsPartitionAssignor.  look for book-kept storeToChangelogTopic map before creating a new internal changelog topics. In this way if the source KTable is created.  its source topic stored in storeToChangelogTopic will be used.\n\n2. Added unit test (confirmed that without 1) it will fail).\n\n3. MINOR: removed TODOs that are related to removed KStreamBuilder.\n\n4. MINOR: removed TODOs in StreamsBuilderTest util functions and replaced with TopologyWrapper.\n\n5. MINOR: removed StreamsBuilderTest#testFrom as it is already covered by TopologyTest#shouldNotAllowToAddSourcesWithSameName.  plus it requires KStreamImpl.SOURCE_NAME which should be a package private field of the KStreamImpl.\n\nReviewers: John Roesler <john@confluent.io>.  Bill Bejeck <bill@confluent.io>.  Matthias\n J. Sax <matthias@confluent.io>","date":"2018-05-18 02:28:45","modifiedFileCount":"17","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-05-18 02:28:45","codes":[{"authorDate":"2018-11-13 14:18:59","commitOrder":6,"curCode":"    private void doTestJoin(final StreamsBuilder builder,\n                            final int[] expectedKeys,\n                            final MockProcessorSupplier<Integer, String> supplier,\n                            final KTable<Integer, String> joined) {\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        @SuppressWarnings(\"unchecked\")\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir, Serdes.Integer(), Serdes.String());\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult();\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"1:XX1+Y1\");\n        checkJoinedValues(getter, kv(0, \"XX0+Y0\"), kv(1, \"XX1+Y1\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+YY0\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+YY0\"), kv(1, \"XX1+YY1\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:null\", \"1:null\");\n        checkJoinedValues(getter, kv(0, null), kv(1, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        driver.process(topic1, null, \"XX\" + 1);\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n    }\n","date":"2018-11-13 14:18:59","endLine":170,"groupId":"13654","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestJoin","params":"(finalStreamsBuilderbuilder@finalint[]expectedKeys@finalMockProcessorSupplier<Integer@String>supplier@finalKTable<Integer@String>joined)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5e/cbe83be78f91472b9c05d53f59816b0c309498.src","preCode":"    private void doTestJoin(final StreamsBuilder builder,\n                            final int[] expectedKeys,\n                            final MockProcessorSupplier<Integer, String> supplier,\n                            final KTable<Integer, String> joined) {\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir, Serdes.Integer(), Serdes.String());\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult();\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"1:XX1+Y1\");\n        checkJoinedValues(getter, kv(0, \"XX0+Y0\"), kv(1, \"XX1+Y1\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+YY0\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+YY0\"), kv(1, \"XX1+YY1\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:null\", \"1:null\");\n        checkJoinedValues(getter, kv(0, null), kv(1, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        driver.process(topic1, null, \"XX\" + 1);\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableInnerJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"M"},{"authorDate":"2018-05-18 02:28:45","commitOrder":6,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-05-18 02:28:45","endLine":107,"groupId":"15879","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/98/fc5001789d214925fd49bee5a8aefba5759d0e.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"N"}],"commitId":"12f310d50e7f5b1c18c4f61a119a6cd830da3bc0","commitMessage":"@@@KAFKA-7612: Fix javac warnings and enable warnings as errors (#5900)\n\n- Use Xlint:all with 3 exclusions (filed KAFKA-7613 to remove the exclusions)\n- Use the same javac options when compiling tests (seems accidental that\nwe didn't do this before)\n- Replaced several deprecated method calls with non-deprecated ones:\n  - `KafkaConsumer.poll(long)` and `KafkaConsumer.close(long)`\n  - `Class.newInstance` and `new Integer/Long` (deprecated since Java 9)\n  - `scala.Console` (deprecated in Scala 2.11)\n  - `PartitionData` taking a timestamp (one of them seemingly a bug)\n  - `JsonMappingException` single parameter constructor\n- Fix unnecessary usage of raw types in several places.\n- Add @SuppressWarnings for deprecations.  unchecked and switch fallthrough in\nseveral places.\n- Scala clean-ups (var -> val.  ETA expansion warnings.  avoid reflective calls)\n- Use lambdas to simplify code in a few places\n- Add @SafeVarargs.  fix varargs usage and remove unnecessary `Utils.mkList` method\n\nReviewers: Matthias J. Sax <mjsax@apache.org>.  Manikumar Reddy <manikumar.reddy@gmail.com>.  Randall Hauch <rhauch@gmail.com>.  Bill Bejeck <bill@confluent.io>.  Stanislav Kozlovski <stanislav_kozlovski@outlook.com>","date":"2018-11-13 14:18:59","modifiedFileCount":"146","status":"M","submitter":"Ismael Juma"},{"authorTime":"2018-05-18 02:28:45","codes":[{"authorDate":"2018-12-09 14:49:48","commitOrder":7,"curCode":"    private void doTestJoin(final StreamsBuilder builder,\n                            final int[] expectedKeys,\n                            final MockProcessorSupplier<Integer, String> supplier,\n                            final KTable<Integer, String> joined) {\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir, Serdes.Integer(), Serdes.String());\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult();\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"1:XX1+Y1\");\n        checkJoinedValues(getter, kv(0, \"XX0+Y0\"), kv(1, \"XX1+Y1\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+YY0\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+YY0\"), kv(1, \"XX1+YY1\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:null\", \"1:null\");\n        checkJoinedValues(getter, kv(0, null), kv(1, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        driver.process(topic1, null, \"XX\" + 1);\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n    }\n","date":"2018-12-09 14:49:48","endLine":340,"groupId":"13654","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestJoin","params":"(finalStreamsBuilderbuilder@finalint[]expectedKeys@finalMockProcessorSupplier<Integer@String>supplier@finalKTable<Integer@String>joined)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/63/ed53f5cf4232f19f2c273022212f43efae1674.src","preCode":"    private void doTestJoin(final StreamsBuilder builder,\n                            final int[] expectedKeys,\n                            final MockProcessorSupplier<Integer, String> supplier,\n                            final KTable<Integer, String> joined) {\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        @SuppressWarnings(\"unchecked\")\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir, Serdes.Integer(), Serdes.String());\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult();\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"1:XX1+Y1\");\n        checkJoinedValues(getter, kv(0, \"XX0+Y0\"), kv(1, \"XX1+Y1\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+YY0\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+YY0\"), kv(1, \"XX1+YY1\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:null\", \"1:null\");\n        checkJoinedValues(getter, kv(0, null), kv(1, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        driver.process(topic1, null, \"XX\" + 1);\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableInnerJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":246,"status":"M"},{"authorDate":"2018-05-18 02:28:45","commitOrder":7,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-05-18 02:28:45","endLine":107,"groupId":"15879","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/98/fc5001789d214925fd49bee5a8aefba5759d0e.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"N"}],"commitId":"c0353d8ddce88bac6fc04f85dd40cb95b8ca5cf9","commitMessage":"@@@KAFKA-6036: Local Materialization for Source KTable (#5779)\n\nRefactor the materialization for source KTables in the way that:\n\nIf Materialized.as(queryableName) is specified.  materialize;\nIf the downstream operator requires to fetch from this KTable via ValueGetters.  materialize;\nIf the downstream operator requires to send old values.  materialize.\nOtherwise do not materialize the KTable. E.g. builder.table(\"topic\").filter().toStream().to(\"topic\") would not create any state stores.\n\nThere's a couple of minor changes along with PR as well:\n\nKTableImpl's queryableStoreName and isQueryable are merged into queryableStoreName only.  and if it is null it means not queryable. As long as it is not null.  it should be queryable (i.e. internally generated names will not be used any more).\nTo achieve this.  splitted MaterializedInternal.storeName() and MaterializedInternal.queryableName(). The former can be internally generated and will not be exposed to users. QueryableName can be modified to set to the internal store name if we decide to materialize it during the DSL parsing / physical topology generation phase. And only if queryableName is specified the corresponding KTable is determined to be materialized.\n\nFound some overlapping unit tests among KTableImplTest.  and KTableXXTest.  removed them.\n\nThere are a few typing bugs found along the way.  fixed them as well.\n\n-----------------------\n\nThis PR is an illustration of experimenting a poc towards logical materializations.\n\nToday we've logically materialized the KTable for filter / mapValues / transformValues if queryableName is not specified via Materialized.  but whenever users specify queryableName we will still always materialize. My original goal is to also consider logically materialize for queryable stores.  but when implementing it via a wrapped store to apply the transformations on the fly I realized it is tougher than I thought.  because we not only need to support fetch or get.  but also needs to support range queries.  approximateNumEntries.  and isOpen etc as well.  which are not efficient to support. So in the end I'd suggest we still stick with the rule of always materializing if queryableName is specified.  and only consider logical materialization otherwise.\n\nReviewers: Bill Bejeck <bill@confluent.io>.  Matthias J. Sax <mjsax@apache.org>","date":"2018-12-09 14:49:48","modifiedFileCount":"32","status":"M","submitter":"Guozhang Wang"},{"authorTime":"2018-05-18 02:28:45","codes":[{"authorDate":"2019-02-15 07:06:47","commitOrder":8,"curCode":"    private void doTestJoin(final StreamsBuilder builder, final int[] expectedKeys) {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+Y0\");\n            assertOutputKeyValue(driver, 1, \"XX1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+YY0\");\n            assertOutputKeyValue(driver, 1, \"XX1+YY1\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, null);\n            assertOutputKeyValue(driver, 1, null);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            driver.pipeInput(recordFactory.create(topic1, null, \"XX\" + 1));\n            assertNull(driver.readOutput(output));\n        }\n\n    }\n","date":"2019-02-15 07:06:47","endLine":292,"groupId":"15879","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestJoin","params":"(finalStreamsBuilderbuilder@finalint[]expectedKeys)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/5d/1f5c3d8c8c85450ecfc113f3c83366d85110b2.src","preCode":"    private void doTestJoin(final StreamsBuilder builder,\n                            final int[] expectedKeys,\n                            final MockProcessorSupplier<Integer, String> supplier,\n                            final KTable<Integer, String> joined) {\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        final KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver.setUp(builder, stateDir, Serdes.Integer(), Serdes.String());\n        driver.setTime(0L);\n\n        final MockProcessor<Integer, String> processor = supplier.theCapturedProcessor();\n\n        final KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic1, null, \"SomeVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult();\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n        \r\n        driver.process(topic2, null, \"AnotherVal\");\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+Y0\", \"1:XX1+Y1\");\n        checkJoinedValues(getter, kv(0, \"XX0+Y0\"), kv(1, \"XX1+Y1\"));\n\n        \r\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic2, expectedKey, \"YY\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:XX0+YY0\", \"1:XX1+YY1\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+YY0\"), kv(1, \"XX1+YY1\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"X\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        \r\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"0:null\", \"1:null\");\n        checkJoinedValues(getter, kv(0, null), kv(1, null));\n\n        \r\n\n        for (final int expectedKey : expectedKeys) {\n            driver.process(topic1, expectedKey, \"XX\" + expectedKey);\n        }\n        driver.flushState();\n\n        processor.checkAndClearProcessResult(\"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        driver.process(topic1, null, \"XX\" + 1);\n        checkJoinedValues(getter, kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableInnerJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":217,"status":"M"},{"authorDate":"2018-05-18 02:28:45","commitOrder":8,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-05-18 02:28:45","endLine":107,"groupId":"15879","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/98/fc5001789d214925fd49bee5a8aefba5759d0e.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"N"}],"commitId":"c1918a2b9a9ba282efe92ddb867abef3d6d9b98c","commitMessage":"@@@KAFKA-6474: Rewrite tests to use new public TopologyTestDriver [part 4] (#5433)\n\nReviewer: John Roesler <john@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2019-02-15 07:06:47","modifiedFileCount":"3","status":"M","submitter":"Filipe Agapito"},{"authorTime":"2018-05-18 02:28:45","codes":[{"authorDate":"2019-05-18 07:48:07","commitOrder":9,"curCode":"    private void doTestJoin(final StreamsBuilder builder, final int[] expectedKeys) {\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 6L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 2, null, 10L);\n            assertOutputKeyValueTimestamp(driver, 3, null, 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","date":"2019-05-18 07:48:07","endLine":442,"groupId":"2709","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestJoin","params":"(finalStreamsBuilderbuilder@finalint[]expectedKeys)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/19/5e38d9537ffc1ba24a1e5c9d0b92670b609412.src","preCode":"    private void doTestJoin(final StreamsBuilder builder, final int[] expectedKeys) {\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\"));\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\"));\n            assertOutputKeyValue(driver, 0, \"X0+Y0\");\n            assertOutputKeyValue(driver, 1, \"X1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+Y0\");\n            assertOutputKeyValue(driver, 1, \"XX1+Y1\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"XX0+YY0\");\n            assertOutputKeyValue(driver, 1, \"XX1+YY1\");\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"X\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 0, \"X0+YY0\");\n            assertOutputKeyValue(driver, 1, \"X1+YY1\");\n            assertOutputKeyValue(driver, 2, \"X2+YY2\");\n            assertOutputKeyValue(driver, 3, \"X3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], null));\n            }\n            assertOutputKeyValue(driver, 0, null);\n            assertOutputKeyValue(driver, 1, null);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey));\n            }\n            assertOutputKeyValue(driver, 2, \"XX2+YY2\");\n            assertOutputKeyValue(driver, 3, \"XX3+YY3\");\n            assertNull(driver.readOutput(output));\n\n            driver.pipeInput(recordFactory.create(topic1, null, \"XX\" + 1));\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableInnerJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":348,"status":"M"},{"authorDate":"2018-05-18 02:28:45","commitOrder":9,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-05-18 02:28:45","endLine":107,"groupId":"15879","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/98/fc5001789d214925fd49bee5a8aefba5759d0e.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"N"}],"commitId":"6a2749faa63397caa93dae7bfdc3f1d0573a2ff4","commitMessage":"@@@KAFKA-6455: Improve DSL operator timestamp semantics (#6725)\n\nBasic idea:\nKTable-KTable join: set max(left-ts. right-ts) for result\n#agg(...) (stream/table windowed/non-windowed): set max(ts1.  ts2.  ts3. ...) of all input records that contribute to the aggregation result\nfor all stateless transformation: input-ts -> output-ts\n\nReviewers: Guozhang Wang <wangguoz@gmail.com>.   John Roesler <john@confluent.io>.  Andy Coates <andy@confluent.io>.   Bill Bejeck <bbejeck@gmail.com","date":"2019-05-18 07:48:07","modifiedFileCount":"61","status":"M","submitter":"Matthias J. Sax"},{"authorTime":"2018-05-18 02:28:45","codes":[{"authorDate":"2019-10-07 16:01:58","commitOrder":10,"curCode":"    private void doTestJoin(final StreamsBuilder builder, final int[] expectedKeys) {\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            final TestInputTopic<Integer, String> inputTopic1 =\n                    driver.createInputTopic(topic1, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestInputTopic<Integer, String> inputTopic2 =\n                    driver.createInputTopic(topic2, Serdes.Integer().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n            final TestOutputTopic<Integer, String> outputTopic =\n                    driver.createOutputTopic(output, Serdes.Integer().deserializer(), Serdes.String().deserializer());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic1.pipeInput(expectedKeys[i], \"X\" + expectedKeys[i], 5L + i);\n            }\n            \r\n            inputTopic1.pipeInput(null, \"SomeVal\", 42L);\n            \r\n            \r\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                inputTopic2.pipeInput(expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i);\n            }\n            \r\n            inputTopic2.pipeInput(null, \"AnotherVal\", 73L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"X1+Y1\", 10L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XX\" + expectedKey, 7L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+Y1\", 10L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic2.pipeInput(expectedKey, \"YY\" + expectedKey, expectedKey * 5L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXX\" + expectedKey, 6L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic2.pipeInput(expectedKeys[0], null, 5L);\n            inputTopic2.pipeInput(expectedKeys[1], null, 7L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 0, null, 6L);\n            assertOutputKeyValueTimestamp(outputTopic, 1, null, 7L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                inputTopic1.pipeInput(expectedKey, \"XXXX\" + expectedKey, 13L);\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, \"XXXX3+YY3\", 15L);\n            assertTrue(outputTopic.isEmpty());\n\n            \r\n            inputTopic1.pipeInput(expectedKeys[0], null, 0L);\n            inputTopic1.pipeInput(expectedKeys[1], null, 42L);\n            inputTopic1.pipeInput(expectedKeys[2], null, 5L);\n            inputTopic1.pipeInput(expectedKeys[3], null, 20L);\n            \r\n            \r\n            assertOutputKeyValueTimestamp(outputTopic, 2, null, 10L);\n            assertOutputKeyValueTimestamp(outputTopic, 3, null, 20L);\n            assertTrue(outputTopic.isEmpty());\n        }\n    }\n","date":"2019-10-07 16:01:58","endLine":469,"groupId":"101437","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestJoin","params":"(finalStreamsBuilderbuilder@finalint[]expectedKeys)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/44/cc693f9fedcc43f8d2936fec97aefb9726d998.src","preCode":"    private void doTestJoin(final StreamsBuilder builder, final int[] expectedKeys) {\n        final Collection<Set<String>> copartitionGroups =\n            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKeys[i], \"X\" + expectedKeys[i], 5L + i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic1, null, \"SomeVal\", 42L));\n            \r\n            \r\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (int i = 0; i < 2; i++) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKeys[i], \"Y\" + expectedKeys[i], 10L * i));\n            }\n            \r\n            driver.pipeInput(recordFactory.create(topic2, null, \"AnotherVal\", 73L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"X0+Y0\", 5L);\n            assertOutputKeyValueTimestamp(driver, 1, \"X1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XX\" + expectedKey, 7L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+Y0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+Y1\", 10L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic2, expectedKey, \"YY\" + expectedKey, expectedKey * 5L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XX0+YY0\", 7L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XX1+YY1\", 7L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXX\" + expectedKey, 6L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, \"XXX0+YY0\", 6L);\n            assertOutputKeyValueTimestamp(driver, 1, \"XXX1+YY1\", 6L);\n            assertOutputKeyValueTimestamp(driver, 2, \"XXX2+YY2\", 10L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[0], null, 5L));\n            driver.pipeInput(recordFactory.create(topic2, expectedKeys[1], null, 7L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 0, null, 6L);\n            assertOutputKeyValueTimestamp(driver, 1, null, 7L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            for (final int expectedKey : expectedKeys) {\n                driver.pipeInput(recordFactory.create(topic1, expectedKey, \"XXXX\" + expectedKey, 13L));\n            }\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 2, \"XXXX2+YY2\", 13L);\n            assertOutputKeyValueTimestamp(driver, 3, \"XXXX3+YY3\", 15L);\n            assertNull(driver.readOutput(output));\n\n            \r\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[0], null, 0L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[1], null, 42L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[2], null, 5L));\n            driver.pipeInput(recordFactory.create(topic1, expectedKeys[3], null, 20L));\n            \r\n            \r\n            assertOutputKeyValueTimestamp(driver, 2, null, 10L);\n            assertOutputKeyValueTimestamp(driver, 3, null, 20L);\n            assertNull(driver.readOutput(output));\n        }\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableInnerJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":368,"status":"M"},{"authorDate":"2018-05-18 02:28:45","commitOrder":10,"curCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","date":"2018-05-18 02:28:45","endLine":107,"groupId":"101437","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldRequireCopartitionedStreams","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/98/fc5001789d214925fd49bee5a8aefba5759d0e.src","preCode":"    public void shouldRequireCopartitionedStreams() {\n\n        final Collection<Set<String>> copartitionGroups = TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(streamTopic, tableTopic)), copartitionGroups.iterator().next());\n    }\n","realPath":"streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamKTableLeftJoinTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"N"}],"commitId":"a5a6938c69f4310f7ec519036f0df77d8022326a","commitMessage":"@@@KAFKA-8233: TopologyTestDriver test input and output usability improvements (#7378)\n\nImplements KIP-470\n\nReviewers: Bill Bejeck <bill@confluent.io>.  John Roesler <john@confluent.io>.  Matthias J. Sax <matthias@confluent.io>","date":"2019-10-07 16:01:58","modifiedFileCount":"47","status":"M","submitter":"Jukka Karvanen"}]
