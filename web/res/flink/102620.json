[{"authorTime":"2017-03-01 22:36:17","codes":[{"authorDate":"2017-03-01 22:36:17","commitOrder":1,"curCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithLateness() throws Exception {\n\t\t\r\n\t\t\r\n\t\t\r\n\n\t\tfinal int GAP_SIZE = 3;\n\t\tfinal long LATENESS = 10;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(GAP_SIZE)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\t\t\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-2\", 10000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<Object> sideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-3\", 10000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-03-18 14:44:17","endLine":1920,"groupId":"36786","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testNotSideOutputDueToLatenessSessionWithLateness","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b3/8cb2e5ab2d2a952536d4a8fcb6d0fb155beb81.src","preCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithLateness() throws Exception {\n\t\t\r\n\t\t\r\n\t\t\r\n\n\t\tfinal int GAP_SIZE = 3;\n\t\tfinal long LATENESS = 10;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(GAP_SIZE)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\t\t\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-2\", 10000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<Object> sideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-3\", 10000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1820,"status":"B"},{"authorDate":"2017-03-01 22:36:17","commitOrder":1,"curCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithHugeLateness() throws Exception {\n\t\tfinal int GAP_SIZE = 3;\n\t\tfinal long LATENESS = 10000;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(GAP_SIZE)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-7\", 1000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<Object> sideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-8\", 1000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-03-18 14:44:17","endLine":2105,"groupId":"36786","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotSideOutputDueToLatenessSessionWithHugeLateness","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b3/8cb2e5ab2d2a952536d4a8fcb6d0fb155beb81.src","preCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithHugeLateness() throws Exception {\n\t\tfinal int GAP_SIZE = 3;\n\t\tfinal long LATENESS = 10000;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(GAP_SIZE)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-7\", 1000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<Object> sideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-8\", 1000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":2015,"status":"B"}],"commitId":"07a15d0e1647c79ae010ca6df5b1830a4087dd56","commitMessage":"@@@[FLINK-4460] Provide late-data output for window operations\n\nWe use side outputs to emit dropped late data.\n","date":"2017-03-18 14:44:17","modifiedFileCount":"8","status":"B","submitter":"Chen Qin"},{"authorTime":"2017-03-10 18:42:56","codes":[{"authorDate":"2017-03-10 18:42:56","commitOrder":2,"curCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithLateness() throws Exception {\n\t\t\r\n\t\t\r\n\t\t\r\n\n\t\tfinal int GAP_SIZE = 3;\n\t\tfinal long LATENESS = 10;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(GAP_SIZE)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\t\t\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-2\", 10000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(\n\t\t\t\tlateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-3\", 10000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-03-18 14:44:17","endLine":1922,"groupId":"36786","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testNotSideOutputDueToLatenessSessionWithLateness","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8f/8667b3eadd1006616bcdd2e2604988436489ab.src","preCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithLateness() throws Exception {\n\t\t\r\n\t\t\r\n\t\t\r\n\n\t\tfinal int GAP_SIZE = 3;\n\t\tfinal long LATENESS = 10;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(GAP_SIZE)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\t\t\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-2\", 10000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(\n\t\t\t\tlateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-3\", 10000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1821,"status":"MB"},{"authorDate":"2017-03-10 18:42:56","commitOrder":2,"curCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithHugeLateness() throws Exception {\n\t\tfinal int GAP_SIZE = 3;\n\t\tfinal long LATENESS = 10000;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(GAP_SIZE)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-7\", 1000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-8\", 1000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-03-18 14:44:17","endLine":2107,"groupId":"36786","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotSideOutputDueToLatenessSessionWithHugeLateness","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8f/8667b3eadd1006616bcdd2e2604988436489ab.src","preCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithHugeLateness() throws Exception {\n\t\tfinal int GAP_SIZE = 3;\n\t\tfinal long LATENESS = 10000;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(GAP_SIZE)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-7\", 1000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-8\", 1000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":2017,"status":"MB"}],"commitId":"c2afe1b7ba748ccdb1b4233321805f31a6465bc1","commitMessage":"@@@[FLINK-4460] Add WindowOperatorContractTest tests for late data emission\n","date":"2017-03-18 14:44:17","modifiedFileCount":"3","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2017-05-17 20:01:04","codes":[{"authorDate":"2017-05-17 20:01:04","commitOrder":3,"curCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithLateness() throws Exception {\n\t\t\r\n\t\t\r\n\t\t\r\n\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-2\", 10000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(\n\t\t\t\tlateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-3\", 10000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-05-23 04:22:24","endLine":1881,"groupId":"36786","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testNotSideOutputDueToLatenessSessionWithLateness","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/42/c6c6f9aeb78646d1c634a18d5b21eaf608a346.src","preCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithLateness() throws Exception {\n\t\t\r\n\t\t\r\n\t\t\r\n\n\t\tfinal int GAP_SIZE = 3;\n\t\tfinal long LATENESS = 10;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(GAP_SIZE)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-2\", 10000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(\n\t\t\t\tlateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-3\", 10000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1780,"status":"M"},{"authorDate":"2017-05-17 20:01:04","commitOrder":3,"curCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithHugeLateness() throws Exception {\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10000;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-7\", 1000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-8\", 1000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-05-23 04:22:24","endLine":2066,"groupId":"36786","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotSideOutputDueToLatenessSessionWithHugeLateness","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/42/c6c6f9aeb78646d1c634a18d5b21eaf608a346.src","preCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithHugeLateness() throws Exception {\n\t\tfinal int GAP_SIZE = 3;\n\t\tfinal long LATENESS = 10000;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(GAP_SIZE)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-7\", 1000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-8\", 1000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1976,"status":"M"}],"commitId":"12b4185c6c09101b64e12a84c33dc4d28f95cff9","commitMessage":"@@@[FLINK-6603] [streaming] Enable checkstyle on test sources\n\nUpdates / reverts the import order by sections:\n- org.apache.flink.*\n- all other imports\n- javax.*\n- java.*\n- static imports\n\nAdds EmptyLineSeparator to enforce an extra newline (not enforced\nbetween field or local variable declarations).\n\nThis closes #3941\n","date":"2017-05-23 04:22:24","modifiedFileCount":"395","status":"M","submitter":"Greg Hogan"},{"authorTime":"2017-12-20 19:27:56","codes":[{"authorDate":"2017-12-20 19:27:56","commitOrder":4,"curCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithLateness() throws Exception {\n\t\t\r\n\t\t\r\n\t\t\r\n\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-2\", 10000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(\n\t\t\t\tlateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-3\", 10000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-01-06 12:30:12","endLine":1904,"groupId":"36786","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testNotSideOutputDueToLatenessSessionWithLateness","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c0/3207e7f1634926b7c5327931ad5fb6f82d91d2.src","preCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithLateness() throws Exception {\n\t\t\r\n\t\t\r\n\t\t\r\n\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-2\", 10000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(\n\t\t\t\tlateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-3\", 10000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1803,"status":"M"},{"authorDate":"2017-12-20 19:27:56","commitOrder":4,"curCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithHugeLateness() throws Exception {\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10000;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-7\", 1000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-8\", 1000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-01-06 12:30:12","endLine":2089,"groupId":"36786","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotSideOutputDueToLatenessSessionWithHugeLateness","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c0/3207e7f1634926b7c5327931ad5fb6f82d91d2.src","preCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithHugeLateness() throws Exception {\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10000;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-7\", 1000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-8\", 1000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1999,"status":"M"}],"commitId":"091a37052b7045b3ed28c68bfea109024a5d1871","commitMessage":"@@@[FLINK-8298][tests] Properly shutdown MockEnvironment to release resources\n\nThis closes #5193.\n","date":"2018-01-06 12:30:12","modifiedFileCount":"9","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2018-05-04 23:15:51","codes":[{"authorDate":"2018-05-04 23:15:51","commitOrder":5,"curCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithLateness() throws Exception {\n\t\t\r\n\t\t\r\n\t\t\r\n\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10;\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tSTRING_INT_TUPLE.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-2\", 10000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(\n\t\t\t\tlateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-3\", 10000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-05-05 00:48:16","endLine":2024,"groupId":"36786","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testNotSideOutputDueToLatenessSessionWithLateness","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4c/28e4057503dad900453e1a33a86d3f5303b660.src","preCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithLateness() throws Exception {\n\t\t\r\n\t\t\r\n\t\t\r\n\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-2\", 10000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(\n\t\t\t\tlateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-3\", 10000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1925,"status":"M"},{"authorDate":"2018-05-04 23:15:51","commitOrder":5,"curCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithHugeLateness() throws Exception {\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10000;\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tSTRING_INT_TUPLE.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-7\", 1000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-8\", 1000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-05-05 00:48:16","endLine":2205,"groupId":"36786","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotSideOutputDueToLatenessSessionWithHugeLateness","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4c/28e4057503dad900453e1a33a86d3f5303b660.src","preCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithHugeLateness() throws Exception {\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10000;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-7\", 1000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-8\", 1000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":2117,"status":"M"}],"commitId":"c8fa8d025684c2225824c54a7285bbfdec7cfddc","commitMessage":"@@@[FLINK-9292] [core] Remove TypeInfoParser (part 1)\n","date":"2018-05-05 00:48:16","modifiedFileCount":"26","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2018-12-03 15:23:07","codes":[{"authorDate":"2018-12-03 15:23:07","commitOrder":6,"curCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithLateness() throws Exception {\n\t\t\r\n\t\t\r\n\t\t\r\n\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10;\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tSTRING_INT_TUPLE.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tlateOutputTag );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-2\", 10000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(\n\t\t\t\tlateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-3\", 10000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-12-11 18:52:13","endLine":2024,"groupId":"102620","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testNotSideOutputDueToLatenessSessionWithLateness","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/5b/c17782d9c9f210d345d77ebbb39d6a72cb8f05.src","preCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithLateness() throws Exception {\n\t\t\r\n\t\t\r\n\t\t\r\n\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10;\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tSTRING_INT_TUPLE.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-2\", 10000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(\n\t\t\t\tlateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-3\", 10000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1925,"status":"M"},{"authorDate":"2018-12-03 15:23:07","commitOrder":6,"curCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithHugeLateness() throws Exception {\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10000;\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tSTRING_INT_TUPLE.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tlateOutputTag );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-7\", 1000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-8\", 1000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-12-11 18:52:13","endLine":2205,"groupId":"102620","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotSideOutputDueToLatenessSessionWithHugeLateness","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/5b/c17782d9c9f210d345d77ebbb39d6a72cb8f05.src","preCode":"\tpublic void testNotSideOutputDueToLatenessSessionWithHugeLateness() throws Exception {\n\t\tfinal int gapSize = 3;\n\t\tfinal long lateness = 10000;\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tSTRING_INT_TUPLE.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Long, Long>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tEventTimeSessionWindows.withGap(Time.seconds(gapSize)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new ReducedSessionWindowFunction()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\n\t\texpected.add(new Watermark(1999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 2000));\n\t\ttestHarness.processWatermark(new Watermark(4998));\n\n\t\texpected.add(new Watermark(4998));\n\n\t\t\r\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 4500));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 8500));\n\t\ttestHarness.processWatermark(new Watermark(7400));\n\n\t\texpected.add(new Watermark(7400));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processWatermark(new Watermark(11501));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-5\", 1000L, 11500L), 11499));\n\t\texpected.add(new Watermark(11501));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 11600));\n\t\ttestHarness.processWatermark(new Watermark(14600));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-1\", 11600L, 14600L), 14599));\n\t\texpected.add(new Watermark(14600));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 10000));\n\n\t\t\r\n\t\t\r\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-7\", 1000L, 14600L), 14599));\n\n\t\tConcurrentLinkedQueue<Object> actual = testHarness.getOutput();\n\t\tConcurrentLinkedQueue<StreamRecord<Tuple2<String, Integer>>> sideActual = testHarness.getSideOutput(lateOutputTag);\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 14500));\n\t\ttestHarness.processWatermark(new Watermark(20000));\n\n\t\texpected.add(new StreamRecord<>(new Tuple3<>(\"key2-8\", 1000L, 17500L), 17499));\n\t\texpected.add(new Watermark(20000));\n\n\t\ttestHarness.processWatermark(new Watermark(100000));\n\t\texpected.add(new Watermark(100000));\n\n\t\tactual = testHarness.getOutput();\n\t\tsideActual = testHarness.getSideOutput(lateOutputTag);\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, actual, new Tuple3ResultSortComparator());\n\t\tassertEquals(null, sideActual);\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":2117,"status":"M"}],"commitId":"927936d573bbfdd9501d3e1d0a9f913d9882e42e","commitMessage":"@@@[hotfix][test][streaming] Fix invalid testNotSideOutputXXX in WindowOperatorTest\n","date":"2018-12-11 18:52:13","modifiedFileCount":"1","status":"M","submitter":"blueszheng"}]
