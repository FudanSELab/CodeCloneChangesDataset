[{"authorTime":"2016-09-01 06:48:43","codes":[{"authorDate":"2016-09-01 06:48:43","commitOrder":1,"curCode":"    public void sstableRepairStatusChanged()\n    {\n        UUID repairID = registerSession(cfs);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n\n        \r\n        SSTableReader sstable = makeSSTable(false);\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        SSTableRepairStatusChanged notification;\n\n        \r\n        mutateRepaired(sstable, repairID);\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertTrue(pendingContains(repairID, sstable));\n\n        \r\n        mutateRepaired(sstable, System.currentTimeMillis());\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertTrue(repairedContains(sstable));\n        Assert.assertFalse(pendingContains(repairID, sstable));\n    }\n","date":"2017-02-07 11:11:18","endLine":174,"groupId":"22793","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"sstableRepairStatusChanged","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/8f/5378137ef576f26b3de860b082fb7aa880d47b.src","preCode":"    public void sstableRepairStatusChanged()\n    {\n        UUID repairID = registerSession(cfs);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n\n        \r\n        SSTableReader sstable = makeSSTable(false);\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        SSTableRepairStatusChanged notification;\n\n        \r\n        mutateRepaired(sstable, repairID);\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertTrue(pendingContains(repairID, sstable));\n\n        \r\n        mutateRepaired(sstable, System.currentTimeMillis());\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertTrue(repairedContains(sstable));\n        Assert.assertFalse(pendingContains(repairID, sstable));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/CompactionStrategyManagerPendingRepairTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":145,"status":"B"},{"authorDate":"2016-09-01 06:48:43","commitOrder":1,"curCode":"    public void cleanupCompactionFailed()\n    {\n        UUID repairID = registerSession(cfs);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        csm.handleNotification(new SSTableAddedNotification(Collections.singleton(sstable)), cfs.getTracker());\n        LocalSessionAccessor.failUnsafe(repairID);\n\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertNotNull(pendingContains(repairID, sstable));\n        Assert.assertTrue(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n\n        AbstractCompactionTask compactionTask = csm.getNextBackgroundTask(FBUtilities.nowInSeconds());\n        Assert.assertNotNull(compactionTask);\n        Assert.assertSame(PendingRepairManager.RepairFinishedCompactionTask.class, compactionTask.getClass());\n\n        \r\n        compactionTask.execute(null);\n\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(unrepairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        \r\n        Assert.assertFalse(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n        Assert.assertEquals(ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getSSTableMetadata().repairedAt);\n    }\n","date":"2017-02-07 11:11:18","endLine":290,"groupId":"27078","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanupCompactionFailed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/8f/5378137ef576f26b3de860b082fb7aa880d47b.src","preCode":"    public void cleanupCompactionFailed()\n    {\n        UUID repairID = registerSession(cfs);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        csm.handleNotification(new SSTableAddedNotification(Collections.singleton(sstable)), cfs.getTracker());\n        LocalSessionAccessor.failUnsafe(repairID);\n\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertNotNull(pendingContains(repairID, sstable));\n        Assert.assertTrue(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n\n        AbstractCompactionTask compactionTask = csm.getNextBackgroundTask(FBUtilities.nowInSeconds());\n        Assert.assertNotNull(compactionTask);\n        Assert.assertSame(PendingRepairManager.RepairFinishedCompactionTask.class, compactionTask.getClass());\n\n        \r\n        compactionTask.execute(null);\n\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(unrepairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        \r\n        Assert.assertFalse(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n        Assert.assertEquals(ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getSSTableMetadata().repairedAt);\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/CompactionStrategyManagerPendingRepairTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":261,"status":"B"}],"commitId":"98d74ed998706e9e047dc0f7886a1e9b18df3ce9","commitMessage":"@@@Fix consistency of incrementally repaired data\n\npatch by Blake Eggleston.  reviewed by Marcus Eriksson for CASSANDRA-9143\n","date":"2017-02-07 11:11:18","modifiedFileCount":"81","status":"B","submitter":"Blake Eggleston"},{"authorTime":"2017-02-16 02:47:24","codes":[{"authorDate":"2017-02-16 02:47:24","commitOrder":2,"curCode":"    public void sstableRepairStatusChanged()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n\n        \r\n        SSTableReader sstable = makeSSTable(false);\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        SSTableRepairStatusChanged notification;\n\n        \r\n        mutateRepaired(sstable, repairID);\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertTrue(pendingContains(repairID, sstable));\n\n        \r\n        mutateRepaired(sstable, System.currentTimeMillis());\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertTrue(repairedContains(sstable));\n        Assert.assertFalse(pendingContains(repairID, sstable));\n    }\n","date":"2017-02-18 05:57:17","endLine":174,"groupId":"22793","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"sstableRepairStatusChanged","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/27/bff2082e0b017b0223e940d3123df38cf784a3.src","preCode":"    public void sstableRepairStatusChanged()\n    {\n        UUID repairID = registerSession(cfs);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n\n        \r\n        SSTableReader sstable = makeSSTable(false);\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        SSTableRepairStatusChanged notification;\n\n        \r\n        mutateRepaired(sstable, repairID);\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertTrue(pendingContains(repairID, sstable));\n\n        \r\n        mutateRepaired(sstable, System.currentTimeMillis());\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertTrue(repairedContains(sstable));\n        Assert.assertFalse(pendingContains(repairID, sstable));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/CompactionStrategyManagerPendingRepairTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":145,"status":"M"},{"authorDate":"2017-02-16 02:47:24","commitOrder":2,"curCode":"    public void cleanupCompactionFailed()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        csm.handleNotification(new SSTableAddedNotification(Collections.singleton(sstable)), cfs.getTracker());\n        LocalSessionAccessor.failUnsafe(repairID);\n\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertNotNull(pendingContains(repairID, sstable));\n        Assert.assertTrue(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n\n        AbstractCompactionTask compactionTask = csm.getNextBackgroundTask(FBUtilities.nowInSeconds());\n        Assert.assertNotNull(compactionTask);\n        Assert.assertSame(PendingRepairManager.RepairFinishedCompactionTask.class, compactionTask.getClass());\n\n        \r\n        compactionTask.execute(null);\n\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(unrepairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        \r\n        Assert.assertFalse(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n        Assert.assertEquals(ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getSSTableMetadata().repairedAt);\n    }\n","date":"2017-02-18 05:57:17","endLine":290,"groupId":"27078","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanupCompactionFailed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/27/bff2082e0b017b0223e940d3123df38cf784a3.src","preCode":"    public void cleanupCompactionFailed()\n    {\n        UUID repairID = registerSession(cfs);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        csm.handleNotification(new SSTableAddedNotification(Collections.singleton(sstable)), cfs.getTracker());\n        LocalSessionAccessor.failUnsafe(repairID);\n\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertNotNull(pendingContains(repairID, sstable));\n        Assert.assertTrue(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n\n        AbstractCompactionTask compactionTask = csm.getNextBackgroundTask(FBUtilities.nowInSeconds());\n        Assert.assertNotNull(compactionTask);\n        Assert.assertSame(PendingRepairManager.RepairFinishedCompactionTask.class, compactionTask.getClass());\n\n        \r\n        compactionTask.execute(null);\n\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(unrepairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        \r\n        Assert.assertFalse(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n        Assert.assertEquals(ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getSSTableMetadata().repairedAt);\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/CompactionStrategyManagerPendingRepairTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":261,"status":"M"}],"commitId":"c878b6968be88fa89fb1d1d0212411bcbc4fae7c","commitMessage":"@@@StreamPlan for incremental repairs flushing memtables unnecessarily\nPatch by Blake Eggleston; Reviewed by Marcus Eriksson for CASSANDRA-13226\n","date":"2017-02-18 05:57:17","modifiedFileCount":"8","status":"M","submitter":"Blake Eggleston"},{"authorTime":"2017-04-04 23:09:16","codes":[{"authorDate":"2017-02-16 02:47:24","commitOrder":3,"curCode":"    public void sstableRepairStatusChanged()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n\n        \r\n        SSTableReader sstable = makeSSTable(false);\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        SSTableRepairStatusChanged notification;\n\n        \r\n        mutateRepaired(sstable, repairID);\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertTrue(pendingContains(repairID, sstable));\n\n        \r\n        mutateRepaired(sstable, System.currentTimeMillis());\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertTrue(repairedContains(sstable));\n        Assert.assertFalse(pendingContains(repairID, sstable));\n    }\n","date":"2017-02-18 05:57:17","endLine":174,"groupId":"22793","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"sstableRepairStatusChanged","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/27/bff2082e0b017b0223e940d3123df38cf784a3.src","preCode":"    public void sstableRepairStatusChanged()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n\n        \r\n        SSTableReader sstable = makeSSTable(false);\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        SSTableRepairStatusChanged notification;\n\n        \r\n        mutateRepaired(sstable, repairID);\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertTrue(pendingContains(repairID, sstable));\n\n        \r\n        mutateRepaired(sstable, System.currentTimeMillis());\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertTrue(repairedContains(sstable));\n        Assert.assertFalse(pendingContains(repairID, sstable));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/CompactionStrategyManagerPendingRepairTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":145,"status":"N"},{"authorDate":"2017-04-04 23:09:16","commitOrder":3,"curCode":"    public void cleanupCompactionFailed()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        csm.handleNotification(new SSTableAddedNotification(Collections.singleton(sstable)), cfs.getTracker());\n        LocalSessionAccessor.failUnsafe(repairID);\n\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertNotNull(pendingContains(repairID, sstable));\n        Assert.assertTrue(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n\n        cfs.getCompactionStrategyManager().enable(); \r\n        AbstractCompactionTask compactionTask = csm.getNextBackgroundTask(FBUtilities.nowInSeconds());\n        Assert.assertNotNull(compactionTask);\n        Assert.assertSame(PendingRepairManager.RepairFinishedCompactionTask.class, compactionTask.getClass());\n\n        \r\n        compactionTask.execute(null);\n\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(unrepairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        \r\n        Assert.assertFalse(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n        Assert.assertEquals(ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getSSTableMetadata().repairedAt);\n    }\n","date":"2017-04-06 21:16:54","endLine":292,"groupId":"20133","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanupCompactionFailed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/0b/27f73f1405865e7819a755245f82c9267abc94.src","preCode":"    public void cleanupCompactionFailed()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        csm.handleNotification(new SSTableAddedNotification(Collections.singleton(sstable)), cfs.getTracker());\n        LocalSessionAccessor.failUnsafe(repairID);\n\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertNotNull(pendingContains(repairID, sstable));\n        Assert.assertTrue(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n\n        AbstractCompactionTask compactionTask = csm.getNextBackgroundTask(FBUtilities.nowInSeconds());\n        Assert.assertNotNull(compactionTask);\n        Assert.assertSame(PendingRepairManager.RepairFinishedCompactionTask.class, compactionTask.getClass());\n\n        \r\n        compactionTask.execute(null);\n\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(unrepairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        \r\n        Assert.assertFalse(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n        Assert.assertEquals(ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getSSTableMetadata().repairedAt);\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/CompactionStrategyManagerPendingRepairTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":262,"status":"M"}],"commitId":"30820eacb9c565d06260031260910f020e16e83d","commitMessage":"@@@Disable compaction during PendingRepairTests\n\nPatch by Paulo Motta; Reviewed by Blake Eggleston for CASSANDRA-13224\n","date":"2017-04-06 21:16:54","modifiedFileCount":"3","status":"M","submitter":"Paulo Motta"},{"authorTime":"2017-06-23 16:30:21","codes":[{"authorDate":"2017-02-16 02:47:24","commitOrder":4,"curCode":"    public void sstableRepairStatusChanged()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n\n        \r\n        SSTableReader sstable = makeSSTable(false);\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        SSTableRepairStatusChanged notification;\n\n        \r\n        mutateRepaired(sstable, repairID);\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertTrue(pendingContains(repairID, sstable));\n\n        \r\n        mutateRepaired(sstable, System.currentTimeMillis());\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertTrue(repairedContains(sstable));\n        Assert.assertFalse(pendingContains(repairID, sstable));\n    }\n","date":"2017-02-18 05:57:17","endLine":174,"groupId":"22793","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"sstableRepairStatusChanged","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/27/bff2082e0b017b0223e940d3123df38cf784a3.src","preCode":"    public void sstableRepairStatusChanged()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n\n        \r\n        SSTableReader sstable = makeSSTable(false);\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        SSTableRepairStatusChanged notification;\n\n        \r\n        mutateRepaired(sstable, repairID);\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertTrue(pendingContains(repairID, sstable));\n\n        \r\n        mutateRepaired(sstable, System.currentTimeMillis());\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertTrue(repairedContains(sstable));\n        Assert.assertFalse(pendingContains(repairID, sstable));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/CompactionStrategyManagerPendingRepairTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":145,"status":"N"},{"authorDate":"2017-06-23 16:30:21","commitOrder":4,"curCode":"    public void cleanupCompactionFailed()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        csm.handleNotification(new SSTableAddedNotification(Collections.singleton(sstable), null), cfs.getTracker());\n        LocalSessionAccessor.failUnsafe(repairID);\n\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertNotNull(pendingContains(repairID, sstable));\n        Assert.assertTrue(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n\n        cfs.getCompactionStrategyManager().enable(); \r\n        AbstractCompactionTask compactionTask = csm.getNextBackgroundTask(FBUtilities.nowInSeconds());\n        Assert.assertNotNull(compactionTask);\n        Assert.assertSame(PendingRepairManager.RepairFinishedCompactionTask.class, compactionTask.getClass());\n\n        \r\n        compactionTask.execute(null);\n\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(unrepairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        \r\n        Assert.assertFalse(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n        Assert.assertEquals(ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getSSTableMetadata().repairedAt);\n    }\n","date":"2017-06-23 16:30:21","endLine":292,"groupId":"20133","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanupCompactionFailed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/af/629e56706b933a658c7ce0123d2f54f05c2826.src","preCode":"    public void cleanupCompactionFailed()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        csm.handleNotification(new SSTableAddedNotification(Collections.singleton(sstable)), cfs.getTracker());\n        LocalSessionAccessor.failUnsafe(repairID);\n\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertNotNull(pendingContains(repairID, sstable));\n        Assert.assertTrue(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n\n        cfs.getCompactionStrategyManager().enable(); \r\n        AbstractCompactionTask compactionTask = csm.getNextBackgroundTask(FBUtilities.nowInSeconds());\n        Assert.assertNotNull(compactionTask);\n        Assert.assertSame(PendingRepairManager.RepairFinishedCompactionTask.class, compactionTask.getClass());\n\n        \r\n        compactionTask.execute(null);\n\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(unrepairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        \r\n        Assert.assertFalse(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n        Assert.assertEquals(ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getSSTableMetadata().repairedAt);\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/CompactionStrategyManagerPendingRepairTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":262,"status":"M"}],"commitId":"679c31718b709f5619bba80eeb6f388484b94c3c","commitMessage":"@@@Improve secondary index (re)build failure and concurrency handling\n\npatch by Andres de la Pe?a; reviewed by Paulo Motta and Sergio Bossa for CASSANDRA-10130\n","date":"2017-06-23 16:30:21","modifiedFileCount":"15","status":"M","submitter":"Andre?s de la Pen?a"},{"authorTime":"2018-07-06 06:10:40","codes":[{"authorDate":"2018-07-06 06:10:40","commitOrder":5,"curCode":"    public void sstableRepairStatusChanged()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n\n        \r\n        SSTableReader sstable = makeSSTable(false);\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertFalse(hasPendingStrategiesFor(repairID));\n        Assert.assertFalse(hasTransientStrategiesFor(repairID));\n\n        SSTableRepairStatusChanged notification;\n\n        \r\n        mutateRepaired(sstable, repairID, false);\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(hasPendingStrategiesFor(repairID));\n        Assert.assertFalse(hasTransientStrategiesFor(repairID));\n        Assert.assertTrue(pendingContains(sstable));\n\n        \r\n        mutateRepaired(sstable, System.currentTimeMillis());\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertTrue(repairedContains(sstable));\n        Assert.assertFalse(pendingContains(sstable));\n    }\n","date":"2018-09-01 09:34:22","endLine":184,"groupId":"16080","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"sstableRepairStatusChanged","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/26/7c2e416ef2bb3d3ca3d5f89f598a8683407b07.src","preCode":"    public void sstableRepairStatusChanged()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n\n        \r\n        SSTableReader sstable = makeSSTable(false);\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        SSTableRepairStatusChanged notification;\n\n        \r\n        mutateRepaired(sstable, repairID);\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertTrue(pendingContains(repairID, sstable));\n\n        \r\n        mutateRepaired(sstable, System.currentTimeMillis());\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertTrue(repairedContains(sstable));\n        Assert.assertFalse(pendingContains(repairID, sstable));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/CompactionStrategyManagerPendingRepairTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"},{"authorDate":"2018-07-06 06:10:40","commitOrder":5,"curCode":"    public void cleanupCompactionFailed()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID, false);\n        csm.handleNotification(new SSTableAddedNotification(Collections.singleton(sstable), null), cfs.getTracker());\n        LocalSessionAccessor.failUnsafe(repairID);\n\n        Assert.assertTrue(hasPendingStrategiesFor(repairID));\n        Assert.assertFalse(hasTransientStrategiesFor(repairID));\n        Assert.assertTrue(pendingContains(sstable));\n        Assert.assertTrue(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n\n        cfs.getCompactionStrategyManager().enable(); \r\n        AbstractCompactionTask compactionTask = csm.getNextBackgroundTask(FBUtilities.nowInSeconds());\n        Assert.assertNotNull(compactionTask);\n        Assert.assertSame(PendingRepairManager.RepairFinishedCompactionTask.class, compactionTask.getClass());\n\n        \r\n        compactionTask.execute(null);\n\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(hasPendingStrategiesFor(repairID));\n        Assert.assertFalse(hasTransientStrategiesFor(repairID));\n\n        \r\n        Assert.assertFalse(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n        Assert.assertEquals(ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getSSTableMetadata().repairedAt);\n    }\n","date":"2018-09-01 09:34:22","endLine":307,"groupId":"13901","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanupCompactionFailed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/26/7c2e416ef2bb3d3ca3d5f89f598a8683407b07.src","preCode":"    public void cleanupCompactionFailed()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        csm.handleNotification(new SSTableAddedNotification(Collections.singleton(sstable), null), cfs.getTracker());\n        LocalSessionAccessor.failUnsafe(repairID);\n\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNotNull);\n        Assert.assertNotNull(pendingContains(repairID, sstable));\n        Assert.assertTrue(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n\n        cfs.getCompactionStrategyManager().enable(); \r\n        AbstractCompactionTask compactionTask = csm.getNextBackgroundTask(FBUtilities.nowInSeconds());\n        Assert.assertNotNull(compactionTask);\n        Assert.assertSame(PendingRepairManager.RepairFinishedCompactionTask.class, compactionTask.getClass());\n\n        \r\n        compactionTask.execute(null);\n\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(unrepairedContains(sstable));\n        csm.getForPendingRepair(repairID).forEach(Assert::assertNull);\n\n        \r\n        Assert.assertFalse(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n        Assert.assertEquals(ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getSSTableMetadata().repairedAt);\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/CompactionStrategyManagerPendingRepairTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":275,"status":"M"}],"commitId":"f7431b432875e334170ccdb19934d05545d2cebd","commitMessage":"@@@Transient Replication and Cheap Quorums\n\nPatch by Blake Eggleston.  Benedict Elliott Smith.  Marcus Eriksson.  Alex Petrov.  Ariel Weisberg; Reviewed by Blake Eggleston.  Marcus Eriksson.  Benedict Elliott Smith.  Alex Petrov.  Ariel Weisberg for CASSANDRA-14404\n\nCo-authored-by: Blake Eggleston <bdeggleston@gmail.com>\nCo-authored-by: Benedict Elliott Smith <benedict@apache.org>\nCo-authored-by: Marcus Eriksson <marcuse@apache.org>\nCo-authored-by: Alex Petrov <oleksandr.petrov@gmail.com>\n","date":"2018-09-01 09:34:22","modifiedFileCount":"230","status":"M","submitter":"Ariel Weisberg"},{"authorTime":"2018-12-19 00:01:02","codes":[{"authorDate":"2018-07-06 06:10:40","commitOrder":6,"curCode":"    public void sstableRepairStatusChanged()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n\n        \r\n        SSTableReader sstable = makeSSTable(false);\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertFalse(hasPendingStrategiesFor(repairID));\n        Assert.assertFalse(hasTransientStrategiesFor(repairID));\n\n        SSTableRepairStatusChanged notification;\n\n        \r\n        mutateRepaired(sstable, repairID, false);\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(hasPendingStrategiesFor(repairID));\n        Assert.assertFalse(hasTransientStrategiesFor(repairID));\n        Assert.assertTrue(pendingContains(sstable));\n\n        \r\n        mutateRepaired(sstable, System.currentTimeMillis());\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertTrue(repairedContains(sstable));\n        Assert.assertFalse(pendingContains(sstable));\n    }\n","date":"2018-09-01 09:34:22","endLine":184,"groupId":"10779","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"sstableRepairStatusChanged","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/26/7c2e416ef2bb3d3ca3d5f89f598a8683407b07.src","preCode":"    public void sstableRepairStatusChanged()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n\n        \r\n        SSTableReader sstable = makeSSTable(false);\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertFalse(hasPendingStrategiesFor(repairID));\n        Assert.assertFalse(hasTransientStrategiesFor(repairID));\n\n        SSTableRepairStatusChanged notification;\n\n        \r\n        mutateRepaired(sstable, repairID, false);\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(hasPendingStrategiesFor(repairID));\n        Assert.assertFalse(hasTransientStrategiesFor(repairID));\n        Assert.assertTrue(pendingContains(sstable));\n\n        \r\n        mutateRepaired(sstable, System.currentTimeMillis());\n        notification = new SSTableRepairStatusChanged(Collections.singleton(sstable));\n        csm.handleNotification(notification, cfs.getTracker());\n        Assert.assertFalse(unrepairedContains(sstable));\n        Assert.assertTrue(repairedContains(sstable));\n        Assert.assertFalse(pendingContains(sstable));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/CompactionStrategyManagerPendingRepairTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"N"},{"authorDate":"2018-12-19 00:01:02","commitOrder":6,"curCode":"    public void cleanupCompactionFailed()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID, false);\n        csm.handleNotification(new SSTableAddedNotification(Collections.singleton(sstable), null), cfs.getTracker());\n        LocalSessionAccessor.failUnsafe(repairID);\n\n        Assert.assertTrue(hasPendingStrategiesFor(repairID));\n        Assert.assertFalse(hasTransientStrategiesFor(repairID));\n        Assert.assertTrue(pendingContains(sstable));\n        Assert.assertTrue(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n\n        cfs.getCompactionStrategyManager().enable(); \r\n        AbstractCompactionTask compactionTask = csm.getNextBackgroundTask(FBUtilities.nowInSeconds());\n        Assert.assertNotNull(compactionTask);\n        Assert.assertSame(PendingRepairManager.RepairFinishedCompactionTask.class, compactionTask.getClass());\n\n        \r\n        compactionTask.execute(ActiveCompactionsTracker.NOOP);\n\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(hasPendingStrategiesFor(repairID));\n        Assert.assertFalse(hasTransientStrategiesFor(repairID));\n\n        \r\n        Assert.assertFalse(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n        Assert.assertEquals(ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getSSTableMetadata().repairedAt);\n    }\n","date":"2019-01-17 15:01:16","endLine":307,"groupId":"10779","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanupCompactionFailed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/9f/2bc2ea75fbbe2b3083b6d3c38eeec8af48d1b3.src","preCode":"    public void cleanupCompactionFailed()\n    {\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID, false);\n        csm.handleNotification(new SSTableAddedNotification(Collections.singleton(sstable), null), cfs.getTracker());\n        LocalSessionAccessor.failUnsafe(repairID);\n\n        Assert.assertTrue(hasPendingStrategiesFor(repairID));\n        Assert.assertFalse(hasTransientStrategiesFor(repairID));\n        Assert.assertTrue(pendingContains(sstable));\n        Assert.assertTrue(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n\n        cfs.getCompactionStrategyManager().enable(); \r\n        AbstractCompactionTask compactionTask = csm.getNextBackgroundTask(FBUtilities.nowInSeconds());\n        Assert.assertNotNull(compactionTask);\n        Assert.assertSame(PendingRepairManager.RepairFinishedCompactionTask.class, compactionTask.getClass());\n\n        \r\n        compactionTask.execute(null);\n\n        Assert.assertFalse(repairedContains(sstable));\n        Assert.assertTrue(unrepairedContains(sstable));\n        Assert.assertFalse(hasPendingStrategiesFor(repairID));\n        Assert.assertFalse(hasTransientStrategiesFor(repairID));\n\n        \r\n        Assert.assertFalse(sstable.isPendingRepair());\n        Assert.assertFalse(sstable.isRepaired());\n        Assert.assertEquals(ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getSSTableMetadata().repairedAt);\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/CompactionStrategyManagerPendingRepairTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":275,"status":"M"}],"commitId":"6e27e65f150ed6cc6a7205b9d7c89a763f3256fa","commitMessage":"@@@Only cancel conflicting compactions when starting anticompactions and sub range compactions\n\nPatch by marcuse; reviewed by Blake Eggleston for CASSANDRA-14935\n","date":"2019-01-17 15:01:16","modifiedFileCount":"41","status":"M","submitter":"Marcus Eriksson"}]
