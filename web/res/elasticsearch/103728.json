[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testShardLockObtainFailedException() {\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,\n            \"allocId1\");\n        testAllocator.addData(node1, \"allocId1\", randomBoolean(), new ShardLockObtainFailedException(shardId, \"test\"));\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo(\"allocId1\"));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","date":"2018-04-26 03:22:53","endLine":162,"groupId":"25979","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testShardLockObtainFailedException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/687548190a3c41271e5b541d858d53a809dc52.src","preCode":"    public void testShardLockObtainFailedException() {\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,\n            \"allocId1\");\n        testAllocator.addData(node1, \"allocId1\", randomBoolean(), new ShardLockObtainFailedException(shardId, \"test\"));\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo(\"allocId1\"));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testRestoreThrottle() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), \"allocId\");\n        testAllocator.addData(node1, \"some allocId\", randomBoolean());\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","date":"2018-04-26 03:22:53","endLine":347,"groupId":"25979","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRestoreThrottle","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/687548190a3c41271e5b541d858d53a809dc52.src","preCode":"    public void testRestoreThrottle() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), \"allocId\");\n        testAllocator.addData(node1, \"some allocId\", randomBoolean());\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":340,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2020-04-06 21:51:05","codes":[{"authorDate":"2020-04-06 21:51:05","commitOrder":2,"curCode":"    public void testShardLockObtainFailedException() {\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,\n            \"allocId1\");\n        testAllocator.addData(node1, \"allocId1\", randomBoolean(), new ShardLockObtainFailedException(shardId, \"test\"));\n        allocateAllUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),\n            equalTo(node1.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),\n            equalTo(\"allocId1\"));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","date":"2020-04-06 21:51:05","endLine":173,"groupId":"25979","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testShardLockObtainFailedException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/24/04facdda7301eb4453ff42dcb5e13ee382d239.src","preCode":"    public void testShardLockObtainFailedException() {\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,\n            \"allocId1\");\n        testAllocator.addData(node1, \"allocId1\", randomBoolean(), new ShardLockObtainFailedException(shardId, \"test\"));\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),\n            equalTo(node1.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),\n            equalTo(\"allocId1\"));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":159,"status":"M"},{"authorDate":"2020-04-06 21:51:05","commitOrder":2,"curCode":"    public void testRestoreThrottle() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), \"allocId\");\n        testAllocator.addData(node1, \"some allocId\", randomBoolean());\n        allocateAllUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","date":"2020-04-06 21:51:05","endLine":364,"groupId":"25979","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRestoreThrottle","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/24/04facdda7301eb4453ff42dcb5e13ee382d239.src","preCode":"    public void testRestoreThrottle() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), \"allocId\");\n        testAllocator.addData(node1, \"some allocId\", randomBoolean());\n        testAllocator.allocateUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":357,"status":"M"}],"commitId":"f6feb6c2c845aaab31cec4b4047c77c2caf85b89","commitMessage":"@@@Merge feature/searchable-snapshots branch into master (#54803)\n\nThis commit merges the searchable-snapshots feature branch into master.\nSee #54803 for the complete list of squashed commits.\n\nCo-authored-by: David Turner <david.turner@elastic.co>\nCo-authored-by: Yannick Welsch <yannick@welsch.lu>\nCo-authored-by: Lee Hinman <dakrone@users.noreply.github.com>\nCo-authored-by: Andrei Dan <andrei.dan@elastic.co>","date":"2020-04-06 21:51:05","modifiedFileCount":"73","status":"M","submitter":"Tanguy Leroux"},{"authorTime":"2020-10-06 23:29:42","codes":[{"authorDate":"2020-04-06 21:51:05","commitOrder":3,"curCode":"    public void testShardLockObtainFailedException() {\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,\n            \"allocId1\");\n        testAllocator.addData(node1, \"allocId1\", randomBoolean(), new ShardLockObtainFailedException(shardId, \"test\"));\n        allocateAllUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),\n            equalTo(node1.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),\n            equalTo(\"allocId1\"));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","date":"2020-04-06 21:51:05","endLine":173,"groupId":"103728","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testShardLockObtainFailedException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/24/04facdda7301eb4453ff42dcb5e13ee382d239.src","preCode":"    public void testShardLockObtainFailedException() {\n        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,\n            \"allocId1\");\n        testAllocator.addData(node1, \"allocId1\", randomBoolean(), new ShardLockObtainFailedException(shardId, \"test\"));\n        allocateAllUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),\n            equalTo(node1.getId()));\n        \r\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),\n            equalTo(\"allocId1\"));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":159,"status":"N"},{"authorDate":"2020-10-06 23:29:42","commitOrder":3,"curCode":"    public void testRestoreThrottle() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), randomLong(), \"allocId\");\n        testAllocator.addData(node1, \"some allocId\", randomBoolean());\n        allocateAllUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","date":"2020-10-06 23:29:42","endLine":366,"groupId":"103728","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testRestoreThrottle","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/85/55ec1ea142878114976f3da2bf9d4703ed9161.src","preCode":"    public void testRestoreThrottle() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), \"allocId\");\n        testAllocator.addData(node1, \"some allocId\", randomBoolean());\n        allocateAllUnassigned(allocation);\n        assertThat(allocation.routingNodesChanged(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false));\n        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"M"}],"commitId":"2afec0d916c7de33c9a6c3cbe30a8a2ee61be765","commitMessage":"@@@Determine shard size before allocating shards recovering from snapshots (#61906)\n\nDetermines the shard size of shards before allocating shards that are \nrecovering from snapshots. It ensures during shard allocation that the \ntarget node that is selected as recovery target will have enough free \ndisk space for the recovery event. This applies to regular restores.  \nCCR bootstrap from remote.  as well as mounting searchable snapshots.\n\nThe InternalSnapshotInfoService is responsible for fetching snapshot \nshard sizes from repositories. It provides a getShardSize() method \nto other components of the system that can be used to retrieve the \nlatest known shard size. If the latest snapshot shard size retrieval \nfailed.  the getShardSize() returns \nShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE. While \nwe'd like a better way to handle such failures.  returning this value \nallows to keep the existing behavior for now.\n\nNote that this PR does not address an issues (we already have today) \nwhere a replica is being allocated without knowing how much disk \nspace is being used by the primary. ","date":"2020-10-06 23:29:42","modifiedFileCount":"49","status":"M","submitter":"Yannick Welsch"}]
