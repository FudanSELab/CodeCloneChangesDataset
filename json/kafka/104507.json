[{"authorTime":"2020-12-29 10:37:08","codes":[{"authorDate":"2020-12-29 10:37:08","commitOrder":1,"curCode":"    public void testFetchSnapshotResponseFromNewerEpochNotLeader() throws Exception {\n        int localId = 0;\n        int firstLeaderId = localId + 1;\n        int secondLeaderId = firstLeaderId + 1;\n        Set<Integer> voters = Utils.mkSet(localId, firstLeaderId, secondLeaderId);\n        int epoch = 2;\n        OffsetAndEpoch snapshotId = new OffsetAndEpoch(100L, 1);\n\n        RaftClientTestContext context = new RaftClientTestContext.Builder(localId, voters)\n            .withElectedLeader(epoch, firstLeaderId)\n            .build();\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch, 0L, 0);\n\n        context.deliverResponse(\n            fetchRequest.correlationId,\n            fetchRequest.destinationId(),\n            snapshotFetchResponse(context.metadataPartition, epoch, firstLeaderId, snapshotId, 200L)\n        );\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound snapshotRequest = context.assertSentFetchSnapshotRequest();\n        FetchSnapshotRequestData.PartitionSnapshot request = assertFetchSnapshotRequest(\n                snapshotRequest,\n                context.metadataPartition,\n                localId,\n                Integer.MAX_VALUE\n        ).get();\n        assertEquals(snapshotId.offset, request.snapshotId().endOffset());\n        assertEquals(snapshotId.epoch, request.snapshotId().epoch());\n        assertEquals(0, request.position());\n\n        \r\n        context.deliverResponse(\n            snapshotRequest.correlationId,\n            snapshotRequest.destinationId(),\n            FetchSnapshotResponse.singleton(\n                context.metadataPartition,\n                responsePartitionSnapshot -> {\n                    responsePartitionSnapshot\n                        .currentLeader()\n                        .setLeaderEpoch(epoch + 1)\n                        .setLeaderId(secondLeaderId);\n\n                    return responsePartitionSnapshot\n                        .setErrorCode(Errors.FENCED_LEADER_EPOCH.code());\n                }\n            )\n        );\n\n        context.pollUntilRequest();\n        fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch + 1, 0L, 0);\n    }\n","date":"2020-12-29 10:37:08","endLine":681,"groupId":"21074","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testFetchSnapshotResponseFromNewerEpochNotLeader","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/61/fb5b9c16eb437d2e5815374fd19888d218e834.src","preCode":"    public void testFetchSnapshotResponseFromNewerEpochNotLeader() throws Exception {\n        int localId = 0;\n        int firstLeaderId = localId + 1;\n        int secondLeaderId = firstLeaderId + 1;\n        Set<Integer> voters = Utils.mkSet(localId, firstLeaderId, secondLeaderId);\n        int epoch = 2;\n        OffsetAndEpoch snapshotId = new OffsetAndEpoch(100L, 1);\n\n        RaftClientTestContext context = new RaftClientTestContext.Builder(localId, voters)\n            .withElectedLeader(epoch, firstLeaderId)\n            .build();\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch, 0L, 0);\n\n        context.deliverResponse(\n            fetchRequest.correlationId,\n            fetchRequest.destinationId(),\n            snapshotFetchResponse(context.metadataPartition, epoch, firstLeaderId, snapshotId, 200L)\n        );\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound snapshotRequest = context.assertSentFetchSnapshotRequest();\n        FetchSnapshotRequestData.PartitionSnapshot request = assertFetchSnapshotRequest(\n                snapshotRequest,\n                context.metadataPartition,\n                localId,\n                Integer.MAX_VALUE\n        ).get();\n        assertEquals(snapshotId.offset, request.snapshotId().endOffset());\n        assertEquals(snapshotId.epoch, request.snapshotId().epoch());\n        assertEquals(0, request.position());\n\n        \r\n        context.deliverResponse(\n            snapshotRequest.correlationId,\n            snapshotRequest.destinationId(),\n            FetchSnapshotResponse.singleton(\n                context.metadataPartition,\n                responsePartitionSnapshot -> {\n                    responsePartitionSnapshot\n                        .currentLeader()\n                        .setLeaderEpoch(epoch + 1)\n                        .setLeaderId(secondLeaderId);\n\n                    return responsePartitionSnapshot\n                        .setErrorCode(Errors.FENCED_LEADER_EPOCH.code());\n                }\n            )\n        );\n\n        context.pollUntilRequest();\n        fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch + 1, 0L, 0);\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/KafkaRaftClientSnapshotTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":626,"status":"B"},{"authorDate":"2020-12-29 10:37:08","commitOrder":1,"curCode":"    public void testFetchSnapshotResponseFromNewerEpochLeader() throws Exception {\n        int localId = 0;\n        int leaderId = localId + 1;\n        Set<Integer> voters = Utils.mkSet(localId, leaderId);\n        int epoch = 2;\n        OffsetAndEpoch snapshotId = new OffsetAndEpoch(100L, 1);\n\n        RaftClientTestContext context = new RaftClientTestContext.Builder(localId, voters)\n            .withElectedLeader(epoch, leaderId)\n            .build();\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch, 0L, 0);\n\n        context.deliverResponse(\n            fetchRequest.correlationId,\n            fetchRequest.destinationId(),\n            snapshotFetchResponse(context.metadataPartition, epoch, leaderId, snapshotId, 200L)\n        );\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound snapshotRequest = context.assertSentFetchSnapshotRequest();\n        FetchSnapshotRequestData.PartitionSnapshot request = assertFetchSnapshotRequest(\n                snapshotRequest,\n                context.metadataPartition,\n                localId,\n                Integer.MAX_VALUE\n        ).get();\n        assertEquals(snapshotId.offset, request.snapshotId().endOffset());\n        assertEquals(snapshotId.epoch, request.snapshotId().epoch());\n        assertEquals(0, request.position());\n\n        \r\n        context.deliverResponse(\n            snapshotRequest.correlationId,\n            snapshotRequest.destinationId(),\n            FetchSnapshotResponse.singleton(\n                context.metadataPartition,\n                responsePartitionSnapshot -> {\n                    responsePartitionSnapshot\n                        .currentLeader()\n                        .setLeaderEpoch(epoch + 1)\n                        .setLeaderId(leaderId);\n\n                    return responsePartitionSnapshot\n                        .setErrorCode(Errors.FENCED_LEADER_EPOCH.code());\n                }\n            )\n        );\n\n        context.pollUntilRequest();\n        fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch + 1, 0L, 0);\n    }\n","date":"2020-12-29 10:37:08","endLine":738,"groupId":"21074","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testFetchSnapshotResponseFromNewerEpochLeader","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/61/fb5b9c16eb437d2e5815374fd19888d218e834.src","preCode":"    public void testFetchSnapshotResponseFromNewerEpochLeader() throws Exception {\n        int localId = 0;\n        int leaderId = localId + 1;\n        Set<Integer> voters = Utils.mkSet(localId, leaderId);\n        int epoch = 2;\n        OffsetAndEpoch snapshotId = new OffsetAndEpoch(100L, 1);\n\n        RaftClientTestContext context = new RaftClientTestContext.Builder(localId, voters)\n            .withElectedLeader(epoch, leaderId)\n            .build();\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch, 0L, 0);\n\n        context.deliverResponse(\n            fetchRequest.correlationId,\n            fetchRequest.destinationId(),\n            snapshotFetchResponse(context.metadataPartition, epoch, leaderId, snapshotId, 200L)\n        );\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound snapshotRequest = context.assertSentFetchSnapshotRequest();\n        FetchSnapshotRequestData.PartitionSnapshot request = assertFetchSnapshotRequest(\n                snapshotRequest,\n                context.metadataPartition,\n                localId,\n                Integer.MAX_VALUE\n        ).get();\n        assertEquals(snapshotId.offset, request.snapshotId().endOffset());\n        assertEquals(snapshotId.epoch, request.snapshotId().epoch());\n        assertEquals(0, request.position());\n\n        \r\n        context.deliverResponse(\n            snapshotRequest.correlationId,\n            snapshotRequest.destinationId(),\n            FetchSnapshotResponse.singleton(\n                context.metadataPartition,\n                responsePartitionSnapshot -> {\n                    responsePartitionSnapshot\n                        .currentLeader()\n                        .setLeaderEpoch(epoch + 1)\n                        .setLeaderId(leaderId);\n\n                    return responsePartitionSnapshot\n                        .setErrorCode(Errors.FENCED_LEADER_EPOCH.code());\n                }\n            )\n        );\n\n        context.pollUntilRequest();\n        fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch + 1, 0L, 0);\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/KafkaRaftClientSnapshotTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":684,"status":"B"}],"commitId":"2023aed59d863278a6302e03066d387f994f085c","commitMessage":"@@@KAFKA-10427:  Fetch snapshot API (#9553)\n\nImplements the code necessary for the leader to response to fetch snapshot requests and for the follower to fetch snapshots. This API is described in more detail in KIP-630: https://cwiki.apache.org/confluence/display/KAFKA/KIP-630%3A+Kafka+Raft+Snapshot.  More specifically.  this patch includes the following changes:\n\nLeader Changes:\n1. Raft leader response to FetchSnapshot request by reading the local snapshot and sending the requested bytes in the response. This implementation currently copies the bytes to memory. This will be fixed in a future PR.\n\nFollower Changes:\n1. Raft followers will start fetching snapshot if the leader sends a Fetch response that includes a SnapshotId.\n\n2. Raft followers send FetchSnapshot requests if there is a pending download. The same timer is used for both Fetch and FetchSnapshot requests.\n\n3. Raft follower handle FetchSnapshot responses by comping the bytes to the pending SnapshotWriter. This implementation doesn't fix the replicated log after the snapshot has been downloaded. This will be implemented in a future PR.\n\nReviewers: Jason Gustafson <jason@confluent.io>","date":"2020-12-29 10:37:08","modifiedFileCount":"17","status":"B","submitter":"Jos? Armando Garc?a Sancio"},{"authorTime":"2021-07-08 07:02:37","codes":[{"authorDate":"2021-07-08 07:02:37","commitOrder":2,"curCode":"    public void testFetchSnapshotResponseFromNewerEpochNotLeader() throws Exception {\n        int localId = 0;\n        int firstLeaderId = localId + 1;\n        int secondLeaderId = firstLeaderId + 1;\n        Set<Integer> voters = Utils.mkSet(localId, firstLeaderId, secondLeaderId);\n        int epoch = 2;\n        OffsetAndEpoch snapshotId = new OffsetAndEpoch(100L, 1);\n\n        RaftClientTestContext context = new RaftClientTestContext.Builder(localId, voters)\n            .withElectedLeader(epoch, firstLeaderId)\n            .build();\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch, 0L, 0);\n\n        context.deliverResponse(\n            fetchRequest.correlationId,\n            fetchRequest.destinationId(),\n            snapshotFetchResponse(context.metadataPartition, context.metadataTopicId, epoch, firstLeaderId, snapshotId, 200L)\n        );\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound snapshotRequest = context.assertSentFetchSnapshotRequest();\n        FetchSnapshotRequestData.PartitionSnapshot request = assertFetchSnapshotRequest(\n                snapshotRequest,\n                context.metadataPartition,\n                localId,\n                Integer.MAX_VALUE\n        ).get();\n        assertEquals(snapshotId.offset, request.snapshotId().endOffset());\n        assertEquals(snapshotId.epoch, request.snapshotId().epoch());\n        assertEquals(0, request.position());\n\n        \r\n        context.deliverResponse(\n            snapshotRequest.correlationId,\n            snapshotRequest.destinationId(),\n            FetchSnapshotResponse.singleton(\n                context.metadataPartition,\n                responsePartitionSnapshot -> {\n                    responsePartitionSnapshot\n                        .currentLeader()\n                        .setLeaderEpoch(epoch + 1)\n                        .setLeaderId(secondLeaderId);\n\n                    return responsePartitionSnapshot\n                        .setErrorCode(Errors.FENCED_LEADER_EPOCH.code());\n                }\n            )\n        );\n\n        context.pollUntilRequest();\n        fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch + 1, 0L, 0);\n    }\n","date":"2021-07-08 07:02:37","endLine":1166,"groupId":"104507","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testFetchSnapshotResponseFromNewerEpochNotLeader","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f7/7103110603ba598fd7297ffbe3bad5f12abb1d.src","preCode":"    public void testFetchSnapshotResponseFromNewerEpochNotLeader() throws Exception {\n        int localId = 0;\n        int firstLeaderId = localId + 1;\n        int secondLeaderId = firstLeaderId + 1;\n        Set<Integer> voters = Utils.mkSet(localId, firstLeaderId, secondLeaderId);\n        int epoch = 2;\n        OffsetAndEpoch snapshotId = new OffsetAndEpoch(100L, 1);\n\n        RaftClientTestContext context = new RaftClientTestContext.Builder(localId, voters)\n            .withElectedLeader(epoch, firstLeaderId)\n            .build();\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch, 0L, 0);\n\n        context.deliverResponse(\n            fetchRequest.correlationId,\n            fetchRequest.destinationId(),\n            snapshotFetchResponse(context.metadataPartition, epoch, firstLeaderId, snapshotId, 200L)\n        );\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound snapshotRequest = context.assertSentFetchSnapshotRequest();\n        FetchSnapshotRequestData.PartitionSnapshot request = assertFetchSnapshotRequest(\n                snapshotRequest,\n                context.metadataPartition,\n                localId,\n                Integer.MAX_VALUE\n        ).get();\n        assertEquals(snapshotId.offset, request.snapshotId().endOffset());\n        assertEquals(snapshotId.epoch, request.snapshotId().epoch());\n        assertEquals(0, request.position());\n\n        \r\n        context.deliverResponse(\n            snapshotRequest.correlationId,\n            snapshotRequest.destinationId(),\n            FetchSnapshotResponse.singleton(\n                context.metadataPartition,\n                responsePartitionSnapshot -> {\n                    responsePartitionSnapshot\n                        .currentLeader()\n                        .setLeaderEpoch(epoch + 1)\n                        .setLeaderId(secondLeaderId);\n\n                    return responsePartitionSnapshot\n                        .setErrorCode(Errors.FENCED_LEADER_EPOCH.code());\n                }\n            )\n        );\n\n        context.pollUntilRequest();\n        fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch + 1, 0L, 0);\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/KafkaRaftClientSnapshotTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1111,"status":"M"},{"authorDate":"2021-07-08 07:02:37","commitOrder":2,"curCode":"    public void testFetchSnapshotResponseFromNewerEpochLeader() throws Exception {\n        int localId = 0;\n        int leaderId = localId + 1;\n        Set<Integer> voters = Utils.mkSet(localId, leaderId);\n        int epoch = 2;\n        OffsetAndEpoch snapshotId = new OffsetAndEpoch(100L, 1);\n\n        RaftClientTestContext context = new RaftClientTestContext.Builder(localId, voters)\n            .withElectedLeader(epoch, leaderId)\n            .build();\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch, 0L, 0);\n\n        context.deliverResponse(\n            fetchRequest.correlationId,\n            fetchRequest.destinationId(),\n            snapshotFetchResponse(context.metadataPartition, context.metadataTopicId, epoch, leaderId, snapshotId, 200L)\n        );\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound snapshotRequest = context.assertSentFetchSnapshotRequest();\n        FetchSnapshotRequestData.PartitionSnapshot request = assertFetchSnapshotRequest(\n                snapshotRequest,\n                context.metadataPartition,\n                localId,\n                Integer.MAX_VALUE\n        ).get();\n        assertEquals(snapshotId.offset, request.snapshotId().endOffset());\n        assertEquals(snapshotId.epoch, request.snapshotId().epoch());\n        assertEquals(0, request.position());\n\n        \r\n        context.deliverResponse(\n            snapshotRequest.correlationId,\n            snapshotRequest.destinationId(),\n            FetchSnapshotResponse.singleton(\n                context.metadataPartition,\n                responsePartitionSnapshot -> {\n                    responsePartitionSnapshot\n                        .currentLeader()\n                        .setLeaderEpoch(epoch + 1)\n                        .setLeaderId(leaderId);\n\n                    return responsePartitionSnapshot\n                        .setErrorCode(Errors.FENCED_LEADER_EPOCH.code());\n                }\n            )\n        );\n\n        context.pollUntilRequest();\n        fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch + 1, 0L, 0);\n    }\n","date":"2021-07-08 07:02:37","endLine":1223,"groupId":"104507","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testFetchSnapshotResponseFromNewerEpochLeader","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-kafka-10-0.7/blobInfo/CC_OUT/blobs/f7/7103110603ba598fd7297ffbe3bad5f12abb1d.src","preCode":"    public void testFetchSnapshotResponseFromNewerEpochLeader() throws Exception {\n        int localId = 0;\n        int leaderId = localId + 1;\n        Set<Integer> voters = Utils.mkSet(localId, leaderId);\n        int epoch = 2;\n        OffsetAndEpoch snapshotId = new OffsetAndEpoch(100L, 1);\n\n        RaftClientTestContext context = new RaftClientTestContext.Builder(localId, voters)\n            .withElectedLeader(epoch, leaderId)\n            .build();\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch, 0L, 0);\n\n        context.deliverResponse(\n            fetchRequest.correlationId,\n            fetchRequest.destinationId(),\n            snapshotFetchResponse(context.metadataPartition, epoch, leaderId, snapshotId, 200L)\n        );\n\n        context.pollUntilRequest();\n        RaftRequest.Outbound snapshotRequest = context.assertSentFetchSnapshotRequest();\n        FetchSnapshotRequestData.PartitionSnapshot request = assertFetchSnapshotRequest(\n                snapshotRequest,\n                context.metadataPartition,\n                localId,\n                Integer.MAX_VALUE\n        ).get();\n        assertEquals(snapshotId.offset, request.snapshotId().endOffset());\n        assertEquals(snapshotId.epoch, request.snapshotId().epoch());\n        assertEquals(0, request.position());\n\n        \r\n        context.deliverResponse(\n            snapshotRequest.correlationId,\n            snapshotRequest.destinationId(),\n            FetchSnapshotResponse.singleton(\n                context.metadataPartition,\n                responsePartitionSnapshot -> {\n                    responsePartitionSnapshot\n                        .currentLeader()\n                        .setLeaderEpoch(epoch + 1)\n                        .setLeaderId(leaderId);\n\n                    return responsePartitionSnapshot\n                        .setErrorCode(Errors.FENCED_LEADER_EPOCH.code());\n                }\n            )\n        );\n\n        context.pollUntilRequest();\n        fetchRequest = context.assertSentFetchRequest();\n        context.assertFetchRequestData(fetchRequest, epoch + 1, 0L, 0);\n    }\n","realPath":"raft/src/test/java/org/apache/kafka/raft/KafkaRaftClientSnapshotTest.java","repoName":"kafka","snippetEndLine":0,"snippetStartLine":0,"startLine":1169,"status":"M"}],"commitId":"2b8aff58b575c199ee8372e5689420c9d77357a5","commitMessage":"@@@KAFKA-10580: Add topic ID support to Fetch request (#9944)\n\nUpdated FetchRequest and FetchResponse to use topic IDs rather than topic names.\nSome of the complicated code is found in FetchSession and FetchSessionHandler.\nWe need to be able to store topic IDs and maintain a cache on the broker for IDs that may not have been resolved. On incremental fetch requests.  we will try to resolve them or remove them if in toForget.\n\nReviewers: Rajini Sivaram <rajinisivaram@googlemail.com>.  Chia-Ping Tsai <chia7712@gmail.com>.  Jun Rao <junrao@gmail.com>","date":"2021-07-08 07:02:37","modifiedFileCount":"23","status":"M","submitter":"Justine Olshan"}]
