[{"authorTime":"2019-12-20 00:31:28","codes":[{"authorDate":"2019-12-20 00:31:28","commitOrder":1,"curCode":"    public void testProxyStrategyWillOpenNewConnectionsOnDisconnect() throws Exception {\n        try (MockTransportService transport1 = startTransport(\"node1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"node2\", Version.CURRENT)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, addresses(address1, address2))) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    long initialConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                        .filter(n -> n.getAddress().equals(address2))\n                        .count();\n                    assertNotEquals(0, initialConnectionsToTransport2);\n                    assertEquals(numOfConnections, connectionManager.size());\n                    assertTrue(strategy.assertNoRunningConnections());\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        \r\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n                        assertTrue(finalConnectionsToTransport2 > initialConnectionsToTransport2);\n                        assertTrue(strategy.assertNoRunningConnections());\n                    });\n                }\n            }\n        }\n    }\n","date":"2019-12-20 00:31:28","endLine":164,"groupId":"60208","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testProxyStrategyWillOpenNewConnectionsOnDisconnect","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/44ff895725d9dc67f3bba646af5c37de797c2b.src","preCode":"    public void testProxyStrategyWillOpenNewConnectionsOnDisconnect() throws Exception {\n        try (MockTransportService transport1 = startTransport(\"node1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"node2\", Version.CURRENT)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, addresses(address1, address2))) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    long initialConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                        .filter(n -> n.getAddress().equals(address2))\n                        .count();\n                    assertNotEquals(0, initialConnectionsToTransport2);\n                    assertEquals(numOfConnections, connectionManager.size());\n                    assertTrue(strategy.assertNoRunningConnections());\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        \r\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n                        assertTrue(finalConnectionsToTransport2 > initialConnectionsToTransport2);\n                        assertTrue(strategy.assertNoRunningConnections());\n                    });\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/ProxyConnectionStrategyTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"B"},{"authorDate":"2019-12-20 00:31:28","commitOrder":1,"curCode":"    public void testClusterNameValidationPreventConnectingToDifferentClusters() throws Exception {\n        Settings otherSettings = Settings.builder().put(\"cluster.name\", \"otherCluster\").build();\n\n        try (MockTransportService transport1 = startTransport(\"cluster1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"cluster2\", Version.CURRENT, otherSettings)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, addresses(address1, address2))) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    if (connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1))) {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n                    } else {\n                        assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n                    }\n                    assertTrue(strategy.assertNoRunningConnections());\n                }\n            }\n        }\n    }\n","date":"2019-12-20 00:31:28","endLine":276,"groupId":"45742","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testClusterNameValidationPreventConnectingToDifferentClusters","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/44ff895725d9dc67f3bba646af5c37de797c2b.src","preCode":"    public void testClusterNameValidationPreventConnectingToDifferentClusters() throws Exception {\n        Settings otherSettings = Settings.builder().put(\"cluster.name\", \"otherCluster\").build();\n\n        try (MockTransportService transport1 = startTransport(\"cluster1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"cluster2\", Version.CURRENT, otherSettings)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, addresses(address1, address2))) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    if (connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1))) {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n                    } else {\n                        assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n                    }\n                    assertTrue(strategy.assertNoRunningConnections());\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/ProxyConnectionStrategyTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":243,"status":"B"}],"commitId":"342a2920a9659ec9c5a8042ddb1d4b6aef965a71","commitMessage":"@@@Rename the remote connection mode simple to proxy (#50291)\n\nThis commit renames the simple connection mode to the proxy connection\nmode for remote cluster connections. In order to do this.  the mode specific\nsettings which we namespaced by their mode (ex: sniff.seed and\nproxy.addresses) have been reverted.","date":"2019-12-20 00:31:28","modifiedFileCount":"16","status":"B","submitter":"Tim Brooks"},{"authorTime":"2019-12-20 03:22:54","codes":[{"authorDate":"2019-12-20 03:22:54","commitOrder":2,"curCode":"    public void testProxyStrategyWillOpenNewConnectionsOnDisconnect() throws Exception {\n        try (MockTransportService transport1 = startTransport(\"node1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"node2\", Version.CURRENT)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2), false)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    long initialConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                        .filter(n -> n.getAddress().equals(address2))\n                        .count();\n                    assertEquals(0, initialConnectionsToTransport2);\n                    assertEquals(numOfConnections, connectionManager.size());\n                    assertTrue(strategy.assertNoRunningConnections());\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        \r\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n                        assertNotEquals(0, finalConnectionsToTransport2);\n                        assertEquals(numOfConnections, connectionManager.size());\n                        assertTrue(strategy.assertNoRunningConnections());\n                    });\n                }\n            }\n        }\n    }\n","date":"2019-12-20 03:22:54","endLine":158,"groupId":"0","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testProxyStrategyWillOpenNewConnectionsOnDisconnect","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/11/060670553538af2547b62589cf20635ccdea26.src","preCode":"    public void testProxyStrategyWillOpenNewConnectionsOnDisconnect() throws Exception {\n        try (MockTransportService transport1 = startTransport(\"node1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"node2\", Version.CURRENT)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, addresses(address1, address2))) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    long initialConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                        .filter(n -> n.getAddress().equals(address2))\n                        .count();\n                    assertNotEquals(0, initialConnectionsToTransport2);\n                    assertEquals(numOfConnections, connectionManager.size());\n                    assertTrue(strategy.assertNoRunningConnections());\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        \r\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n                        assertTrue(finalConnectionsToTransport2 > initialConnectionsToTransport2);\n                        assertTrue(strategy.assertNoRunningConnections());\n                    });\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/ProxyConnectionStrategyTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"},{"authorDate":"2019-12-20 03:22:54","commitOrder":2,"curCode":"    public void testClusterNameValidationPreventConnectingToDifferentClusters() throws Exception {\n        Settings otherSettings = Settings.builder().put(\"cluster.name\", \"otherCluster\").build();\n\n        try (MockTransportService transport1 = startTransport(\"cluster1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"cluster2\", Version.CURRENT, otherSettings)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                Supplier<TransportAddress> resolver = alternatingResolver(address1, address2);\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), resolver, false)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        assertTrue(strategy.assertNoRunningConnections());\n\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n\n                        \r\n                        assertEquals(0, finalConnectionsToTransport2);\n                        assertEquals(0, connectionManager.size());\n                    });\n                }\n            }\n        }\n    }\n","date":"2019-12-20 03:22:54","endLine":233,"groupId":"0","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testClusterNameValidationPreventConnectingToDifferentClusters","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/11/060670553538af2547b62589cf20635ccdea26.src","preCode":"    public void testClusterNameValidationPreventConnectingToDifferentClusters() throws Exception {\n        Settings otherSettings = Settings.builder().put(\"cluster.name\", \"otherCluster\").build();\n\n        try (MockTransportService transport1 = startTransport(\"cluster1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"cluster2\", Version.CURRENT, otherSettings)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, addresses(address1, address2))) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    if (connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1))) {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n                    } else {\n                        assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n                    }\n                    assertTrue(strategy.assertNoRunningConnections());\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/ProxyConnectionStrategyTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"}],"commitId":"3b8f5d9ea1861a1d6b9e3d435608180fdb669733","commitMessage":"@@@Modify proxy mode to support a single address (#50391)\n\nCurrently.  the remote proxy connection mode uses a list setting for the\nproxy address. This commit modifies this so that the setting is\nproxy_address and only supports a single remote proxy address.","date":"2019-12-20 03:22:54","modifiedFileCount":"4","status":"M","submitter":"Tim Brooks"},{"authorTime":"2020-01-07 01:12:00","codes":[{"authorDate":"2020-01-07 01:12:00","commitOrder":3,"curCode":"    public void testProxyStrategyWillOpenNewConnectionsOnDisconnect() throws Exception {\n        try (MockTransportService transport1 = startTransport(\"node1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"node2\", Version.CURRENT)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2, useAddress1), false)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    long initialConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                        .filter(n -> n.getAddress().equals(address2))\n                        .count();\n                    assertEquals(0, initialConnectionsToTransport2);\n                    assertEquals(numOfConnections, connectionManager.size());\n                    assertTrue(strategy.assertNoRunningConnections());\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        \r\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n                        assertNotEquals(0, finalConnectionsToTransport2);\n                        assertEquals(numOfConnections, connectionManager.size());\n                        assertTrue(strategy.assertNoRunningConnections());\n                    });\n                }\n            }\n        }\n    }\n","date":"2020-01-07 01:12:00","endLine":161,"groupId":"44201","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testProxyStrategyWillOpenNewConnectionsOnDisconnect","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0a/a2c881429453536c0d4603240b7b5b3a08aeb1.src","preCode":"    public void testProxyStrategyWillOpenNewConnectionsOnDisconnect() throws Exception {\n        try (MockTransportService transport1 = startTransport(\"node1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"node2\", Version.CURRENT)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2), false)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    long initialConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                        .filter(n -> n.getAddress().equals(address2))\n                        .count();\n                    assertEquals(0, initialConnectionsToTransport2);\n                    assertEquals(numOfConnections, connectionManager.size());\n                    assertTrue(strategy.assertNoRunningConnections());\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        \r\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n                        assertNotEquals(0, finalConnectionsToTransport2);\n                        assertEquals(numOfConnections, connectionManager.size());\n                        assertTrue(strategy.assertNoRunningConnections());\n                    });\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/ProxyConnectionStrategyTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"},{"authorDate":"2020-01-07 01:12:00","commitOrder":3,"curCode":"    public void testClusterNameValidationPreventConnectingToDifferentClusters() throws Exception {\n        Settings otherSettings = Settings.builder().put(\"cluster.name\", \"otherCluster\").build();\n\n        try (MockTransportService transport1 = startTransport(\"cluster1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"cluster2\", Version.CURRENT, otherSettings)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2, useAddress1), false)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        assertTrue(strategy.assertNoRunningConnections());\n\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n\n                        \r\n                        assertEquals(0, finalConnectionsToTransport2);\n                        assertEquals(0, connectionManager.size());\n                    });\n                }\n            }\n        }\n    }\n","date":"2020-01-07 01:12:00","endLine":238,"groupId":"44206","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testClusterNameValidationPreventConnectingToDifferentClusters","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/0a/a2c881429453536c0d4603240b7b5b3a08aeb1.src","preCode":"    public void testClusterNameValidationPreventConnectingToDifferentClusters() throws Exception {\n        Settings otherSettings = Settings.builder().put(\"cluster.name\", \"otherCluster\").build();\n\n        try (MockTransportService transport1 = startTransport(\"cluster1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"cluster2\", Version.CURRENT, otherSettings)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                Supplier<TransportAddress> resolver = alternatingResolver(address1, address2);\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), resolver, false)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        assertTrue(strategy.assertNoRunningConnections());\n\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n\n                        \r\n                        assertEquals(0, finalConnectionsToTransport2);\n                        assertEquals(0, connectionManager.size());\n                    });\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/ProxyConnectionStrategyTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"M"}],"commitId":"87350a11a611676307035c53c2dd04fee74de92b","commitMessage":"@@@Remove races in ProxyConnectionStrategyTests (#50620)\n\nCurrently.  we use delayed address resolution in the proxy strategy tests\nto allow tests to connect to different addresses. Unfortunately.  this\nhas the potential to introduce races as the address is resolved each\nconnection attempt. The number of connection attempts can vary based on\nwhen connections are opening and closing. This commit modifies the test\nbe allowing them to specifically control which address is used.\n\nRelated to #50618","date":"2020-01-07 01:12:00","modifiedFileCount":"1","status":"M","submitter":"Tim Brooks"},{"authorTime":"2020-01-14 05:07:09","codes":[{"authorDate":"2020-01-14 05:07:09","commitOrder":4,"curCode":"    public void testProxyStrategyWillOpenNewConnectionsOnDisconnect() throws Exception {\n        try (MockTransportService transport1 = startTransport(\"node1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"node2\", Version.CURRENT)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2, useAddress1), null)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    long initialConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                        .filter(n -> n.getAddress().equals(address2))\n                        .count();\n                    assertEquals(0, initialConnectionsToTransport2);\n                    assertEquals(numOfConnections, connectionManager.size());\n                    assertTrue(strategy.assertNoRunningConnections());\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        \r\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n                        assertNotEquals(0, finalConnectionsToTransport2);\n                        assertEquals(numOfConnections, connectionManager.size());\n                        assertTrue(strategy.assertNoRunningConnections());\n                    });\n                }\n            }\n        }\n    }\n","date":"2020-01-14 05:07:09","endLine":161,"groupId":"44201","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testProxyStrategyWillOpenNewConnectionsOnDisconnect","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/46/54918d898f51090e7e1473c0290c7370ed5680.src","preCode":"    public void testProxyStrategyWillOpenNewConnectionsOnDisconnect() throws Exception {\n        try (MockTransportService transport1 = startTransport(\"node1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"node2\", Version.CURRENT)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2, useAddress1), false)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    long initialConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                        .filter(n -> n.getAddress().equals(address2))\n                        .count();\n                    assertEquals(0, initialConnectionsToTransport2);\n                    assertEquals(numOfConnections, connectionManager.size());\n                    assertTrue(strategy.assertNoRunningConnections());\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        \r\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n                        assertNotEquals(0, finalConnectionsToTransport2);\n                        assertEquals(numOfConnections, connectionManager.size());\n                        assertTrue(strategy.assertNoRunningConnections());\n                    });\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/ProxyConnectionStrategyTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"},{"authorDate":"2020-01-14 05:07:09","commitOrder":4,"curCode":"    public void testClusterNameValidationPreventConnectingToDifferentClusters() throws Exception {\n        Settings otherSettings = Settings.builder().put(\"cluster.name\", \"otherCluster\").build();\n\n        try (MockTransportService transport1 = startTransport(\"cluster1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"cluster2\", Version.CURRENT, otherSettings)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2, useAddress1), null)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        assertTrue(strategy.assertNoRunningConnections());\n\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n\n                        \r\n                        assertEquals(0, finalConnectionsToTransport2);\n                        assertEquals(0, connectionManager.size());\n                    });\n                }\n            }\n        }\n    }\n","date":"2020-01-14 05:07:09","endLine":238,"groupId":"44206","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testClusterNameValidationPreventConnectingToDifferentClusters","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/46/54918d898f51090e7e1473c0290c7370ed5680.src","preCode":"    public void testClusterNameValidationPreventConnectingToDifferentClusters() throws Exception {\n        Settings otherSettings = Settings.builder().put(\"cluster.name\", \"otherCluster\").build();\n\n        try (MockTransportService transport1 = startTransport(\"cluster1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"cluster2\", Version.CURRENT, otherSettings)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2, useAddress1), false)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        assertTrue(strategy.assertNoRunningConnections());\n\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n\n                        \r\n                        assertEquals(0, finalConnectionsToTransport2);\n                        assertEquals(0, connectionManager.size());\n                    });\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/ProxyConnectionStrategyTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"M"}],"commitId":"d1deeaeb74cb8ce5b00b3d2a31919585e2e14ed5","commitMessage":"@@@Allow proxy mode server name to be configured (#50774)\n\nCurrently.  proxy mode allows a remote cluster connection to be setup by\nexpecting all open connections to be routed through an intermediate\nproxy. The proxy must use some logic to ensure that the connections end\nup on the correct remote cluster. One mechanism provided is that the\ndefault distribution TLS implementations will forward the host component\nof the configured address to the remote connection using the SNI\nextension. This is limiting as it requires that the proxy be configured\nin a way that always uses a valid hostname as the proxy address.\n\nInstead.  this commit adds an additional setting to allow the server_name\nto be configured independently. This allows the proxy address to be\nspecified as a IP literal.  but the server_name specified as an arbitrary\nstring which still must be a valid hostname. It also decouples the\nserver_name from the requirement of being a DNS resolvable domain.","date":"2020-01-14 05:07:09","modifiedFileCount":"6","status":"M","submitter":"Tim Brooks"},{"authorTime":"2020-02-01 00:43:25","codes":[{"authorDate":"2020-02-01 00:43:25","commitOrder":5,"curCode":"    public void testProxyStrategyWillOpenNewConnectionsOnDisconnect() throws Exception {\n        try (MockTransportService transport1 = startTransport(\"node1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"node2\", Version.CURRENT)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ClusterConnectionManager connectionManager = new ClusterConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2, useAddress1), null)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    long initialConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                        .filter(n -> n.getAddress().equals(address2))\n                        .count();\n                    assertEquals(0, initialConnectionsToTransport2);\n                    assertEquals(numOfConnections, connectionManager.size());\n                    assertTrue(strategy.assertNoRunningConnections());\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        \r\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n                        assertNotEquals(0, finalConnectionsToTransport2);\n                        assertEquals(numOfConnections, connectionManager.size());\n                        assertTrue(strategy.assertNoRunningConnections());\n                    });\n                }\n            }\n        }\n    }\n","date":"2020-02-01 00:43:25","endLine":161,"groupId":"44201","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testProxyStrategyWillOpenNewConnectionsOnDisconnect","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/47/ba6b17205d155f0f4a28f06c3f5b59a79c8e38.src","preCode":"    public void testProxyStrategyWillOpenNewConnectionsOnDisconnect() throws Exception {\n        try (MockTransportService transport1 = startTransport(\"node1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"node2\", Version.CURRENT)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2, useAddress1), null)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    long initialConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                        .filter(n -> n.getAddress().equals(address2))\n                        .count();\n                    assertEquals(0, initialConnectionsToTransport2);\n                    assertEquals(numOfConnections, connectionManager.size());\n                    assertTrue(strategy.assertNoRunningConnections());\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        \r\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n                        assertNotEquals(0, finalConnectionsToTransport2);\n                        assertEquals(numOfConnections, connectionManager.size());\n                        assertTrue(strategy.assertNoRunningConnections());\n                    });\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/ProxyConnectionStrategyTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"},{"authorDate":"2020-02-01 00:43:25","commitOrder":5,"curCode":"    public void testClusterNameValidationPreventConnectingToDifferentClusters() throws Exception {\n        Settings otherSettings = Settings.builder().put(\"cluster.name\", \"otherCluster\").build();\n\n        try (MockTransportService transport1 = startTransport(\"cluster1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"cluster2\", Version.CURRENT, otherSettings)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ClusterConnectionManager connectionManager = new ClusterConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2, useAddress1), null)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        assertTrue(strategy.assertNoRunningConnections());\n\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n\n                        \r\n                        assertEquals(0, finalConnectionsToTransport2);\n                        assertEquals(0, connectionManager.size());\n                    });\n                }\n            }\n        }\n    }\n","date":"2020-02-01 00:43:25","endLine":238,"groupId":"44206","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testClusterNameValidationPreventConnectingToDifferentClusters","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/47/ba6b17205d155f0f4a28f06c3f5b59a79c8e38.src","preCode":"    public void testClusterNameValidationPreventConnectingToDifferentClusters() throws Exception {\n        Settings otherSettings = Settings.builder().put(\"cluster.name\", \"otherCluster\").build();\n\n        try (MockTransportService transport1 = startTransport(\"cluster1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"cluster2\", Version.CURRENT, otherSettings)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ConnectionManager connectionManager = new ConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2, useAddress1), null)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        assertTrue(strategy.assertNoRunningConnections());\n\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n\n                        \r\n                        assertEquals(0, finalConnectionsToTransport2);\n                        assertEquals(0, connectionManager.size());\n                    });\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/ProxyConnectionStrategyTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"M"}],"commitId":"9dbd9ba757f63441c990e9812dfd3129498a5f18","commitMessage":"@@@Extract a ConnectionManager interface (#51722)\n\nCurrently we have three different implementations representing a\n`ConnectionManager`. There is the basic `ConnectionManager` which\nholds all connections for a cluster. And a remote connection manager\nwhich support proxy behavior. And a stubbable connection manager for\ntests. The remote and stubbable instances use the delegate pattern. \nso this commit extracts an interface for them all to implement.","date":"2020-02-01 00:43:25","modifiedFileCount":"15","status":"M","submitter":"Tim Brooks"},{"authorTime":"2020-04-17 12:10:56","codes":[{"authorDate":"2020-04-17 12:10:56","commitOrder":6,"curCode":"    public void testProxyStrategyWillOpenNewConnectionsOnDisconnect() throws Exception {\n        try (MockTransportService transport1 = startTransport(\"node1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"node2\", Version.CURRENT)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ClusterConnectionManager connectionManager = new ClusterConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         Settings.EMPTY, numOfConnections, address1.toString(),\n                         alternatingResolver(address1, address2, useAddress1), null)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    long initialConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                        .filter(n -> n.getAddress().equals(address2))\n                        .count();\n                    assertEquals(0, initialConnectionsToTransport2);\n                    assertEquals(numOfConnections, connectionManager.size());\n                    assertTrue(strategy.assertNoRunningConnections());\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        \r\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n                        assertNotEquals(0, finalConnectionsToTransport2);\n                        assertEquals(numOfConnections, connectionManager.size());\n                        assertTrue(strategy.assertNoRunningConnections());\n                    });\n                }\n            }\n        }\n    }\n","date":"2020-04-17 12:10:56","endLine":162,"groupId":"104415","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testProxyStrategyWillOpenNewConnectionsOnDisconnect","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/cd/ed690ea7e9c0ebd192ec6ba2acbd408634af62.src","preCode":"    public void testProxyStrategyWillOpenNewConnectionsOnDisconnect() throws Exception {\n        try (MockTransportService transport1 = startTransport(\"node1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"node2\", Version.CURRENT)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ClusterConnectionManager connectionManager = new ClusterConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2, useAddress1), null)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    long initialConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                        .filter(n -> n.getAddress().equals(address2))\n                        .count();\n                    assertEquals(0, initialConnectionsToTransport2);\n                    assertEquals(numOfConnections, connectionManager.size());\n                    assertTrue(strategy.assertNoRunningConnections());\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        \r\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n                        assertNotEquals(0, finalConnectionsToTransport2);\n                        assertEquals(numOfConnections, connectionManager.size());\n                        assertTrue(strategy.assertNoRunningConnections());\n                    });\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/ProxyConnectionStrategyTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"},{"authorDate":"2020-04-17 12:10:56","commitOrder":6,"curCode":"    public void testClusterNameValidationPreventConnectingToDifferentClusters() throws Exception {\n        Settings otherSettings = Settings.builder().put(\"cluster.name\", \"otherCluster\").build();\n\n        try (MockTransportService transport1 = startTransport(\"cluster1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"cluster2\", Version.CURRENT, otherSettings)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ClusterConnectionManager connectionManager = new ClusterConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         Settings.EMPTY, numOfConnections, address1.toString(),\n                         alternatingResolver(address1, address2, useAddress1), null)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        assertTrue(strategy.assertNoRunningConnections());\n\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n\n                        \r\n                        assertEquals(0, finalConnectionsToTransport2);\n                        assertEquals(0, connectionManager.size());\n                    });\n                }\n            }\n        }\n    }\n","date":"2020-04-17 12:10:56","endLine":240,"groupId":"104415","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testClusterNameValidationPreventConnectingToDifferentClusters","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/cd/ed690ea7e9c0ebd192ec6ba2acbd408634af62.src","preCode":"    public void testClusterNameValidationPreventConnectingToDifferentClusters() throws Exception {\n        Settings otherSettings = Settings.builder().put(\"cluster.name\", \"otherCluster\").build();\n\n        try (MockTransportService transport1 = startTransport(\"cluster1\", Version.CURRENT);\n             MockTransportService transport2 = startTransport(\"cluster2\", Version.CURRENT, otherSettings)) {\n            TransportAddress address1 = transport1.boundAddress().publishAddress();\n            TransportAddress address2 = transport2.boundAddress().publishAddress();\n\n            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {\n                localService.start();\n                localService.acceptIncomingRequests();\n\n                ClusterConnectionManager connectionManager = new ClusterConnectionManager(profile, localService.transport);\n                int numOfConnections = randomIntBetween(4, 8);\n\n                AtomicBoolean useAddress1 = new AtomicBoolean(true);\n\n                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);\n                     ProxyConnectionStrategy strategy = new ProxyConnectionStrategy(clusterAlias, localService, remoteConnectionManager,\n                         numOfConnections, address1.toString(), alternatingResolver(address1, address2, useAddress1), null)) {\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n\n                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();\n                    strategy.connect(connectFuture);\n                    connectFuture.actionGet();\n\n                    assertTrue(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                    assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address2)));\n                    useAddress1.set(false);\n\n                    transport1.close();\n\n                    assertBusy(() -> {\n                        assertFalse(connectionManager.getAllConnectedNodes().stream().anyMatch(n -> n.getAddress().equals(address1)));\n                        assertTrue(strategy.assertNoRunningConnections());\n\n                        long finalConnectionsToTransport2 = connectionManager.getAllConnectedNodes().stream()\n                            .filter(n -> n.getAddress().equals(address2))\n                            .count();\n\n                        \r\n                        assertEquals(0, finalConnectionsToTransport2);\n                        assertEquals(0, connectionManager.size());\n                    });\n                }\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/ProxyConnectionStrategyTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":191,"status":"M"}],"commitId":"5216bd273a70dd8d801d4c925b85c60d5ceadf7a","commitMessage":"@@@Retry follow task when remote connection queue full (#55314)\n\nIf more than 100 shard-follow tasks are trying to connect to the remote \ncluster.  then some of them will abort with \"connect listener queue is \nfull\". This is because we retry on ESRejectedExecutionException.  but not\non RejectedExecutionException.","date":"2020-04-17 12:10:56","modifiedFileCount":"10","status":"M","submitter":"Nhat Nguyen"}]
