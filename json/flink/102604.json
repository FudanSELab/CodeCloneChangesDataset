[{"authorTime":"2015-10-20 23:04:21","codes":[{"authorDate":"2015-10-20 23:04:21","commitOrder":1,"curCode":"\tpublic void testSlidingEventTimeWindows() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\t\tfinal int WINDOW_SLIDE = 1;\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tSlidingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS), Time.of(WINDOW_SLIDE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\twindowBufferFactory,\n\t\t\t\tnew ReduceWindowFunction<String, TimeWindow, Tuple2<String, Integer>>(new SumReducer()),\n\t\t\t\tEventTimeTrigger.create());\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t\tif (windowBufferFactory instanceof PreAggregatingHeapWindowBuffer.Factory) {\n\t\t\tAssert.assertEquals(\"Close was not called.\", 2, closeCalled.get());\n\t\t} else {\n\t\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t\t}\n\t}\n","date":"2015-10-21 17:01:43","endLine":158,"groupId":"22030","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b9/4e53018dfd946628360b018e8c47d4a959ee71.src","preCode":"\tpublic void testSlidingEventTimeWindows() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\t\tfinal int WINDOW_SLIDE = 1;\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tSlidingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS), Time.of(WINDOW_SLIDE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\twindowBufferFactory,\n\t\t\t\tnew ReduceWindowFunction<String, TimeWindow, Tuple2<String, Integer>>(new SumReducer()),\n\t\t\t\tEventTimeTrigger.create());\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t\tif (windowBufferFactory instanceof PreAggregatingHeapWindowBuffer.Factory) {\n\t\t\tAssert.assertEquals(\"Close was not called.\", 2, closeCalled.get());\n\t\t} else {\n\t\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"B"},{"authorDate":"2015-10-20 23:04:21","commitOrder":1,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\twindowBufferFactory,\n\t\t\t\tnew ReduceWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)));\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t\tif (windowBufferFactory instanceof PreAggregatingHeapWindowBuffer.Factory) {\n\t\t\tAssert.assertEquals(\"Close was not called.\", 2, closeCalled.get());\n\t\t} else {\n\t\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t\t}\n\t}\n","date":"2015-10-21 17:01:43","endLine":330,"groupId":"38906","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b9/4e53018dfd946628360b018e8c47d4a959ee71.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\twindowBufferFactory,\n\t\t\t\tnew ReduceWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)));\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t\tif (windowBufferFactory instanceof PreAggregatingHeapWindowBuffer.Factory) {\n\t\t\tAssert.assertEquals(\"Close was not called.\", 2, closeCalled.get());\n\t\t} else {\n\t\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":247,"status":"B"}],"commitId":"06f6ac5d3edbc8dd20baf6e1b30900c189a68876","commitMessage":"@@@[FLINK-2877] Move Streaming API out of Staging package\n","date":"2015-10-21 17:01:43","modifiedFileCount":"0","status":"B","submitter":"Rufus Refactor"},{"authorTime":"2016-01-25 19:34:05","codes":[{"authorDate":"2016-01-25 19:34:05","commitOrder":2,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tlong initialTime = 0L;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\t}\n","date":"2016-02-04 03:27:51","endLine":121,"groupId":"22030","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9d/4a41a0b0da37dacc98dc27f7ec5f5419d1ed7a.src","preCode":"\tpublic void testSlidingEventTimeWindows() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\t\tfinal int WINDOW_SLIDE = 1;\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tSlidingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS), Time.of(WINDOW_SLIDE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\twindowBufferFactory,\n\t\t\t\tnew ReduceWindowFunction<String, TimeWindow, Tuple2<String, Integer>>(new SumReducer()),\n\t\t\t\tEventTimeTrigger.create());\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t\tif (windowBufferFactory instanceof PreAggregatingHeapWindowBuffer.Factory) {\n\t\t\tAssert.assertEquals(\"Close was not called.\", 2, closeCalled.get());\n\t\t} else {\n\t\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":61,"status":"M"},{"authorDate":"2016-01-25 19:34:05","commitOrder":2,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew ReduceWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)));\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-02-04 03:27:51","endLine":416,"groupId":"38906","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9d/4a41a0b0da37dacc98dc27f7ec5f5419d1ed7a.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\twindowBufferFactory,\n\t\t\t\tnew ReduceWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)));\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t\tif (windowBufferFactory instanceof PreAggregatingHeapWindowBuffer.Factory) {\n\t\t\tAssert.assertEquals(\"Close was not called.\", 2, closeCalled.get());\n\t\t} else {\n\t\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":330,"status":"M"}],"commitId":"67ca4a436daf8de1a6e0329b4b30342e77d26087","commitMessage":"@@@[FLINK-3200] Use Partitioned State in WindowOperator\n\nThis changes window operator to use the new partitioned state\nabstraction for keeping window contents instead of custom internal\nstate and the checkpointed interface.\n\nFor now.  timers are still kept as custom checkpointed state.  however.\n\nWindowOperator now expects a StateIdentifier for MergingState.  this can\neither be for ReducingState or ListState but WindowOperator is agnostic\nto the type of State. Also the signature of WindowFunction is changed to\ninclude the type of intermediate input. For example.  if a ReducingState\nis used the input of the WindowFunction is T (where T is the input\ntype). If using a ListState the input of the WindowFunction would be of\ntype Iterable[T].\n","date":"2016-02-04 03:27:51","modifiedFileCount":"40","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-02-08 21:56:19","codes":[{"authorDate":"2016-01-25 19:34:05","commitOrder":3,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tlong initialTime = 0L;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\t}\n","date":"2016-02-04 03:27:51","endLine":121,"groupId":"22030","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9d/4a41a0b0da37dacc98dc27f7ec5f5419d1ed7a.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tlong initialTime = 0L;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":61,"status":"N"},{"authorDate":"2016-02-08 21:56:19","commitOrder":3,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)));\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-02-13 01:51:01","endLine":416,"groupId":"38906","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c1/111a08753e44524512049d02dc42cfbee6660f.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew ReduceWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)));\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":330,"status":"M"}],"commitId":"94cba8998c726092e2cc80fd022ca40bf0c38ec2","commitMessage":"@@@[FLINK-2991] Add Folding State and use in WindowOperator\n\nThis enables efficient incremental aggregation of fold window.\n\nThis also adds:\n- WindowedStream.apply(initVal.  foldFunction.  windowFunction)\n- AllWindowedStream.apply(initVal.  foldFunction.  windowFunction)\n\nThis closes #1605\n","date":"2016-02-13 01:51:01","modifiedFileCount":"17","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-02-26 22:19:50","codes":[{"authorDate":"2016-01-25 19:34:05","commitOrder":4,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tlong initialTime = 0L;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\t}\n","date":"2016-02-04 03:27:51","endLine":121,"groupId":"22030","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9d/4a41a0b0da37dacc98dc27f7ec5f5419d1ed7a.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tlong initialTime = 0L;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":61,"status":"N"},{"authorDate":"2016-02-26 22:19:50","commitOrder":4,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)));\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-02-27 07:07:05","endLine":418,"groupId":"38906","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/a1/f08ad019b26bbf2d0e47384beb4d8cee521b0f.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)));\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":332,"status":"M"}],"commitId":"27b5c49e76f58992fd5575959a7dea7088505e12","commitMessage":"@@@[FLINK-3521] Make Iterable part of method signature for WindowFunction\n\nThis closes #1723\n","date":"2016-02-27 07:07:05","modifiedFileCount":"32","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2015-12-16 00:37:48","codes":[{"authorDate":"2015-12-16 00:37:48","commitOrder":5,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tlong initialTime = 0L;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","date":"2016-04-05 23:18:58","endLine":135,"groupId":"22030","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/64/2a16b20765b2c396b1849e6d8485555d9b602e.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tlong initialTime = 0L;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"M"},{"authorDate":"2015-12-16 00:37:48","commitOrder":5,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)));\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-04-05 23:18:58","endLine":718,"groupId":"38906","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/64/2a16b20765b2c396b1849e6d8485555d9b602e.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)));\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":632,"status":"M"}],"commitId":"6cd8ceb10c841827cf89b74ecf5a0495a6933d53","commitMessage":"@@@[FLINK-3174] Add MergingWindowAssigner and SessionWindows\n\nThis introduces MergingWindowAssigner.  an extension of WindowAssigner\nthat can merge windows. When using a MergingWindowAssigner the\nWindowOperator eagerly merges windows when processing elements.\n\nFor keeping track of in-flight windows and for merging windows this adds\nMergingWindowSet.  this keeps track of windows per key.\n\nOnly when using a MergingWindowAssigners is the more costly merging\nlogic used in the WindowOperator.\n\nFor triggers there is a new method Trigger.onMerge() that notifies the\ntrigger of the new merged window. This allows the trigger to set a timer\nfor the newly merged window. Only triggers that return true\nfrom Trigger.canMerge() can be used with MergingWindowAssigner. Trigger\nhas default implementations for canMerge() and onMerge().  we return\nfalse and onMerge() throws an Exception.\n\nThis also adds AbstractStateBackend.mergePartitionedStates for merging\nstate of several source namespaces into a target namespace. This is only\npossible for the newly introduced MergingState which is an extension of\nAppendingState. Only ReducingState and ListState are MergingState while\nFoldingState is now an AppendingState.\n\nThis enables proper support for session windows.\n\nThis also adds the EventTimeSessionWindows and ProcessingTimeSessionWindows\nwindow assigners and adapts an existing session example and adds test cases.\n","date":"2016-04-05 23:18:58","modifiedFileCount":"21","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2015-12-16 00:37:48","codes":[{"authorDate":"2016-04-12 22:27:18","commitOrder":6,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tlong initialTime = 0L;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamTaskState snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot, 10L);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","date":"2016-04-25 16:18:40","endLine":142,"groupId":"30032","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/23/3131d256c2145d35984e959c9dba432d2e2348.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tlong initialTime = 0L;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"M"},{"authorDate":"2015-12-16 00:37:48","commitOrder":6,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)));\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-04-05 23:18:58","endLine":718,"groupId":"38906","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/64/2a16b20765b2c396b1849e6d8485555d9b602e.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)));\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":632,"status":"N"}],"commitId":"f2f5bd5bed2f737b8418be09359691e899462184","commitMessage":"@@@[FLINK-3740] Make Session Window State Checkpointed\n","date":"2016-04-25 16:18:40","modifiedFileCount":"5","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-05-31 23:13:58","codes":[{"authorDate":"2016-04-12 22:27:18","commitOrder":7,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tlong initialTime = 0L;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamTaskState snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot, 10L);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","date":"2016-04-25 16:18:40","endLine":142,"groupId":"30032","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/23/3131d256c2145d35984e959c9dba432d2e2348.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tlong initialTime = 0L;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamTaskState snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot, 10L);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"N"},{"authorDate":"2016-05-31 23:13:58","commitOrder":7,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-06-21 18:14:06","endLine":780,"groupId":"38906","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/dd/f4dcc5f59645a1fabd0acc28fc85697b013e7d.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)));\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":691,"status":"M"}],"commitId":"34a8b03d2ad40db7dc00fa47923b96374c289838","commitMessage":"@@@[FLINK-3714] Add Support for \"Allowed Lateness\"\n\nHandle late elements and take care\nof cleaning the window state.\n","date":"2016-06-21 18:14:06","modifiedFileCount":"16","status":"M","submitter":"kl0u"},{"authorTime":"2016-06-20 22:44:44","codes":[{"authorDate":"2016-06-20 22:44:44","commitOrder":8,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamTaskState snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot, 10L);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","date":"2016-06-21 18:16:59","endLine":143,"groupId":"41333","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9a/af683720fca42a5ba5ac38c6f1111493aeeb43.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tlong initialTime = 0L;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), initialTime + 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamTaskState snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot, 10L);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), initialTime + 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), initialTime + 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6999));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":78,"status":"M"},{"authorDate":"2016-06-20 22:44:44","commitOrder":8,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\t\t\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-06-21 18:16:59","endLine":773,"groupId":"23141","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9a/af683720fca42a5ba5ac38c6f1111493aeeb43.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 7000));\n\t\ttestHarness.processWatermark(new Watermark(initialTime + 8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":685,"status":"M"}],"commitId":"09e28109b3707f23230ea50526b7db8aa166df15","commitMessage":"@@@[hotfix] Remove \"initialTime\" in WindowOperatorTest\n\nI added this once with the though of varying the start time for window\ntests but it just makes stuff harder to parse for now.\n","date":"2016-06-21 18:16:59","modifiedFileCount":"1","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-06-20 22:44:44","codes":[{"authorDate":"2016-08-11 17:59:07","commitOrder":9,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamStateHandle snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","date":"2016-09-01 01:10:01","endLine":156,"groupId":"32599","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/a6e1ebc3ba383fc9be914da7b9f88d1041f245.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamTaskState snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot, 10L);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":91,"status":"M"},{"authorDate":"2016-06-20 22:44:44","commitOrder":9,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\t\t\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-06-21 18:16:59","endLine":773,"groupId":"23141","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9a/af683720fca42a5ba5ac38c6f1111493aeeb43.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\t\t\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":685,"status":"N"}],"commitId":"847ead01f2f0aaf318b2b1ba8501bc697d245900","commitMessage":"@@@[FLINK-4381] Refactor State to Prepare For Key-Group State Backends\n","date":"2016-09-01 01:10:01","modifiedFileCount":"99","status":"M","submitter":"Stefan Richter"},{"authorTime":"2016-08-11 00:44:50","codes":[{"authorDate":"2016-08-11 17:59:07","commitOrder":10,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamStateHandle snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","date":"2016-09-01 01:10:01","endLine":156,"groupId":"32599","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/a6e1ebc3ba383fc9be914da7b9f88d1041f245.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamStateHandle snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":91,"status":"N"},{"authorDate":"2016-08-11 00:44:50","commitOrder":10,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-09-01 01:10:01","endLine":771,"groupId":"23141","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/67/a6f556796c5e88af3f93de8d4445e42b02169d.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\t\t\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":685,"status":"M"}],"commitId":"4809f5367b08a9734fc1bd4875be51a9f3bb65aa","commitMessage":"@@@[FLINK-3761] Refactor State Backends/Make Keyed State Key-Group Aware\n\nThe biggest change in this is that functionality that used to be in\nAbstractStateBackend is now moved to CheckpointStreamFactory and\nKeyedStateBackend. The former is responsible for providing streams that\ncan be used to checkpoint data while the latter is responsible for\nkeeping keyed state. A keyed backend can checkpoint the state that it\nkeeps by using a CheckpointStreamFactory.\n\nThis also refactors how asynchronous keyed state snapshots work. They\nare not implemented using a Future/RunnableFuture.\n\nAlso.  this changes the keyed state backends to be key-group aware and to\nsnapshot the state in key-groups with an index for restoring.\n","date":"2016-09-01 01:10:01","modifiedFileCount":"100","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-10-05 05:49:54","codes":[{"authorDate":"2016-08-11 17:59:07","commitOrder":11,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamStateHandle snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","date":"2016-09-01 01:10:01","endLine":156,"groupId":"32599","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/a6e1ebc3ba383fc9be914da7b9f88d1041f245.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamStateHandle snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":91,"status":"N"},{"authorDate":"2016-10-05 05:49:54","commitOrder":11,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-06 02:04:34","endLine":753,"groupId":"23141","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/a6524b4be41e76bc2250e273e2598685f8f6ee.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":669,"status":"M"}],"commitId":"1cd8d4f418a707790c091fed2428627eae9da423","commitMessage":"@@@[hotfix] [streaming api] Remove obsolete and unused InputTypeSerializer from WindowOperator\n","date":"2016-10-06 02:04:34","modifiedFileCount":"4","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2016-10-05 05:49:54","codes":[{"authorDate":"2016-10-04 16:59:38","commitOrder":12,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamStateHandle snapshot = testHarness.snapshotLegacy(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","date":"2016-10-20 22:14:21","endLine":157,"groupId":"32599","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2b/0b915da9b3c016ae713819df98d3b5f69bf86f.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamStateHandle snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":92,"status":"M"},{"authorDate":"2016-10-05 05:49:54","commitOrder":12,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-06 02:04:34","endLine":753,"groupId":"23141","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/a6524b4be41e76bc2250e273e2598685f8f6ee.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":669,"status":"N"}],"commitId":"cab9cd44eca83ef8cbcd2a2d070d8c79cb037977","commitMessage":"@@@[FLINK-4844] Partitionable Raw Keyed/Operator State\n","date":"2016-10-20 22:14:21","modifiedFileCount":"87","status":"M","submitter":"Stefan Richter"},{"authorTime":"2016-10-05 05:49:54","codes":[{"authorDate":"2016-10-21 02:26:24","commitOrder":13,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tOperatorStateHandles snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","date":"2016-10-27 05:26:28","endLine":157,"groupId":"7832","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2a/132942d369ee684821c2ab50c56bc03de19d49.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tStreamStateHandle snapshot = testHarness.snapshotLegacy(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.restore(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":92,"status":"M"},{"authorDate":"2016-10-05 05:49:54","commitOrder":13,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-06 02:04:34","endLine":753,"groupId":"23141","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/a6524b4be41e76bc2250e273e2598685f8f6ee.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":669,"status":"N"}],"commitId":"c0192ecad161ce85c07e448537027ac619ca2d14","commitMessage":"@@@[FLINK-4892] Snapshot TimerService using Key-Grouped State\n\nThis also removes StreamCheckpointedOperator from AbstractStreamOperator\nwhich was added as an interim solution for snapshotting the timers.\n","date":"2016-10-27 05:26:28","modifiedFileCount":"16","status":"M","submitter":"kl0u"},{"authorTime":"2017-01-13 22:17:09","codes":[{"authorDate":"2016-10-21 02:26:24","commitOrder":14,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tOperatorStateHandles snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","date":"2016-10-27 05:26:28","endLine":157,"groupId":"7832","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2a/132942d369ee684821c2ab50c56bc03de19d49.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tOperatorStateHandles snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":92,"status":"N"},{"authorDate":"2017-01-13 22:17:09","commitOrder":14,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-01-23 04:53:39","endLine":825,"groupId":"23141","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2f/aa506e95bc097a8c6bad4fa787b3a2cdd9b91d.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":741,"status":"M"}],"commitId":"3b97128f05bacfb80afe4a2a49741c31ff306cd2","commitMessage":"@@@[FLINK-5590] [runtime] Add proper internal state hierarchy\n\nThis introduces an internal state hierarchy that mirrors the external state hierarchy. \nbut gives the runtime access to methods that should not be part of the user facing API. \nsuch as:\n  - setting namespaces\n  - accessing raw values\n  - merging namespaces\n","date":"2017-01-23 04:53:39","modifiedFileCount":"38","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2017-03-01 22:36:17","codes":[{"authorDate":"2016-10-21 02:26:24","commitOrder":15,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tOperatorStateHandles snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","date":"2016-10-27 05:26:28","endLine":157,"groupId":"7832","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2a/132942d369ee684821c2ab50c56bc03de19d49.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tOperatorStateHandles snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":92,"status":"N"},{"authorDate":"2017-03-01 22:36:17","commitOrder":15,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-03-18 14:44:17","endLine":985,"groupId":"23141","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b3/8cb2e5ab2d2a952536d4a8fcb6d0fb155beb81.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":900,"status":"M"}],"commitId":"07a15d0e1647c79ae010ca6df5b1830a4087dd56","commitMessage":"@@@[FLINK-4460] Provide late-data output for window operations\n\nWe use side outputs to emit dropped late data.\n","date":"2017-03-18 14:44:17","modifiedFileCount":"8","status":"M","submitter":"Chen Qin"},{"authorTime":"2017-05-17 20:01:04","codes":[{"authorDate":"2016-10-21 02:26:24","commitOrder":16,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tOperatorStateHandles snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","date":"2016-10-27 05:26:28","endLine":157,"groupId":"7832","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperatorTestHarness<Tuple2<String@Integer>@Tuple2<String@Integer>>testHarness)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2a/132942d369ee684821c2ab50c56bc03de19d49.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tOperatorStateHandles snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":92,"status":"N"},{"authorDate":"2017-05-17 20:01:04","commitOrder":16,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int windowSize = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-05-23 04:22:24","endLine":944,"groupId":"23141","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/42/c6c6f9aeb78646d1c634a18d5b21eaf608a346.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n \t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":862,"status":"M"}],"commitId":"12b4185c6c09101b64e12a84c33dc4d28f95cff9","commitMessage":"@@@[FLINK-6603] [streaming] Enable checkstyle on test sources\n\nUpdates / reverts the import order by sections:\n- org.apache.flink.*\n- all other imports\n- javax.*\n- java.*\n- static imports\n\nAdds EmptyLineSeparator to enforce an extra newline (not enforced\nbetween field or local variable declarations).\n\nThis closes #3941\n","date":"2017-05-23 04:22:24","modifiedFileCount":"395","status":"M","submitter":"Greg Hogan"},{"authorTime":"2017-12-20 19:27:56","codes":[{"authorDate":"2017-12-20 19:27:56","commitOrder":17,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator) throws Exception {\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.setup();\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tOperatorStateHandles snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\n\t\texpectedOutput.clear();\n\t\ttestHarness = createTestHarness(operator);\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-01-06 12:30:12","endLine":175,"groupId":"39635","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperator<Tuple2<String@Integer>@Tuple2<String@Integer>>operator)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c0/3207e7f1634926b7c5327931ad5fb6f82d91d2.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness) throws Exception {\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tOperatorStateHandles snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":102,"status":"M"},{"authorDate":"2017-12-20 19:27:56","commitOrder":17,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int windowSize = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tcreateTestHarness(operator);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-01-06 12:30:12","endLine":967,"groupId":"23141","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c0/3207e7f1634926b7c5327931ad5fb6f82d91d2.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int windowSize = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":885,"status":"M"}],"commitId":"091a37052b7045b3ed28c68bfea109024a5d1871","commitMessage":"@@@[FLINK-8298][tests] Properly shutdown MockEnvironment to release resources\n\nThis closes #5193.\n","date":"2018-01-06 12:30:12","modifiedFileCount":"9","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2017-12-20 19:27:56","codes":[{"authorDate":"2018-02-23 17:36:09","commitOrder":18,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator) throws Exception {\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.setup();\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tOperatorSubtaskState snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\n\t\texpectedOutput.clear();\n\t\ttestHarness = createTestHarness(operator);\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-02-25 22:10:28","endLine":181,"groupId":"37562","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperator<Tuple2<String@Integer>@Tuple2<String@Integer>>operator)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/69/264808dbe43c1dfa5ed97618ebb8e0debe21ec.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator) throws Exception {\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.setup();\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tOperatorStateHandles snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\n\t\texpectedOutput.clear();\n\t\ttestHarness = createTestHarness(operator);\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":108,"status":"M"},{"authorDate":"2017-12-20 19:27:56","commitOrder":18,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int windowSize = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tcreateTestHarness(operator);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-01-06 12:30:12","endLine":967,"groupId":"23141","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c0/3207e7f1634926b7c5327931ad5fb6f82d91d2.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int windowSize = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tcreateTestHarness(operator);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":885,"status":"N"}],"commitId":"617e67c2f540b62b97ca5198b6a5c42b89b6f392","commitMessage":"@@@[hotfix] Remove outdated class OperatorStateHandles and replace it with OperatorSubtaskState\n","date":"2018-02-25 22:10:28","modifiedFileCount":"34","status":"M","submitter":"Stefan Richter"},{"authorTime":"2018-05-04 23:15:51","codes":[{"authorDate":"2018-02-23 17:36:09","commitOrder":19,"curCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator) throws Exception {\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.setup();\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tOperatorSubtaskState snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\n\t\texpectedOutput.clear();\n\t\ttestHarness = createTestHarness(operator);\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-02-25 22:10:28","endLine":181,"groupId":"102604","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"testSlidingEventTimeWindows","params":"(OneInputStreamOperator<Tuple2<String@Integer>@Tuple2<String@Integer>>operator)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/69/264808dbe43c1dfa5ed97618ebb8e0debe21ec.src","preCode":"\tprivate void testSlidingEventTimeWindows(OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator) throws Exception {\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.setup();\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\t\ttestHarness.processWatermark(new Watermark(999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 999));\n\t\texpectedOutput.add(new Watermark(999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 1999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 1999));\n\t\texpectedOutput.add(new Watermark(1999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new Watermark(2999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\tOperatorSubtaskState snapshot = testHarness.snapshot(0L, 0L);\n\t\ttestHarness.close();\n\n\t\texpectedOutput.clear();\n\t\ttestHarness = createTestHarness(operator);\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(snapshot);\n\t\ttestHarness.open();\n\n\t\ttestHarness.processWatermark(new Watermark(3999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), 3999));\n\t\texpectedOutput.add(new Watermark(3999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 4999));\n\t\texpectedOutput.add(new Watermark(4999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), 5999));\n\t\texpectedOutput.add(new Watermark(5999));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(6999));\n\t\ttestHarness.processWatermark(new Watermark(7999));\n\t\texpectedOutput.add(new Watermark(6999));\n\t\texpectedOutput.add(new Watermark(7999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":108,"status":"N"},{"authorDate":"2018-05-04 23:15:51","commitOrder":19,"curCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int windowSize = 3;\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tSTRING_INT_TUPLE.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tcreateTestHarness(operator);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-05-05 00:48:16","endLine":944,"groupId":"102604","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"testContinuousWatermarkTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4c/28e4057503dad900453e1a33a86d3f5303b660.src","preCode":"\tpublic void testContinuousWatermarkTrigger() throws Exception {\n\t\tcloseCalled.set(0);\n\n\t\tfinal int windowSize = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new WindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>()),\n\t\t\t\tContinuousEventTimeTrigger.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tcreateTestHarness(operator);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 0));\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\n\t\ttestHarness.processWatermark(new Watermark(1000));\n\t\texpectedOutput.add(new Watermark(1000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\texpectedOutput.add(new Watermark(2000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(3000));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(3000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(4000));\n\t\texpectedOutput.add(new Watermark(4000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\t\texpectedOutput.add(new Watermark(5000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processWatermark(new Watermark(6000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), Long.MAX_VALUE));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 5), Long.MAX_VALUE));\n\t\texpectedOutput.add(new Watermark(6000));\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\t\r\n\t\ttestHarness.processWatermark(new Watermark(7000));\n\t\ttestHarness.processWatermark(new Watermark(8000));\n\t\texpectedOutput.add(new Watermark(7000));\n\t\texpectedOutput.add(new Watermark(8000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":864,"status":"M"}],"commitId":"c8fa8d025684c2225824c54a7285bbfdec7cfddc","commitMessage":"@@@[FLINK-9292] [core] Remove TypeInfoParser (part 1)\n","date":"2018-05-05 00:48:16","modifiedFileCount":"26","status":"M","submitter":"Stephan Ewen"}]
