[{"authorTime":"2019-02-02 05:54:46","codes":[{"authorDate":"2019-02-02 05:54:46","commitOrder":1,"curCode":"  public void testBloomFilterAgg() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"BLOOM_FILTER(dim1, 1000)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    BloomKFilter expected1 = new BloomKFilter(TEST_NUM_ENTRIES);\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      String raw = NullHandling.emptyToNullIfNeeded((String) row.getRaw(\"dim1\"));\n      if (raw == null) {\n        expected1.addBytes(null, 0, 0);\n      } else {\n        expected1.addString(raw);\n      }\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            jsonMapper.writeValueAsString(expected1)\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                    new BloomFilterAggregatorFactory(\n                        \"a0:agg\",\n                        new DefaultDimensionSpec(\"dim1\", \"a0:dim1\"),\n                        TEST_NUM_ENTRIES\n                    )\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2019-02-02 05:54:46","endLine":271,"groupId":"7216","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testBloomFilterAgg","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/46/41e274899753ae5b4ad11044191af49f5c20f6.src","preCode":"  public void testBloomFilterAgg() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"BLOOM_FILTER(dim1, 1000)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    BloomKFilter expected1 = new BloomKFilter(TEST_NUM_ENTRIES);\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      String raw = NullHandling.emptyToNullIfNeeded((String) row.getRaw(\"dim1\"));\n      if (raw == null) {\n        expected1.addBytes(null, 0, 0);\n      } else {\n        expected1.addString(raw);\n      }\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            jsonMapper.writeValueAsString(expected1)\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                    new BloomFilterAggregatorFactory(\n                        \"a0:agg\",\n                        new DefaultDimensionSpec(\"dim1\", \"a0:dim1\"),\n                        TEST_NUM_ENTRIES\n                    )\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/druid-bloom-filter/src/test/java/org/apache/druid/query/aggregation/bloom/sql/BloomFilterSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":223,"status":"B"},{"authorDate":"2019-02-02 05:54:46","commitOrder":1,"curCode":"  public void testBloomFilterAggExtractionFn() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"BLOOM_FILTER(SUBSTRING(dim1, 1, 1), 1000)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    BloomKFilter expected1 = new BloomKFilter(TEST_NUM_ENTRIES);\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      String raw = NullHandling.emptyToNullIfNeeded((String) row.getRaw(\"dim1\"));\n      \r\n      if (raw == null || \"\".equals(raw)) {\n        expected1.addBytes(null, 0, 0);\n      } else {\n        expected1.addString(raw.substring(0, 1));\n      }\n    }\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            jsonMapper.writeValueAsString(expected1)\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                      new BloomFilterAggregatorFactory(\n                          \"a0:agg\",\n                          new ExtractionDimensionSpec(\n                              \"dim1\",\n                              \"a0:dim1\",\n                              new SubstringDimExtractionFn(0, 1)\n                          ),\n                          TEST_NUM_ENTRIES\n                      )\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2019-02-02 05:54:46","endLine":397,"groupId":"7217","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testBloomFilterAggExtractionFn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/46/41e274899753ae5b4ad11044191af49f5c20f6.src","preCode":"  public void testBloomFilterAggExtractionFn() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"BLOOM_FILTER(SUBSTRING(dim1, 1, 1), 1000)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    BloomKFilter expected1 = new BloomKFilter(TEST_NUM_ENTRIES);\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      String raw = NullHandling.emptyToNullIfNeeded((String) row.getRaw(\"dim1\"));\n      \r\n      if (raw == null || \"\".equals(raw)) {\n        expected1.addBytes(null, 0, 0);\n      } else {\n        expected1.addString(raw.substring(0, 1));\n      }\n    }\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            jsonMapper.writeValueAsString(expected1)\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                      new BloomFilterAggregatorFactory(\n                          \"a0:agg\",\n                          new ExtractionDimensionSpec(\n                              \"dim1\",\n                              \"a0:dim1\",\n                              new SubstringDimExtractionFn(0, 1)\n                          ),\n                          TEST_NUM_ENTRIES\n                      )\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/druid-bloom-filter/src/test/java/org/apache/druid/query/aggregation/bloom/sql/BloomFilterSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":345,"status":"B"}],"commitId":"7a5827e12eb65eef80e08fe86ef76604019d6af8","commitMessage":"@@@bloom filter sql aggregator (#6950)\n\n* adds sql aggregator for bloom filter.  adds complex value serde for sql results\n\n* fix tests\n\n* checkstyle\n\n* fix copy-paste\n","date":"2019-02-02 05:54:46","modifiedFileCount":"7","status":"B","submitter":"Clint Wylie"},{"authorTime":"2020-02-20 05:09:20","codes":[{"authorDate":"2020-02-20 05:09:20","commitOrder":2,"curCode":"  public void testBloomFilterAgg() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"BLOOM_FILTER(dim1, 1000)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            authenticationResult\n        ).toList();\n\n    BloomKFilter expected1 = new BloomKFilter(TEST_NUM_ENTRIES);\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      String raw = NullHandling.emptyToNullIfNeeded((String) row.getRaw(\"dim1\"));\n      if (raw == null) {\n        expected1.addBytes(null, 0, 0);\n      } else {\n        expected1.addString(raw);\n      }\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            jsonMapper.writeValueAsString(expected1)\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                    new BloomFilterAggregatorFactory(\n                        \"a0:agg\",\n                        new DefaultDimensionSpec(\"dim1\", \"a0:dim1\"),\n                        TEST_NUM_ENTRIES\n                    )\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2020-02-20 05:09:20","endLine":278,"groupId":"7216","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testBloomFilterAgg","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/1e/875f2f01262f928013dcba3621847da7024ab4.src","preCode":"  public void testBloomFilterAgg() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"BLOOM_FILTER(dim1, 1000)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    BloomKFilter expected1 = new BloomKFilter(TEST_NUM_ENTRIES);\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      String raw = NullHandling.emptyToNullIfNeeded((String) row.getRaw(\"dim1\"));\n      if (raw == null) {\n        expected1.addBytes(null, 0, 0);\n      } else {\n        expected1.addString(raw);\n      }\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            jsonMapper.writeValueAsString(expected1)\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                    new BloomFilterAggregatorFactory(\n                        \"a0:agg\",\n                        new DefaultDimensionSpec(\"dim1\", \"a0:dim1\"),\n                        TEST_NUM_ENTRIES\n                    )\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/druid-bloom-filter/src/test/java/org/apache/druid/query/aggregation/bloom/sql/BloomFilterSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":225,"status":"M"},{"authorDate":"2020-02-20 05:09:20","commitOrder":2,"curCode":"  public void testBloomFilterAggExtractionFn() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"BLOOM_FILTER(SUBSTRING(dim1, 1, 1), 1000)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            authenticationResult\n        ).toList();\n\n    BloomKFilter expected1 = new BloomKFilter(TEST_NUM_ENTRIES);\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      String raw = NullHandling.emptyToNullIfNeeded((String) row.getRaw(\"dim1\"));\n      \r\n      if (raw == null || \"\".equals(raw)) {\n        expected1.addBytes(null, 0, 0);\n      } else {\n        expected1.addString(raw.substring(0, 1));\n      }\n    }\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            jsonMapper.writeValueAsString(expected1)\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                      new BloomFilterAggregatorFactory(\n                          \"a0:agg\",\n                          new ExtractionDimensionSpec(\n                              \"dim1\",\n                              \"a0:dim1\",\n                              new SubstringDimExtractionFn(0, 1)\n                          ),\n                          TEST_NUM_ENTRIES\n                      )\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2020-02-20 05:09:20","endLine":414,"groupId":"7217","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testBloomFilterAggExtractionFn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/1e/875f2f01262f928013dcba3621847da7024ab4.src","preCode":"  public void testBloomFilterAggExtractionFn() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"BLOOM_FILTER(SUBSTRING(dim1, 1, 1), 1000)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    BloomKFilter expected1 = new BloomKFilter(TEST_NUM_ENTRIES);\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      String raw = NullHandling.emptyToNullIfNeeded((String) row.getRaw(\"dim1\"));\n      \r\n      if (raw == null || \"\".equals(raw)) {\n        expected1.addBytes(null, 0, 0);\n      } else {\n        expected1.addString(raw.substring(0, 1));\n      }\n    }\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            jsonMapper.writeValueAsString(expected1)\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                      new BloomFilterAggregatorFactory(\n                          \"a0:agg\",\n                          new ExtractionDimensionSpec(\n                              \"dim1\",\n                              \"a0:dim1\",\n                              new SubstringDimExtractionFn(0, 1)\n                          ),\n                          TEST_NUM_ENTRIES\n                      )\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/druid-bloom-filter/src/test/java/org/apache/druid/query/aggregation/bloom/sql/BloomFilterSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":357,"status":"M"}],"commitId":"b408a6d774e43e574bf8092584fae76d582cfd8f","commitMessage":"@@@sql support for dynamic parameters (#6974)\n\n* sql support for dynamic parameters\n\n* fixup\n\n* javadocs\n\n* fixup from merge\n\n* formatting\n\n* fixes\n\n* fix it\n\n* doc fix\n\n* remove druid fallback self-join parameterized test\n\n* unused imports\n\n* ignore test for now\n\n* fix imports\n\n* fixup\n\n* fix merge\n\n* merge fixup\n\n* fix test that cannot vectorize\n\n* fixup and more better\n\n* dependency thingo\n\n* fix docs\n\n* tweaks\n\n* fix docs\n\n* spelling\n\n* unused imports after merge\n\n* review stuffs\n\n* add comment\n\n* add ignore text\n\n* review stuffs\n","date":"2020-02-20 05:09:20","modifiedFileCount":"32","status":"M","submitter":"Clint Wylie"},{"authorTime":"2021-05-11 01:13:37","codes":[{"authorDate":"2021-05-11 01:13:37","commitOrder":3,"curCode":"  public void testBloomFilterAgg() throws Exception\n  {\n    cannotVectorize();\n\n    BloomKFilter expected1 = new BloomKFilter(TEST_NUM_ENTRIES);\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      String raw = NullHandling.emptyToNullIfNeeded((String) row.getRaw(\"dim1\"));\n      if (raw == null) {\n        expected1.addBytes(null, 0, 0);\n      } else {\n        expected1.addString(raw);\n      }\n    }\n\n    testQuery(\n        \"SELECT\\n\"\n        + \"BLOOM_FILTER(dim1, 1000)\\n\"\n        + \"FROM numfoo\",\n        ImmutableList.of(\n            Druids.newTimeseriesQueryBuilder()\n                  .dataSource(CalciteTests.DATASOURCE3)\n                  .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                  .granularity(Granularities.ALL)\n                  .aggregators(\n                      ImmutableList.of(\n                          new BloomFilterAggregatorFactory(\n                              \"a0:agg\",\n                              new DefaultDimensionSpec(\"dim1\", \"a0:dim1\"),\n                              TEST_NUM_ENTRIES\n                          )\n                      )\n                  )\n                  .context(BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT)\n                  .build()\n        ),\n        ImmutableList.of(\n            new Object[]{CalciteTests.getJsonMapper().writeValueAsString(expected1)}\n        )\n    );\n  }\n","date":"2021-05-11 01:13:37","endLine":173,"groupId":"103261","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testBloomFilterAgg","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ef/fb87d23ed258b984fab4f17f784f5e4e25351f.src","preCode":"  public void testBloomFilterAgg() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"BLOOM_FILTER(dim1, 1000)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            authenticationResult\n        ).toList();\n\n    BloomKFilter expected1 = new BloomKFilter(TEST_NUM_ENTRIES);\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      String raw = NullHandling.emptyToNullIfNeeded((String) row.getRaw(\"dim1\"));\n      if (raw == null) {\n        expected1.addBytes(null, 0, 0);\n      } else {\n        expected1.addString(raw);\n      }\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            jsonMapper.writeValueAsString(expected1)\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                      new BloomFilterAggregatorFactory(\n                          \"a0:agg\",\n                          new DefaultDimensionSpec(\"dim1\", \"a0:dim1\"),\n                          TEST_NUM_ENTRIES\n                      )\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/druid-bloom-filter/src/test/java/org/apache/druid/query/aggregation/bloom/sql/BloomFilterSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":134,"status":"M"},{"authorDate":"2021-05-11 01:13:37","commitOrder":3,"curCode":"  public void testBloomFilterAggExtractionFn() throws Exception\n  {\n    cannotVectorize();\n\n    BloomKFilter expected1 = new BloomKFilter(TEST_NUM_ENTRIES);\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      String raw = NullHandling.emptyToNullIfNeeded((String) row.getRaw(\"dim1\"));\n      \r\n      if (raw == null || \"\".equals(raw)) {\n        expected1.addBytes(null, 0, 0);\n      } else {\n        expected1.addString(raw.substring(0, 1));\n      }\n    }\n\n    testQuery(\n        \"SELECT\\n\"\n        + \"BLOOM_FILTER(SUBSTRING(dim1, 1, 1), 1000)\\n\"\n        + \"FROM numfoo\",\n        ImmutableList.of(\n            Druids.newTimeseriesQueryBuilder()\n                  .dataSource(CalciteTests.DATASOURCE3)\n                  .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                  .granularity(Granularities.ALL)\n                  .aggregators(\n                      ImmutableList.of(\n                          new BloomFilterAggregatorFactory(\n                              \"a0:agg\",\n                              new ExtractionDimensionSpec(\n                                  \"dim1\",\n                                  \"a0:dim1\",\n                                  new SubstringDimExtractionFn(0, 1)\n                              ),\n                              TEST_NUM_ENTRIES\n                          )\n                      )\n                  )\n                  .context(BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT)\n                  .build()\n        ),\n        ImmutableList.of(\n            new Object[]{CalciteTests.getJsonMapper().writeValueAsString(expected1)}\n        )\n    );\n\n  }\n","date":"2021-05-11 01:13:37","endLine":284,"groupId":"103261","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testBloomFilterAggExtractionFn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ef/fb87d23ed258b984fab4f17f784f5e4e25351f.src","preCode":"  public void testBloomFilterAggExtractionFn() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"BLOOM_FILTER(SUBSTRING(dim1, 1, 1), 1000)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            authenticationResult\n        ).toList();\n\n    BloomKFilter expected1 = new BloomKFilter(TEST_NUM_ENTRIES);\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      String raw = NullHandling.emptyToNullIfNeeded((String) row.getRaw(\"dim1\"));\n      \r\n      if (raw == null || \"\".equals(raw)) {\n        expected1.addBytes(null, 0, 0);\n      } else {\n        expected1.addString(raw.substring(0, 1));\n      }\n    }\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            jsonMapper.writeValueAsString(expected1)\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                      new BloomFilterAggregatorFactory(\n                          \"a0:agg\",\n                          new ExtractionDimensionSpec(\n                              \"dim1\",\n                              \"a0:dim1\",\n                              new SubstringDimExtractionFn(0, 1)\n                          ),\n                          TEST_NUM_ENTRIES\n                      )\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/druid-bloom-filter/src/test/java/org/apache/druid/query/aggregation/bloom/sql/BloomFilterSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"}],"commitId":"691d7a1d548909951468005348a603380f4d6d74","commitMessage":"@@@SQL timeseries no longer skip empty buckets with all granularity (#11188)\n\n* SQL timeseries no longer skip empty buckets with all granularity\n\n* add comment.  fix tests\n\n* the ol switcheroo\n\n* revert unintended change\n\n* docs and more tests\n\n* style\n\n* make checkstyle happy\n\n* docs fixes and more tests\n\n* add docs.  tests for array_agg\n\n* fixes\n\n* oops\n\n* doc stuffs\n\n* fix compile.  match doc style","date":"2021-05-11 01:13:37","modifiedFileCount":"16","status":"M","submitter":"Clint Wylie"}]
