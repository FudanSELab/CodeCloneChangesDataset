[{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp > 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","date":"2019-03-21 07:25:05","endLine":284,"groupId":"338","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"notEq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6a/f5b2131c4c2af675dda90c4192ebe9c3c73b8a.src","preCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp > 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"B"},{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(field.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","date":"2019-03-21 07:25:05","endLine":174,"groupId":"1311","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"lt","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/81/e77561bc12186830a9bb1c74185d854bef70e8.src","preCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(field.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":159,"status":"B"}],"commitId":"c20927801a369104e5ea510470e1cf7c8e28b808","commitMessage":"@@@Rename packages to org.apache.iceberg (#138)\n\n* Move all packages by directory (but don't change references)\n* Rename all references from com.netflix.iceberg to org.apache.iceberg\n* Reorganize all imports due to new package name.\n  Previous commit only did a string find-replace.  which made all the imports out of order. Use an IDE to auto-sort all imports.\n\n","date":"2019-03-21 07:25:05","modifiedFileCount":"0","status":"B","submitter":"mccheah"},{"authorTime":"2019-05-29 03:40:04","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":2,"curCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp > 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","date":"2019-03-21 07:25:05","endLine":284,"groupId":"338","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"notEq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6a/f5b2131c4c2af675dda90c4192ebe9c3c73b8a.src","preCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp > 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"N"},{"authorDate":"2019-05-29 03:40:04","commitOrder":2,"curCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(ref.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","date":"2019-05-29 03:40:04","endLine":166,"groupId":"3603","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"lt","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/64/d34e9bfc06fc52c24dc82ce920f125bf86a8a0.src","preCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(field.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"}],"commitId":"81f29e2f80cc2e6b3b6f715573893aff696f579a","commitMessage":"@@@Support filtering based on nested struct fields (#123)\n\n","date":"2019-05-29 03:40:04","modifiedFileCount":"9","status":"M","submitter":"Gautam"},{"authorTime":"2019-08-27 01:23:12","codes":[{"authorDate":"2019-08-27 01:23:12","commitOrder":3,"curCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (containsNullsOnly(id)) {\n        return ROWS_MUST_MATCH;\n      }\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp > 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","date":"2019-08-27 01:23:12","endLine":306,"groupId":"338","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"notEq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/17/ef0b15b502c55a73b39e56f0d53130b823abd1.src","preCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp > 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":277,"status":"M"},{"authorDate":"2019-08-27 01:23:12","commitOrder":3,"curCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n\n      if (containsNullsOnly(id)) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(ref.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","date":"2019-08-27 01:23:12","endLine":168,"groupId":"3603","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"lt","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/d9/0544081af96abc6c396fd94bbfebbbb37dd138.src","preCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(ref.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":151,"status":"M"}],"commitId":"e7197a7e9cda676ddce402a258ca6e3ebfb2dcad","commitMessage":"@@@Use null counts in metrics evaluators (#412)\n\n","date":"2019-08-27 01:23:12","modifiedFileCount":"4","status":"M","submitter":"Anton Okolnychyi"},{"authorTime":"2021-01-21 01:03:55","codes":[{"authorDate":"2021-01-21 01:03:55","commitOrder":4,"curCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (containsNullsOnly(id) || containsNaNsOnly(id)) {\n        return ROWS_MUST_MATCH;\n      }\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        if (NaNUtil.isNaN(lower)) {\n          \r\n          return ROWS_MIGHT_NOT_MATCH;\n        }\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp > 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","date":"2021-01-21 01:03:55","endLine":351,"groupId":"101512","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"notEq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6e/a293a0b562bf42d7874b3ada59687787c298ea.src","preCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (containsNullsOnly(id)) {\n        return ROWS_MUST_MATCH;\n      }\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp > 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":317,"status":"M"},{"authorDate":"2021-01-21 01:03:55","commitOrder":4,"curCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n\n      if (containsNullsOnly(id) || containsNaNsOnly(id)) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(ref.type(), lowerBounds.get(id));\n\n        if (NaNUtil.isNaN(lower)) {\n          \r\n          return ROWS_MIGHT_MATCH;\n        }\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","date":"2021-01-21 01:03:55","endLine":212,"groupId":"101512","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"lt","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/a6/c3c65e9830f65feb26b679888b8b1ba0cd4da9.src","preCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n\n      if (containsNullsOnly(id)) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(ref.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"M"}],"commitId":"b018e21a814808c70990c3d1f29a998d6036aa90","commitMessage":"@@@API: Handle NaN lower or upper bound in stats evaluators (#2069)\n\n","date":"2021-01-21 01:03:55","modifiedFileCount":"2","status":"M","submitter":"yyanyy"}]
