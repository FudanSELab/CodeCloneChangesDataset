[{"authorTime":"2021-08-10 09:00:21","codes":[{"authorDate":"2021-06-05 06:46:57","commitOrder":3,"curCode":"  public void testJobSchedulerInitWithFailedSpec() throws Exception {\n    \r\n    File specDir = Files.createTempDir();\n\n    Properties properties = new Properties();\n    properties.setProperty(FLOWSPEC_STORE_DIR_KEY, specDir.getAbsolutePath());\n    FlowCatalog flowCatalog = new FlowCatalog(ConfigUtils.propertiesToConfig(properties));\n    ServiceBasedAppLauncher serviceLauncher = new ServiceBasedAppLauncher(properties, \"GaaSJobSchedulerTest\");\n\n    \r\n    SpecCatalogListener mockListener = Mockito.mock(SpecCatalogListener.class);\n    when(mockListener.getName()).thenReturn(ServiceConfigKeys.GOBBLIN_SERVICE_JOB_SCHEDULER_LISTENER_CLASS);\n    when(mockListener.onAddSpec(any())).thenReturn(new AddSpecResponse(\"\"));\n    flowCatalog.addListener(mockListener);\n\n    serviceLauncher.addService(flowCatalog);\n    serviceLauncher.start();\n\n    FlowSpec flowSpec0 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec0\"),\n        MockedSpecCompiler.UNCOMPILABLE_FLOW);\n    FlowSpec flowSpec1 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec1\"));\n    FlowSpec flowSpec2 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec2\"));\n\n    \r\n    flowCatalog.put(flowSpec0, true);\n    flowCatalog.put(flowSpec1, true);\n    flowCatalog.put(flowSpec2, true);\n\n    Assert.assertEquals(flowCatalog.getSpecs().size(), 3);\n\n    Orchestrator mockOrchestrator = Mockito.mock(Orchestrator.class);\n\n    \r\n    TestGobblinServiceJobScheduler scheduler = new TestGobblinServiceJobScheduler(\"testscheduler\",\n        ConfigFactory.empty(), Optional.of(flowCatalog), null, mockOrchestrator, null);\n\n    SpecCompiler mockCompiler = Mockito.mock(SpecCompiler.class);\n    Mockito.when(mockOrchestrator.getSpecCompiler()).thenReturn(mockCompiler);\n    Mockito.doAnswer((Answer<Void>) a -> {\n      scheduler.isCompilerHealthy = true;\n      return null;\n    }).when(mockCompiler).awaitHealthy();\n\n    scheduler.setActive(true);\n\n    AssertWithBackoff.create().timeoutMs(20000).maxSleepMs(2000).backoffFactor(2)\n        .assertTrue(new Predicate<Void>() {\n          @Override\n          public boolean apply(Void input) {\n            Map<String, Spec> scheduledFlowSpecs = scheduler.scheduledFlowSpecs;\n            if (scheduledFlowSpecs != null && scheduledFlowSpecs.size() == 2) {\n              return scheduler.scheduledFlowSpecs.containsKey(\"spec1\") &&\n                  scheduler.scheduledFlowSpecs.containsKey(\"spec2\");\n            } else {\n              return false;\n            }\n          }\n        }, \"Waiting all flowSpecs to be scheduled\");\n  }\n","date":"2021-06-05 06:46:57","endLine":203,"groupId":"3401","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testJobSchedulerInitWithFailedSpec","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/cc/84632cee177143cc32cbdf22933519b19c91b7.src","preCode":"  public void testJobSchedulerInitWithFailedSpec() throws Exception {\n    \r\n    File specDir = Files.createTempDir();\n\n    Properties properties = new Properties();\n    properties.setProperty(FLOWSPEC_STORE_DIR_KEY, specDir.getAbsolutePath());\n    FlowCatalog flowCatalog = new FlowCatalog(ConfigUtils.propertiesToConfig(properties));\n    ServiceBasedAppLauncher serviceLauncher = new ServiceBasedAppLauncher(properties, \"GaaSJobSchedulerTest\");\n\n    \r\n    SpecCatalogListener mockListener = Mockito.mock(SpecCatalogListener.class);\n    when(mockListener.getName()).thenReturn(ServiceConfigKeys.GOBBLIN_SERVICE_JOB_SCHEDULER_LISTENER_CLASS);\n    when(mockListener.onAddSpec(any())).thenReturn(new AddSpecResponse(\"\"));\n    flowCatalog.addListener(mockListener);\n\n    serviceLauncher.addService(flowCatalog);\n    serviceLauncher.start();\n\n    FlowSpec flowSpec0 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec0\"),\n        MockedSpecCompiler.UNCOMPILABLE_FLOW);\n    FlowSpec flowSpec1 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec1\"));\n    FlowSpec flowSpec2 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec2\"));\n\n    \r\n    flowCatalog.put(flowSpec0, true);\n    flowCatalog.put(flowSpec1, true);\n    flowCatalog.put(flowSpec2, true);\n\n    Assert.assertEquals(flowCatalog.getSpecs().size(), 3);\n\n    Orchestrator mockOrchestrator = Mockito.mock(Orchestrator.class);\n\n    \r\n    TestGobblinServiceJobScheduler scheduler = new TestGobblinServiceJobScheduler(\"testscheduler\",\n        ConfigFactory.empty(), Optional.of(flowCatalog), null, mockOrchestrator, null);\n\n    SpecCompiler mockCompiler = Mockito.mock(SpecCompiler.class);\n    Mockito.when(mockOrchestrator.getSpecCompiler()).thenReturn(mockCompiler);\n    Mockito.doAnswer((Answer<Void>) a -> {\n      scheduler.isCompilerHealthy = true;\n      return null;\n    }).when(mockCompiler).awaitHealthy();\n\n    scheduler.setActive(true);\n\n    AssertWithBackoff.create().timeoutMs(20000).maxSleepMs(2000).backoffFactor(2)\n        .assertTrue(new Predicate<Void>() {\n          @Override\n          public boolean apply(Void input) {\n            Map<String, Spec> scheduledFlowSpecs = scheduler.scheduledFlowSpecs;\n            if (scheduledFlowSpecs != null && scheduledFlowSpecs.size() == 2) {\n              return scheduler.scheduledFlowSpecs.containsKey(\"spec1\") &&\n                  scheduler.scheduledFlowSpecs.containsKey(\"spec2\");\n            } else {\n              return false;\n            }\n          }\n        }, \"Waiting all flowSpecs to be scheduled\");\n  }\n","realPath":"gobblin-service/src/test/java/org/apache/gobblin/service/modules/scheduler/GobblinServiceJobSchedulerTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":145,"status":"NB"},{"authorDate":"2021-08-10 09:00:21","commitOrder":3,"curCode":"  public void testJobSchedulerUnschedule() throws Exception {\n    \r\n    File specDir = Files.createTempDir();\n\n    Properties properties = new Properties();\n    properties.setProperty(FLOWSPEC_STORE_DIR_KEY, specDir.getAbsolutePath());\n    FlowCatalog flowCatalog = new FlowCatalog(ConfigUtils.propertiesToConfig(properties));\n    ServiceBasedAppLauncher serviceLauncher = new ServiceBasedAppLauncher(properties, \"GaaSJobSchedulerTest\");\n\n    \r\n    SpecCatalogListener mockListener = Mockito.mock(SpecCatalogListener.class);\n    when(mockListener.getName()).thenReturn(ServiceConfigKeys.GOBBLIN_SERVICE_JOB_SCHEDULER_LISTENER_CLASS);\n    when(mockListener.onAddSpec(any())).thenReturn(new AddSpecResponse(\"\"));\n    flowCatalog.addListener(mockListener);\n\n    serviceLauncher.addService(flowCatalog);\n    serviceLauncher.start();\n\n    FlowSpec flowSpec0 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec0\"),\n        MockedSpecCompiler.UNCOMPILABLE_FLOW);\n    FlowSpec flowSpec1 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec1\"));\n    FlowSpec flowSpec2 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec2\"));\n\n    \r\n    flowCatalog.put(flowSpec0, true);\n    flowCatalog.put(flowSpec1, true);\n    flowCatalog.put(flowSpec2, true);\n\n    Assert.assertEquals(flowCatalog.getSpecs().size(), 3);\n\n    Orchestrator mockOrchestrator = Mockito.mock(Orchestrator.class);\n\n    \r\n    TestGobblinServiceJobScheduler scheduler = new TestGobblinServiceJobScheduler(\"testscheduler\",\n        ConfigFactory.empty(), Optional.of(flowCatalog), null, mockOrchestrator, null);\n\n    SpecCompiler mockCompiler = Mockito.mock(SpecCompiler.class);\n    Mockito.when(mockOrchestrator.getSpecCompiler()).thenReturn(mockCompiler);\n    Mockito.doAnswer((Answer<Void>) a -> {\n      scheduler.isCompilerHealthy = true;\n      return null;\n    }).when(mockCompiler).awaitHealthy();\n\n    scheduler.setActive(true);\n\n    AssertWithBackoff.create().timeoutMs(20000).maxSleepMs(2000).backoffFactor(2)\n        .assertTrue(new Predicate<Void>() {\n          @Override\n          public boolean apply(Void input) {\n            Map<String, Spec> scheduledFlowSpecs = scheduler.scheduledFlowSpecs;\n            if (scheduledFlowSpecs != null && scheduledFlowSpecs.size() == 2) {\n              return scheduler.scheduledFlowSpecs.containsKey(\"spec1\") &&\n                  scheduler.scheduledFlowSpecs.containsKey(\"spec2\");\n            } else {\n              return false;\n            }\n          }\n        }, \"Waiting all flowSpecs to be scheduled\");\n\n    \r\n    scheduler.setActive(false);\n    Collection<Invocation> invocations = Mockito.mockingDetails(mockOrchestrator).getInvocations();\n\n    for (Invocation invocation: invocations) {\n      \r\n      Assert.assertFalse(invocation.getMethod().getName().equals(\"remove\"));\n    }\n  }\n","date":"2021-08-10 09:00:21","endLine":278,"groupId":"3401","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testJobSchedulerUnschedule","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/d2/085a5e0a3b29b1e8d83c593b27d9e00328ac84.src","preCode":"  public void testJobSchedulerUnschedule() throws Exception {\n    \r\n    File specDir = Files.createTempDir();\n\n    Properties properties = new Properties();\n    properties.setProperty(FLOWSPEC_STORE_DIR_KEY, specDir.getAbsolutePath());\n    FlowCatalog flowCatalog = new FlowCatalog(ConfigUtils.propertiesToConfig(properties));\n    ServiceBasedAppLauncher serviceLauncher = new ServiceBasedAppLauncher(properties, \"GaaSJobSchedulerTest\");\n\n    \r\n    SpecCatalogListener mockListener = Mockito.mock(SpecCatalogListener.class);\n    when(mockListener.getName()).thenReturn(ServiceConfigKeys.GOBBLIN_SERVICE_JOB_SCHEDULER_LISTENER_CLASS);\n    when(mockListener.onAddSpec(any())).thenReturn(new AddSpecResponse(\"\"));\n    flowCatalog.addListener(mockListener);\n\n    serviceLauncher.addService(flowCatalog);\n    serviceLauncher.start();\n\n    FlowSpec flowSpec0 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec0\"),\n        MockedSpecCompiler.UNCOMPILABLE_FLOW);\n    FlowSpec flowSpec1 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec1\"));\n    FlowSpec flowSpec2 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec2\"));\n\n    \r\n    flowCatalog.put(flowSpec0, true);\n    flowCatalog.put(flowSpec1, true);\n    flowCatalog.put(flowSpec2, true);\n\n    Assert.assertEquals(flowCatalog.getSpecs().size(), 3);\n\n    Orchestrator mockOrchestrator = Mockito.mock(Orchestrator.class);\n\n    \r\n    TestGobblinServiceJobScheduler scheduler = new TestGobblinServiceJobScheduler(\"testscheduler\",\n        ConfigFactory.empty(), Optional.of(flowCatalog), null, mockOrchestrator, null);\n\n    SpecCompiler mockCompiler = Mockito.mock(SpecCompiler.class);\n    Mockito.when(mockOrchestrator.getSpecCompiler()).thenReturn(mockCompiler);\n    Mockito.doAnswer((Answer<Void>) a -> {\n      scheduler.isCompilerHealthy = true;\n      return null;\n    }).when(mockCompiler).awaitHealthy();\n\n    scheduler.setActive(true);\n\n    AssertWithBackoff.create().timeoutMs(20000).maxSleepMs(2000).backoffFactor(2)\n        .assertTrue(new Predicate<Void>() {\n          @Override\n          public boolean apply(Void input) {\n            Map<String, Spec> scheduledFlowSpecs = scheduler.scheduledFlowSpecs;\n            if (scheduledFlowSpecs != null && scheduledFlowSpecs.size() == 2) {\n              return scheduler.scheduledFlowSpecs.containsKey(\"spec1\") &&\n                  scheduler.scheduledFlowSpecs.containsKey(\"spec2\");\n            } else {\n              return false;\n            }\n          }\n        }, \"Waiting all flowSpecs to be scheduled\");\n\n    \r\n    scheduler.setActive(false);\n    Collection<Invocation> invocations = Mockito.mockingDetails(mockOrchestrator).getInvocations();\n\n    for (Invocation invocation: invocations) {\n      \r\n      Assert.assertFalse(invocation.getMethod().getName().equals(\"remove\"));\n    }\n  }\n","realPath":"gobblin-service/src/test/java/org/apache/gobblin/service/modules/scheduler/GobblinServiceJobSchedulerTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":211,"status":"B"}],"commitId":"8a4cda47aaf954041c82e43b6a10f389d1e4a4db","commitMessage":"@@@[GOBBLIN-1507] Prevent orchestrator removals when unscheduling flows (#3353)\n\nWhen demoted from leader.  GaaS removes all flows from orchestrator. We need to ensure that fail over events are not disruptive or destructive to currently running flows.  we only want the new leader node to handle scheduling responsibilities from that point forward.","date":"2021-08-10 09:00:21","modifiedFileCount":"3","status":"M","submitter":"William Lo"},{"authorTime":"2021-09-02 07:57:16","codes":[{"authorDate":"2021-06-05 06:46:57","commitOrder":4,"curCode":"  public void testJobSchedulerInitWithFailedSpec() throws Exception {\n    \r\n    File specDir = Files.createTempDir();\n\n    Properties properties = new Properties();\n    properties.setProperty(FLOWSPEC_STORE_DIR_KEY, specDir.getAbsolutePath());\n    FlowCatalog flowCatalog = new FlowCatalog(ConfigUtils.propertiesToConfig(properties));\n    ServiceBasedAppLauncher serviceLauncher = new ServiceBasedAppLauncher(properties, \"GaaSJobSchedulerTest\");\n\n    \r\n    SpecCatalogListener mockListener = Mockito.mock(SpecCatalogListener.class);\n    when(mockListener.getName()).thenReturn(ServiceConfigKeys.GOBBLIN_SERVICE_JOB_SCHEDULER_LISTENER_CLASS);\n    when(mockListener.onAddSpec(any())).thenReturn(new AddSpecResponse(\"\"));\n    flowCatalog.addListener(mockListener);\n\n    serviceLauncher.addService(flowCatalog);\n    serviceLauncher.start();\n\n    FlowSpec flowSpec0 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec0\"),\n        MockedSpecCompiler.UNCOMPILABLE_FLOW);\n    FlowSpec flowSpec1 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec1\"));\n    FlowSpec flowSpec2 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec2\"));\n\n    \r\n    flowCatalog.put(flowSpec0, true);\n    flowCatalog.put(flowSpec1, true);\n    flowCatalog.put(flowSpec2, true);\n\n    Assert.assertEquals(flowCatalog.getSpecs().size(), 3);\n\n    Orchestrator mockOrchestrator = Mockito.mock(Orchestrator.class);\n\n    \r\n    TestGobblinServiceJobScheduler scheduler = new TestGobblinServiceJobScheduler(\"testscheduler\",\n        ConfigFactory.empty(), Optional.of(flowCatalog), null, mockOrchestrator, null);\n\n    SpecCompiler mockCompiler = Mockito.mock(SpecCompiler.class);\n    Mockito.when(mockOrchestrator.getSpecCompiler()).thenReturn(mockCompiler);\n    Mockito.doAnswer((Answer<Void>) a -> {\n      scheduler.isCompilerHealthy = true;\n      return null;\n    }).when(mockCompiler).awaitHealthy();\n\n    scheduler.setActive(true);\n\n    AssertWithBackoff.create().timeoutMs(20000).maxSleepMs(2000).backoffFactor(2)\n        .assertTrue(new Predicate<Void>() {\n          @Override\n          public boolean apply(Void input) {\n            Map<String, Spec> scheduledFlowSpecs = scheduler.scheduledFlowSpecs;\n            if (scheduledFlowSpecs != null && scheduledFlowSpecs.size() == 2) {\n              return scheduler.scheduledFlowSpecs.containsKey(\"spec1\") &&\n                  scheduler.scheduledFlowSpecs.containsKey(\"spec2\");\n            } else {\n              return false;\n            }\n          }\n        }, \"Waiting all flowSpecs to be scheduled\");\n  }\n","date":"2021-06-05 06:46:57","endLine":203,"groupId":"101060","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testJobSchedulerInitWithFailedSpec","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/cc/84632cee177143cc32cbdf22933519b19c91b7.src","preCode":"  public void testJobSchedulerInitWithFailedSpec() throws Exception {\n    \r\n    File specDir = Files.createTempDir();\n\n    Properties properties = new Properties();\n    properties.setProperty(FLOWSPEC_STORE_DIR_KEY, specDir.getAbsolutePath());\n    FlowCatalog flowCatalog = new FlowCatalog(ConfigUtils.propertiesToConfig(properties));\n    ServiceBasedAppLauncher serviceLauncher = new ServiceBasedAppLauncher(properties, \"GaaSJobSchedulerTest\");\n\n    \r\n    SpecCatalogListener mockListener = Mockito.mock(SpecCatalogListener.class);\n    when(mockListener.getName()).thenReturn(ServiceConfigKeys.GOBBLIN_SERVICE_JOB_SCHEDULER_LISTENER_CLASS);\n    when(mockListener.onAddSpec(any())).thenReturn(new AddSpecResponse(\"\"));\n    flowCatalog.addListener(mockListener);\n\n    serviceLauncher.addService(flowCatalog);\n    serviceLauncher.start();\n\n    FlowSpec flowSpec0 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec0\"),\n        MockedSpecCompiler.UNCOMPILABLE_FLOW);\n    FlowSpec flowSpec1 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec1\"));\n    FlowSpec flowSpec2 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec2\"));\n\n    \r\n    flowCatalog.put(flowSpec0, true);\n    flowCatalog.put(flowSpec1, true);\n    flowCatalog.put(flowSpec2, true);\n\n    Assert.assertEquals(flowCatalog.getSpecs().size(), 3);\n\n    Orchestrator mockOrchestrator = Mockito.mock(Orchestrator.class);\n\n    \r\n    TestGobblinServiceJobScheduler scheduler = new TestGobblinServiceJobScheduler(\"testscheduler\",\n        ConfigFactory.empty(), Optional.of(flowCatalog), null, mockOrchestrator, null);\n\n    SpecCompiler mockCompiler = Mockito.mock(SpecCompiler.class);\n    Mockito.when(mockOrchestrator.getSpecCompiler()).thenReturn(mockCompiler);\n    Mockito.doAnswer((Answer<Void>) a -> {\n      scheduler.isCompilerHealthy = true;\n      return null;\n    }).when(mockCompiler).awaitHealthy();\n\n    scheduler.setActive(true);\n\n    AssertWithBackoff.create().timeoutMs(20000).maxSleepMs(2000).backoffFactor(2)\n        .assertTrue(new Predicate<Void>() {\n          @Override\n          public boolean apply(Void input) {\n            Map<String, Spec> scheduledFlowSpecs = scheduler.scheduledFlowSpecs;\n            if (scheduledFlowSpecs != null && scheduledFlowSpecs.size() == 2) {\n              return scheduler.scheduledFlowSpecs.containsKey(\"spec1\") &&\n                  scheduler.scheduledFlowSpecs.containsKey(\"spec2\");\n            } else {\n              return false;\n            }\n          }\n        }, \"Waiting all flowSpecs to be scheduled\");\n  }\n","realPath":"gobblin-service/src/test/java/org/apache/gobblin/service/modules/scheduler/GobblinServiceJobSchedulerTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":145,"status":"N"},{"authorDate":"2021-09-02 07:57:16","commitOrder":4,"curCode":"  public void testJobSchedulerUnschedule() throws Exception {\n    \r\n    File specDir = Files.createTempDir();\n\n    Properties properties = new Properties();\n    properties.setProperty(FLOWSPEC_STORE_DIR_KEY, specDir.getAbsolutePath());\n    FlowCatalog flowCatalog = new FlowCatalog(ConfigUtils.propertiesToConfig(properties));\n    ServiceBasedAppLauncher serviceLauncher = new ServiceBasedAppLauncher(properties, \"GaaSJobSchedulerTest\");\n\n    \r\n    SpecCatalogListener mockListener = Mockito.mock(SpecCatalogListener.class);\n    when(mockListener.getName()).thenReturn(ServiceConfigKeys.GOBBLIN_SERVICE_JOB_SCHEDULER_LISTENER_CLASS);\n    when(mockListener.onAddSpec(any())).thenReturn(new AddSpecResponse(\"\"));\n    flowCatalog.addListener(mockListener);\n\n    serviceLauncher.addService(flowCatalog);\n    serviceLauncher.start();\n\n    FlowSpec flowSpec0 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec0\"));\n    FlowSpec flowSpec1 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec1\"));\n    FlowSpec flowSpec2 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec2\"));\n\n    \r\n    flowCatalog.put(flowSpec0, true);\n    flowCatalog.put(flowSpec1, true);\n    flowCatalog.put(flowSpec2, true);\n\n    Assert.assertEquals(flowCatalog.getSpecs().size(), 3);\n\n    Orchestrator mockOrchestrator = Mockito.mock(Orchestrator.class);\n    SchedulerService schedulerService = new SchedulerService(new Properties());\n    \r\n    TestGobblinServiceJobScheduler scheduler = new TestGobblinServiceJobScheduler(\"testscheduler\",\n        ConfigFactory.empty(), Optional.of(flowCatalog), null, mockOrchestrator, schedulerService );\n\n    schedulerService.startAsync().awaitRunning();\n    scheduler.startUp();\n    SpecCompiler mockCompiler = Mockito.mock(SpecCompiler.class);\n    Mockito.when(mockOrchestrator.getSpecCompiler()).thenReturn(mockCompiler);\n    Mockito.doAnswer((Answer<Void>) a -> {\n      scheduler.isCompilerHealthy = true;\n      return null;\n    }).when(mockCompiler).awaitHealthy();\n\n    scheduler.setActive(true);\n\n    AssertWithBackoff.create().timeoutMs(20000).maxSleepMs(2000).backoffFactor(2)\n        .assertTrue(new Predicate<Void>() {\n          @Override\n          public boolean apply(Void input) {\n            Map<String, Spec> scheduledFlowSpecs = scheduler.scheduledFlowSpecs;\n            if (scheduledFlowSpecs != null && scheduledFlowSpecs.size() == 3) {\n              return scheduler.scheduledFlowSpecs.containsKey(\"spec0\") &&\n                  scheduler.scheduledFlowSpecs.containsKey(\"spec1\") &&\n                  scheduler.scheduledFlowSpecs.containsKey(\"spec2\");\n            } else {\n              return false;\n            }\n          }\n        }, \"Waiting all flowSpecs to be scheduled\");\n\n    \r\n    scheduler.setActive(false);\n    Collection<Invocation> invocations = Mockito.mockingDetails(mockOrchestrator).getInvocations();\n\n    for (Invocation invocation: invocations) {\n      \r\n      Assert.assertFalse(invocation.getMethod().getName().equals(\"remove\"));\n    }\n\n    Assert.assertEquals(scheduler.scheduledFlowSpecs.size(), 0);\n    Assert.assertEquals(schedulerService.getScheduler().getJobGroupNames().size(), 0);\n  }\n","date":"2021-09-02 07:57:16","endLine":284,"groupId":"101060","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testJobSchedulerUnschedule","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/a9/323971bf999b0c6cf3f5933f74451e8b941566.src","preCode":"  public void testJobSchedulerUnschedule() throws Exception {\n    \r\n    File specDir = Files.createTempDir();\n\n    Properties properties = new Properties();\n    properties.setProperty(FLOWSPEC_STORE_DIR_KEY, specDir.getAbsolutePath());\n    FlowCatalog flowCatalog = new FlowCatalog(ConfigUtils.propertiesToConfig(properties));\n    ServiceBasedAppLauncher serviceLauncher = new ServiceBasedAppLauncher(properties, \"GaaSJobSchedulerTest\");\n\n    \r\n    SpecCatalogListener mockListener = Mockito.mock(SpecCatalogListener.class);\n    when(mockListener.getName()).thenReturn(ServiceConfigKeys.GOBBLIN_SERVICE_JOB_SCHEDULER_LISTENER_CLASS);\n    when(mockListener.onAddSpec(any())).thenReturn(new AddSpecResponse(\"\"));\n    flowCatalog.addListener(mockListener);\n\n    serviceLauncher.addService(flowCatalog);\n    serviceLauncher.start();\n\n    FlowSpec flowSpec0 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec0\"),\n        MockedSpecCompiler.UNCOMPILABLE_FLOW);\n    FlowSpec flowSpec1 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec1\"));\n    FlowSpec flowSpec2 = FlowCatalogTest.initFlowSpec(specDir.getAbsolutePath(), URI.create(\"spec2\"));\n\n    \r\n    flowCatalog.put(flowSpec0, true);\n    flowCatalog.put(flowSpec1, true);\n    flowCatalog.put(flowSpec2, true);\n\n    Assert.assertEquals(flowCatalog.getSpecs().size(), 3);\n\n    Orchestrator mockOrchestrator = Mockito.mock(Orchestrator.class);\n\n    \r\n    TestGobblinServiceJobScheduler scheduler = new TestGobblinServiceJobScheduler(\"testscheduler\",\n        ConfigFactory.empty(), Optional.of(flowCatalog), null, mockOrchestrator, null);\n\n    SpecCompiler mockCompiler = Mockito.mock(SpecCompiler.class);\n    Mockito.when(mockOrchestrator.getSpecCompiler()).thenReturn(mockCompiler);\n    Mockito.doAnswer((Answer<Void>) a -> {\n      scheduler.isCompilerHealthy = true;\n      return null;\n    }).when(mockCompiler).awaitHealthy();\n\n    scheduler.setActive(true);\n\n    AssertWithBackoff.create().timeoutMs(20000).maxSleepMs(2000).backoffFactor(2)\n        .assertTrue(new Predicate<Void>() {\n          @Override\n          public boolean apply(Void input) {\n            Map<String, Spec> scheduledFlowSpecs = scheduler.scheduledFlowSpecs;\n            if (scheduledFlowSpecs != null && scheduledFlowSpecs.size() == 2) {\n              return scheduler.scheduledFlowSpecs.containsKey(\"spec1\") &&\n                  scheduler.scheduledFlowSpecs.containsKey(\"spec2\");\n            } else {\n              return false;\n            }\n          }\n        }, \"Waiting all flowSpecs to be scheduled\");\n\n    \r\n    scheduler.setActive(false);\n    Collection<Invocation> invocations = Mockito.mockingDetails(mockOrchestrator).getInvocations();\n\n    for (Invocation invocation: invocations) {\n      \r\n      Assert.assertFalse(invocation.getMethod().getName().equals(\"remove\"));\n    }\n  }\n","realPath":"gobblin-service/src/test/java/org/apache/gobblin/service/modules/scheduler/GobblinServiceJobSchedulerTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":212,"status":"M"}],"commitId":"d9d22225ff34d534322e1c33675aa3d34f995969","commitMessage":"@@@[GOBBLIN-1529] Clear all jobs quickly when demoting a leader node (#3380)\n\nIn scenarios where there are a large number of scheduled jobs.  it may take too long (measured in hours) to fully demote the past leader to unschedule all of its jobs incrementally. This can cause duplicate flow executions and inconsistent behavior. Instead we should bulk delete all schedules.\n\nIn the future we can investigate an option where past leaders keep their schedules in memory and periodically synchronize their in-memory schedulers from MySQL and prevent them from actually executing or doing work.  but there is no simple way of doing this right now as each scheduler would also have to account for updates/deletes to other hosts.","date":"2021-09-02 07:57:16","modifiedFileCount":"4","status":"M","submitter":"William Lo"}]
