[{"authorTime":"2017-07-31 15:51:25","codes":[{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"  synchronized public HashMap<Long, Long> getIntervals(long lowWatermarkValue, long highWatermarkValue,\n      long partitionInterval, int maxIntervals) {\n    Preconditions\n        .checkArgument(partitionInterval >= 1, \"Invalid value for partitionInterval, value should be at least 1.\");\n    Preconditions.checkArgument(maxIntervals > 0, \"Invalid value for maxIntervals, positive value expected.\");\n\n    HashMap<Long, Long> intervalMap = new HashMap<>();\n\n    if (lowWatermarkValue > highWatermarkValue) {\n      LOG.warn(\n          \"lowWatermarkValue: \" + lowWatermarkValue + \" is greater than highWatermarkValue: \" + highWatermarkValue);\n      return intervalMap;\n    }\n\n    final Calendar calendar = Calendar.getInstance();\n    Date nextTime;\n    final long lowWatermark = toEpoch(Long.toString(lowWatermarkValue));\n    final long highWatermark = toEpoch(Long.toString(highWatermarkValue));\n\n    long interval = getInterval(highWatermark - lowWatermark, partitionInterval, maxIntervals);\n    LOG.info(\"Recalculated partition interval:\" + interval + \" hours\");\n    if (interval == 0) {\n      return intervalMap;\n    }\n\n    Date startTime = new Date(lowWatermark);\n    Date endTime = new Date(highWatermark);\n    LOG.debug(\"Sart time:\" + startTime + \"; End time:\" + endTime);\n    long lwm;\n    long hwm;\n    while (startTime.getTime() < endTime.getTime()) {\n      lwm = Long.parseLong(inputFormatParser.format(startTime));\n      calendar.setTime(startTime);\n      calendar.add(Calendar.HOUR, (int) interval);\n      nextTime = calendar.getTime();\n      hwm = Long.parseLong(inputFormatParser.format(nextTime.getTime() <= endTime.getTime() ? nextTime : endTime));\n      intervalMap.put(lwm, hwm);\n      LOG.debug(\"Partition - low:\" + lwm + \"; high:\" + hwm);\n      startTime = nextTime;\n    }\n    return intervalMap;\n  }\n","date":"2017-07-31 15:51:25","endLine":106,"groupId":"6293","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getIntervals","params":"(longlowWatermarkValue@longhighWatermarkValue@longpartitionInterval@intmaxIntervals)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/c3/25d9ab955286ef8907b9a53f524171dc0c207e.src","preCode":"  synchronized public HashMap<Long, Long> getIntervals(long lowWatermarkValue, long highWatermarkValue,\n      long partitionInterval, int maxIntervals) {\n    Preconditions\n        .checkArgument(partitionInterval >= 1, \"Invalid value for partitionInterval, value should be at least 1.\");\n    Preconditions.checkArgument(maxIntervals > 0, \"Invalid value for maxIntervals, positive value expected.\");\n\n    HashMap<Long, Long> intervalMap = new HashMap<>();\n\n    if (lowWatermarkValue > highWatermarkValue) {\n      LOG.warn(\n          \"lowWatermarkValue: \" + lowWatermarkValue + \" is greater than highWatermarkValue: \" + highWatermarkValue);\n      return intervalMap;\n    }\n\n    final Calendar calendar = Calendar.getInstance();\n    Date nextTime;\n    final long lowWatermark = toEpoch(Long.toString(lowWatermarkValue));\n    final long highWatermark = toEpoch(Long.toString(highWatermarkValue));\n\n    long interval = getInterval(highWatermark - lowWatermark, partitionInterval, maxIntervals);\n    LOG.info(\"Recalculated partition interval:\" + interval + \" hours\");\n    if (interval == 0) {\n      return intervalMap;\n    }\n\n    Date startTime = new Date(lowWatermark);\n    Date endTime = new Date(highWatermark);\n    LOG.debug(\"Sart time:\" + startTime + \"; End time:\" + endTime);\n    long lwm;\n    long hwm;\n    while (startTime.getTime() < endTime.getTime()) {\n      lwm = Long.parseLong(inputFormatParser.format(startTime));\n      calendar.setTime(startTime);\n      calendar.add(Calendar.HOUR, (int) interval);\n      nextTime = calendar.getTime();\n      hwm = Long.parseLong(inputFormatParser.format(nextTime.getTime() <= endTime.getTime() ? nextTime : endTime));\n      intervalMap.put(lwm, hwm);\n      LOG.debug(\"Partition - low:\" + lwm + \"; high:\" + hwm);\n      startTime = nextTime;\n    }\n    return intervalMap;\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/source/extractor/watermark/TimestampWatermark.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"B"},{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"  synchronized public HashMap<Long, Long> getIntervals(long lowWatermarkValue, long highWatermarkValue,\n      long partitionIntervalInHours, int maxIntervals) {\n    Preconditions.checkArgument(maxIntervals > 0, \"Invalid value for maxIntervals, positive value expected.\");\n    Preconditions\n        .checkArgument(partitionIntervalInHours > 0, \"Invalid value for partitionInterval, should be at least 1.\");\n    HashMap<Long, Long> intervalMap = Maps.newHashMap();\n\n    if (lowWatermarkValue > highWatermarkValue) {\n      LOG.warn(\"The low water mark is greater than the high water mark, empty intervals are returned\");\n      return intervalMap;\n    }\n\n    final Calendar calendar = Calendar.getInstance();\n    Date nextTime;\n    Date lowWatermarkDate = extractFromTimestamp(Long.toString(lowWatermarkValue));\n    Date highWatermarkDate = extractFromTimestamp(Long.toString(highWatermarkValue));\n    final long lowWatermark = lowWatermarkDate.getTime();\n    final long highWatermark = highWatermarkDate.getTime();\n\n    int interval = getInterval(highWatermark - lowWatermark, partitionIntervalInHours, maxIntervals);\n    LOG.info(\"Recalculated partition interval:\" + interval + \" hours\");\n\n    Date startTime = new Date(lowWatermark);\n    Date endTime = new Date(highWatermark);\n    LOG.debug(\"Start time:\" + startTime + \"; End time:\" + endTime);\n    long lwm;\n    long hwm;\n    while (startTime.getTime() < endTime.getTime()) {\n      lwm = Long.parseLong(inputFormatParser.format(startTime));\n      calendar.setTime(startTime);\n      calendar.add(Calendar.HOUR, interval);\n      nextTime = calendar.getTime();\n      hwm = Long.parseLong(inputFormatParser.format(nextTime.getTime() <= endTime.getTime() ? nextTime : endTime));\n      intervalMap.put(lwm, hwm);\n      LOG.debug(\"Partition - low:\" + lwm + \"; high:\" + hwm);\n      startTime = nextTime;\n    }\n    return intervalMap;\n  }\n","date":"2017-07-31 15:51:25","endLine":105,"groupId":"2818","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getIntervals","params":"(longlowWatermarkValue@longhighWatermarkValue@longpartitionIntervalInHours@intmaxIntervals)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/0b/3e1af7e61c2a99d6777cc9302fc45fd8479ad2.src","preCode":"  synchronized public HashMap<Long, Long> getIntervals(long lowWatermarkValue, long highWatermarkValue,\n      long partitionIntervalInHours, int maxIntervals) {\n    Preconditions.checkArgument(maxIntervals > 0, \"Invalid value for maxIntervals, positive value expected.\");\n    Preconditions\n        .checkArgument(partitionIntervalInHours > 0, \"Invalid value for partitionInterval, should be at least 1.\");\n    HashMap<Long, Long> intervalMap = Maps.newHashMap();\n\n    if (lowWatermarkValue > highWatermarkValue) {\n      LOG.warn(\"The low water mark is greater than the high water mark, empty intervals are returned\");\n      return intervalMap;\n    }\n\n    final Calendar calendar = Calendar.getInstance();\n    Date nextTime;\n    Date lowWatermarkDate = extractFromTimestamp(Long.toString(lowWatermarkValue));\n    Date highWatermarkDate = extractFromTimestamp(Long.toString(highWatermarkValue));\n    final long lowWatermark = lowWatermarkDate.getTime();\n    final long highWatermark = highWatermarkDate.getTime();\n\n    int interval = getInterval(highWatermark - lowWatermark, partitionIntervalInHours, maxIntervals);\n    LOG.info(\"Recalculated partition interval:\" + interval + \" hours\");\n\n    Date startTime = new Date(lowWatermark);\n    Date endTime = new Date(highWatermark);\n    LOG.debug(\"Start time:\" + startTime + \"; End time:\" + endTime);\n    long lwm;\n    long hwm;\n    while (startTime.getTime() < endTime.getTime()) {\n      lwm = Long.parseLong(inputFormatParser.format(startTime));\n      calendar.setTime(startTime);\n      calendar.add(Calendar.HOUR, interval);\n      nextTime = calendar.getTime();\n      hwm = Long.parseLong(inputFormatParser.format(nextTime.getTime() <= endTime.getTime() ? nextTime : endTime));\n      intervalMap.put(lwm, hwm);\n      LOG.debug(\"Partition - low:\" + lwm + \"; high:\" + hwm);\n      startTime = nextTime;\n    }\n    return intervalMap;\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/source/extractor/watermark/HourWatermark.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":67,"status":"B"}],"commitId":"5457af88d56b8fb89b172129fd1ff24ecdd4eba8","commitMessage":"@@@Merge pull request #2031 from abti/move_packages_to_apache\n","date":"2017-07-31 15:51:25","modifiedFileCount":"2","status":"B","submitter":"Abhishek Tiwari"},{"authorTime":"2018-10-23 01:53:38","codes":[{"authorDate":"2018-10-23 01:53:38","commitOrder":2,"curCode":"  synchronized public HashMap<Long, Long> getIntervals(long lowWatermarkValue, long highWatermarkValue,\n      long partitionInterval, int maxIntervals) {\n    Preconditions\n        .checkArgument(partitionInterval >= 1, \"Invalid value for partitionInterval, value should be at least 1.\");\n    Preconditions.checkArgument(maxIntervals > 0, \"Invalid value for maxIntervals, positive value expected.\");\n\n    HashMap<Long, Long> intervalMap = new HashMap<>();\n\n    if (lowWatermarkValue > highWatermarkValue) {\n      LOG.warn(\n          \"lowWatermarkValue: \" + lowWatermarkValue + \" is greater than highWatermarkValue: \" + highWatermarkValue);\n      return intervalMap;\n    }\n\n    final Calendar calendar = Calendar.getInstance();\n    Date nextTime;\n    final long lowWatermark = toEpoch(Long.toString(lowWatermarkValue));\n    final long highWatermark = toEpoch(Long.toString(highWatermarkValue));\n\n    long interval = getInterval(highWatermark - lowWatermark, partitionInterval, maxIntervals);\n    LOG.info(\"Recalculated partition interval:\" + interval + \" hours\");\n    if (interval == 0) {\n      return intervalMap;\n    }\n\n    Date startTime = new Date(lowWatermark);\n    Date endTime = new Date(highWatermark);\n    LOG.debug(\"Sart time:\" + startTime + \"; End time:\" + endTime);\n    long lwm;\n    long hwm;\n\n    if (startTime.getTime() == endTime.getTime()) {\n      lwm = Long.parseLong(inputFormatParser.format(startTime));\n      hwm = lwm;\n      intervalMap.put(lwm, hwm);\n      return intervalMap;\n    }\n\n    while (startTime.getTime() < endTime.getTime()) {\n      lwm = Long.parseLong(inputFormatParser.format(startTime));\n      calendar.setTime(startTime);\n      calendar.add(Calendar.HOUR, (int) interval);\n      nextTime = calendar.getTime();\n      hwm = Long.parseLong(inputFormatParser.format(nextTime.getTime() <= endTime.getTime() ? nextTime : endTime));\n      intervalMap.put(lwm, hwm);\n      LOG.debug(\"Partition - low:\" + lwm + \"; high:\" + hwm);\n      startTime = nextTime;\n    }\n    return intervalMap;\n  }\n","date":"2018-10-23 01:53:38","endLine":114,"groupId":"101387","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"getIntervals","params":"(longlowWatermarkValue@longhighWatermarkValue@longpartitionInterval@intmaxIntervals)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/4d/8fa085296426c7cc6061411cdc095be3031ad7.src","preCode":"  synchronized public HashMap<Long, Long> getIntervals(long lowWatermarkValue, long highWatermarkValue,\n      long partitionInterval, int maxIntervals) {\n    Preconditions\n        .checkArgument(partitionInterval >= 1, \"Invalid value for partitionInterval, value should be at least 1.\");\n    Preconditions.checkArgument(maxIntervals > 0, \"Invalid value for maxIntervals, positive value expected.\");\n\n    HashMap<Long, Long> intervalMap = new HashMap<>();\n\n    if (lowWatermarkValue > highWatermarkValue) {\n      LOG.warn(\n          \"lowWatermarkValue: \" + lowWatermarkValue + \" is greater than highWatermarkValue: \" + highWatermarkValue);\n      return intervalMap;\n    }\n\n    final Calendar calendar = Calendar.getInstance();\n    Date nextTime;\n    final long lowWatermark = toEpoch(Long.toString(lowWatermarkValue));\n    final long highWatermark = toEpoch(Long.toString(highWatermarkValue));\n\n    long interval = getInterval(highWatermark - lowWatermark, partitionInterval, maxIntervals);\n    LOG.info(\"Recalculated partition interval:\" + interval + \" hours\");\n    if (interval == 0) {\n      return intervalMap;\n    }\n\n    Date startTime = new Date(lowWatermark);\n    Date endTime = new Date(highWatermark);\n    LOG.debug(\"Sart time:\" + startTime + \"; End time:\" + endTime);\n    long lwm;\n    long hwm;\n    while (startTime.getTime() < endTime.getTime()) {\n      lwm = Long.parseLong(inputFormatParser.format(startTime));\n      calendar.setTime(startTime);\n      calendar.add(Calendar.HOUR, (int) interval);\n      nextTime = calendar.getTime();\n      hwm = Long.parseLong(inputFormatParser.format(nextTime.getTime() <= endTime.getTime() ? nextTime : endTime));\n      intervalMap.put(lwm, hwm);\n      LOG.debug(\"Partition - low:\" + lwm + \"; high:\" + hwm);\n      startTime = nextTime;\n    }\n    return intervalMap;\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/source/extractor/watermark/TimestampWatermark.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"},{"authorDate":"2018-10-23 01:53:38","commitOrder":2,"curCode":"  synchronized public HashMap<Long, Long> getIntervals(long lowWatermarkValue, long highWatermarkValue,\n      long partitionIntervalInHours, int maxIntervals) {\n    Preconditions.checkArgument(maxIntervals > 0, \"Invalid value for maxIntervals, positive value expected.\");\n    Preconditions\n        .checkArgument(partitionIntervalInHours > 0, \"Invalid value for partitionInterval, should be at least 1.\");\n    HashMap<Long, Long> intervalMap = Maps.newHashMap();\n\n    if (lowWatermarkValue > highWatermarkValue) {\n      LOG.warn(\"The low water mark is greater than the high water mark, empty intervals are returned\");\n      return intervalMap;\n    }\n\n    final Calendar calendar = Calendar.getInstance();\n    Date nextTime;\n    Date lowWatermarkDate = extractFromTimestamp(Long.toString(lowWatermarkValue));\n    Date highWatermarkDate = extractFromTimestamp(Long.toString(highWatermarkValue));\n    final long lowWatermark = lowWatermarkDate.getTime();\n    final long highWatermark = highWatermarkDate.getTime();\n\n    int interval = getInterval(highWatermark - lowWatermark, partitionIntervalInHours, maxIntervals);\n    LOG.info(\"Recalculated partition interval:\" + interval + \" hours\");\n\n    Date startTime = new Date(lowWatermark);\n    Date endTime = new Date(highWatermark);\n    LOG.debug(\"Start time:\" + startTime + \"; End time:\" + endTime);\n    long lwm;\n    long hwm;\n\n    if (startTime.getTime() == endTime.getTime()) {\n      lwm = Long.parseLong(inputFormatParser.format(startTime));\n      hwm = lwm;\n      intervalMap.put(lwm, hwm);\n      return intervalMap;\n    }\n\n    while (startTime.getTime() < endTime.getTime()) {\n      lwm = Long.parseLong(inputFormatParser.format(startTime));\n      calendar.setTime(startTime);\n      calendar.add(Calendar.HOUR, interval);\n      nextTime = calendar.getTime();\n      hwm = Long.parseLong(inputFormatParser.format(nextTime.getTime() <= endTime.getTime() ? nextTime : endTime));\n      intervalMap.put(lwm, hwm);\n      LOG.debug(\"Partition - low:\" + lwm + \"; high:\" + hwm);\n      startTime = nextTime;\n    }\n    return intervalMap;\n  }\n","date":"2018-10-23 01:53:38","endLine":113,"groupId":"101387","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"getIntervals","params":"(longlowWatermarkValue@longhighWatermarkValue@longpartitionIntervalInHours@intmaxIntervals)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/af/6d507e965ec7161ea8fd543376208b59cca475.src","preCode":"  synchronized public HashMap<Long, Long> getIntervals(long lowWatermarkValue, long highWatermarkValue,\n      long partitionIntervalInHours, int maxIntervals) {\n    Preconditions.checkArgument(maxIntervals > 0, \"Invalid value for maxIntervals, positive value expected.\");\n    Preconditions\n        .checkArgument(partitionIntervalInHours > 0, \"Invalid value for partitionInterval, should be at least 1.\");\n    HashMap<Long, Long> intervalMap = Maps.newHashMap();\n\n    if (lowWatermarkValue > highWatermarkValue) {\n      LOG.warn(\"The low water mark is greater than the high water mark, empty intervals are returned\");\n      return intervalMap;\n    }\n\n    final Calendar calendar = Calendar.getInstance();\n    Date nextTime;\n    Date lowWatermarkDate = extractFromTimestamp(Long.toString(lowWatermarkValue));\n    Date highWatermarkDate = extractFromTimestamp(Long.toString(highWatermarkValue));\n    final long lowWatermark = lowWatermarkDate.getTime();\n    final long highWatermark = highWatermarkDate.getTime();\n\n    int interval = getInterval(highWatermark - lowWatermark, partitionIntervalInHours, maxIntervals);\n    LOG.info(\"Recalculated partition interval:\" + interval + \" hours\");\n\n    Date startTime = new Date(lowWatermark);\n    Date endTime = new Date(highWatermark);\n    LOG.debug(\"Start time:\" + startTime + \"; End time:\" + endTime);\n    long lwm;\n    long hwm;\n    while (startTime.getTime() < endTime.getTime()) {\n      lwm = Long.parseLong(inputFormatParser.format(startTime));\n      calendar.setTime(startTime);\n      calendar.add(Calendar.HOUR, interval);\n      nextTime = calendar.getTime();\n      hwm = Long.parseLong(inputFormatParser.format(nextTime.getTime() <= endTime.getTime() ? nextTime : endTime));\n      intervalMap.put(lwm, hwm);\n      LOG.debug(\"Partition - low:\" + lwm + \"; high:\" + hwm);\n      startTime = nextTime;\n    }\n    return intervalMap;\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/source/extractor/watermark/HourWatermark.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":67,"status":"M"}],"commitId":"1f6e46f876ac1316cc35de3fa9984ca437244111","commitMessage":"@@@[GOBBLIN-615] Generate a valid interval when LWM==HWM in QueryBasedSource\n\nCloses #2482 from yukuai518/interval\n","date":"2018-10-23 01:53:38","modifiedFileCount":"10","status":"M","submitter":"Kuai Yu"}]
