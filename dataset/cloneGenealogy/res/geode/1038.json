[{"authorTime":"2018-07-28 02:28:34","codes":[{"authorDate":"2018-07-28 02:28:34","commitOrder":1,"curCode":"  void doTestPutAndGetMixedServers(String objectType, boolean partitioned, String oldVersion)\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServerAndLocator = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServer2 = host.getVM(oldVersion, 3);\n\n    String regionName = \"aRegion\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    DistributedTestUtils.deleteLocatorStateFile(port);\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n\n      invokeRunnableInVMs(invokeCreateCache(props), oldServer2, currentServer1, currentServer2);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putAndVerify(objectType, currentServer1, regionName, 0, 10, currentServer2,\n          oldServerAndLocator, oldServer2);\n      putAndVerify(objectType, oldServerAndLocator, regionName, 5, 15, currentServer1,\n          currentServer2, oldServer2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeCloseCache(), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n    }\n  }\n","date":"2018-07-28 02:28:34","endLine":292,"groupId":"11352","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestPutAndGetMixedServers","params":"(StringobjectType@booleanpartitioned@StringoldVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/8c/0d460898c9a500bd5794b5307230108549edbd.src","preCode":"  void doTestPutAndGetMixedServers(String objectType, boolean partitioned, String oldVersion)\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServerAndLocator = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServer2 = host.getVM(oldVersion, 3);\n\n    String regionName = \"aRegion\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    DistributedTestUtils.deleteLocatorStateFile(port);\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n\n      invokeRunnableInVMs(invokeCreateCache(props), oldServer2, currentServer1, currentServer2);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putAndVerify(objectType, currentServer1, regionName, 0, 10, currentServer2,\n          oldServerAndLocator, oldServer2);\n      putAndVerify(objectType, oldServerAndLocator, regionName, 5, 15, currentServer1,\n          currentServer2, oldServer2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeCloseCache(), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgrade2DUnitTestBase.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"B"},{"authorDate":"2018-07-28 02:28:34","commitOrder":1,"curCode":"  void doTestQueryMixedServers(boolean partitioned, String oldVersion) throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServer = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServerAndLocator = host.getVM(oldVersion, 3);\n\n    String regionName = \"cqs\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n      invokeRunnableInVMs(invokeCreateCache(props), currentServer1, currentServer2, oldServer);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServer, oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putDataSerializableAndVerify(currentServer1, regionName, 0, 100, currentServer2, oldServer,\n          oldServerAndLocator);\n      query(\"Select * from /\" + regionName + \" p where p.timeout > 0L\", 99, currentServer1,\n          currentServer2, oldServer, oldServerAndLocator);\n\n    } finally {\n      invokeRunnableInVMs(invokeCloseCache(), currentServer1, currentServer2, oldServer,\n          oldServerAndLocator);\n    }\n  }\n","date":"2018-07-28 02:28:34","endLine":351,"groupId":"11353","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"doTestQueryMixedServers","params":"(booleanpartitioned@StringoldVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/8c/0d460898c9a500bd5794b5307230108549edbd.src","preCode":"  void doTestQueryMixedServers(boolean partitioned, String oldVersion) throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServer = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServerAndLocator = host.getVM(oldVersion, 3);\n\n    String regionName = \"cqs\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n      invokeRunnableInVMs(invokeCreateCache(props), currentServer1, currentServer2, oldServer);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServer, oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putDataSerializableAndVerify(currentServer1, regionName, 0, 100, currentServer2, oldServer,\n          oldServerAndLocator);\n      query(\"Select * from /\" + regionName + \" p where p.timeout > 0L\", 99, currentServer1,\n          currentServer2, oldServer, oldServerAndLocator);\n\n    } finally {\n      invokeRunnableInVMs(invokeCloseCache(), currentServer1, currentServer2, oldServer,\n          oldServerAndLocator);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgrade2DUnitTestBase.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"B"}],"commitId":"6712acaadfb7ce894f797e442de09abddb8ea390","commitMessage":"@@@GEODE-5471 Split RollingUpgrade tests to parallelize (#2183)\n\nFor all UpgradeTest test classes.  split each method into its own class\nto allow gradle-docker-plugin to run them concurrently fast.\n\n- RollingUpgradeDUnit split to 3 test classes\n- Using 'parameterize' instead of native constructors\n- Tightened visibility of helper methods\n- rollingupgrade2dunit refactored into 16 test classes\n- Extract LuceneRollingUpgrade tests to individual test child classes.\n- split WAN rolling upgrade\n\nCo-authored-by: Robert Houghton <rhoughton@pivotal.io>\nCo-authored-by: Patrick Rhomberg <prhomberg@pivotal.io>\nCo-authored-by: Finn Southerland <fsoutherland@pivotal.io>\n","date":"2018-07-28 02:28:34","modifiedFileCount":"3","status":"B","submitter":"Robert Houghton"},{"authorTime":"2018-08-17 08:13:57","codes":[{"authorDate":"2018-08-17 08:13:57","commitOrder":2,"curCode":"  void doTestPutAndGetMixedServers(String objectType, boolean partitioned, String oldVersion)\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServerAndLocator = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServer2 = host.getVM(oldVersion, 3);\n\n    String regionName = \"aRegion\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    DistributedTestUtils.deleteLocatorStateFile(port);\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n\n      invokeRunnableInVMs(invokeCreateCache(props), oldServer2, currentServer1, currentServer2);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putAndVerify(objectType, currentServer1, regionName, 0, 10, currentServer2,\n          oldServerAndLocator, oldServer2);\n      putAndVerify(objectType, oldServerAndLocator, regionName, 5, 15, currentServer1,\n          currentServer2, oldServer2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeCloseCache(), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n    }\n  }\n","date":"2018-08-18 01:08:42","endLine":292,"groupId":"26588","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestPutAndGetMixedServers","params":"(StringobjectType@booleanpartitioned@StringoldVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/b9/c80900fd573266b4c7382e28f0bd5235f3b310.src","preCode":"  void doTestPutAndGetMixedServers(String objectType, boolean partitioned, String oldVersion)\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServerAndLocator = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServer2 = host.getVM(oldVersion, 3);\n\n    String regionName = \"aRegion\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    DistributedTestUtils.deleteLocatorStateFile(port);\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n\n      invokeRunnableInVMs(invokeCreateCache(props), oldServer2, currentServer1, currentServer2);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putAndVerify(objectType, currentServer1, regionName, 0, 10, currentServer2,\n          oldServerAndLocator, oldServer2);\n      putAndVerify(objectType, oldServerAndLocator, regionName, 5, 15, currentServer1,\n          currentServer2, oldServer2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeCloseCache(), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgrade2DUnitTestBase.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"M"},{"authorDate":"2018-08-17 08:13:57","commitOrder":2,"curCode":"  void doTestQueryMixedServers(boolean partitioned, String oldVersion) throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServer = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServerAndLocator = host.getVM(oldVersion, 3);\n\n    String regionName = \"cqs\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n      invokeRunnableInVMs(invokeCreateCache(props), currentServer1, currentServer2, oldServer);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServer, oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putDataSerializableAndVerify(currentServer1, regionName, 0, 100, currentServer2, oldServer,\n          oldServerAndLocator);\n      query(\"Select * from /\" + regionName + \" p where p.timeout > 0L\", 99, currentServer1,\n          currentServer2, oldServer, oldServerAndLocator);\n\n    } finally {\n      invokeRunnableInVMs(invokeCloseCache(), currentServer1, currentServer2, oldServer,\n          oldServerAndLocator);\n    }\n  }\n","date":"2018-08-18 01:08:42","endLine":351,"groupId":"35413","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"doTestQueryMixedServers","params":"(booleanpartitioned@StringoldVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/b9/c80900fd573266b4c7382e28f0bd5235f3b310.src","preCode":"  void doTestQueryMixedServers(boolean partitioned, String oldVersion) throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServer = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServerAndLocator = host.getVM(oldVersion, 3);\n\n    String regionName = \"cqs\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n      invokeRunnableInVMs(invokeCreateCache(props), currentServer1, currentServer2, oldServer);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServer, oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putDataSerializableAndVerify(currentServer1, regionName, 0, 100, currentServer2, oldServer,\n          oldServerAndLocator);\n      query(\"Select * from /\" + regionName + \" p where p.timeout > 0L\", 99, currentServer1,\n          currentServer2, oldServer, oldServerAndLocator);\n\n    } finally {\n      invokeRunnableInVMs(invokeCloseCache(), currentServer1, currentServer2, oldServer,\n          oldServerAndLocator);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgrade2DUnitTestBase.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"M"}],"commitId":"f3f255a234eac78b63dc4932e1d725c20fe75706","commitMessage":"@@@GEODE-5593 Update test dependencies\n\nUpdated the following dependencies:\n\nassertj \t3.8.0 => 3.10.0\nawaitility \t2.0.0 => 3.1.1\nbcel\t\t6.0 => 6.2\ncglib\t\t3.2.4 => 3.2.7\nderby\t\t10.13.1.1 => 10.14.2.0\nhttpclient\t4.5.3 => 4.5.6\nbcel\t\t6.0 => 6.2\ncglib\t\t3.2.4 => 3.2.7\nderby\t\t10.13.1.1 => 10.14.2.0\nhttpclient\t4.5.3 => 4.5.6\nhttpcore\t4.4.6 => 4.4.10\njavax.mail\t1.4.6 => 1.6.1\njavax.persistence 2.1.1 => 2.2.0\njmock\t\t2.8.2 => 2.8.4\njson-path\t2.2.0 => 2.4.0\njunit-quickcheck 0.7 => 0.8.1\nmockito\t\t2.8.9 => 2.19.1\npowermock\t1.7.1 => 2.0.0-beta.5\nselenimum\t3.9.1 => 3.13.0\nsystem-rules\t1.17.1 => 1.18.0\nxerces\t\t2.11.0 => 2.12.0\n\nUpdated some tests due to API changes. Typically this meant\nconverting from until() to untilAsserted().  In other cases\nyou aren't allowed to throw undeclared check exceptions.\n\nUpdated and corrected powermock usage in a few places.\n\nDid not update junit-params since too many places in our\ntests use the test method name for region name (and the\ntest method name would not have been a legal region\nname).  This is an opportunity for future refactoring.\n","date":"2018-08-18 01:08:42","modifiedFileCount":"182","status":"M","submitter":"Anthony Baker"},{"authorTime":"2018-10-05 06:38:58","codes":[{"authorDate":"2018-10-05 06:38:58","commitOrder":3,"curCode":"  void doTestPutAndGetMixedServers(String objectType, boolean partitioned, String oldVersion)\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServerAndLocator = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServer2 = host.getVM(oldVersion, 3);\n\n    String regionName = \"aRegion\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    DistributedTestUtils.deleteLocatorStateFile(port);\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n\n      invokeRunnableInVMs(invokeCreateCache(props), oldServer2, currentServer1, currentServer2);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putAndVerify(objectType, currentServer1, regionName, 0, 10, currentServer2,\n          oldServerAndLocator, oldServer2);\n      putAndVerify(objectType, oldServerAndLocator, regionName, 5, 15, currentServer1,\n          currentServer2, oldServer2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeCloseCache(), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n    }\n  }\n","date":"2018-10-19 08:01:02","endLine":290,"groupId":"35414","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestPutAndGetMixedServers","params":"(StringobjectType@booleanpartitioned@StringoldVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/3b/ff442b8192a8da2979054d98844d6e38a28a72.src","preCode":"  void doTestPutAndGetMixedServers(String objectType, boolean partitioned, String oldVersion)\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServerAndLocator = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServer2 = host.getVM(oldVersion, 3);\n\n    String regionName = \"aRegion\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    DistributedTestUtils.deleteLocatorStateFile(port);\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n\n      invokeRunnableInVMs(invokeCreateCache(props), oldServer2, currentServer1, currentServer2);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putAndVerify(objectType, currentServer1, regionName, 0, 10, currentServer2,\n          oldServerAndLocator, oldServer2);\n      putAndVerify(objectType, oldServerAndLocator, regionName, 5, 15, currentServer1,\n          currentServer2, oldServer2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeCloseCache(), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgrade2DUnitTestBase.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"M"},{"authorDate":"2018-10-05 06:38:58","commitOrder":3,"curCode":"  void doTestQueryMixedServers(boolean partitioned, String oldVersion) throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServer = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServerAndLocator = host.getVM(oldVersion, 3);\n\n    String regionName = \"cqs\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n      invokeRunnableInVMs(invokeCreateCache(props), currentServer1, currentServer2, oldServer);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServer, oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putDataSerializableAndVerify(currentServer1, regionName, 0, 100, currentServer2, oldServer,\n          oldServerAndLocator);\n      query(\"Select * from /\" + regionName + \" p where p.timeout > 0L\", 99, currentServer1,\n          currentServer2, oldServer, oldServerAndLocator);\n\n    } finally {\n      invokeRunnableInVMs(invokeCloseCache(), currentServer1, currentServer2, oldServer,\n          oldServerAndLocator);\n    }\n  }\n","date":"2018-10-19 08:01:02","endLine":349,"groupId":"35413","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"doTestQueryMixedServers","params":"(booleanpartitioned@StringoldVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/3b/ff442b8192a8da2979054d98844d6e38a28a72.src","preCode":"  void doTestQueryMixedServers(boolean partitioned, String oldVersion) throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServer = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServerAndLocator = host.getVM(oldVersion, 3);\n\n    String regionName = \"cqs\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n      invokeRunnableInVMs(invokeCreateCache(props), currentServer1, currentServer2, oldServer);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServer, oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putDataSerializableAndVerify(currentServer1, regionName, 0, 100, currentServer2, oldServer,\n          oldServerAndLocator);\n      query(\"Select * from /\" + regionName + \" p where p.timeout > 0L\", 99, currentServer1,\n          currentServer2, oldServer, oldServerAndLocator);\n\n    } finally {\n      invokeRunnableInVMs(invokeCloseCache(), currentServer1, currentServer2, oldServer,\n          oldServerAndLocator);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgrade2DUnitTestBase.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":292,"status":"M"}],"commitId":"239c532f8338c9d8e9bb8062fab9fadd3376ec73","commitMessage":"@@@GEODE-5424: Changing all awaitility calls to use consistent timings\n\nWe have a lot of Awaitility calls in our tests. Each test was picking\nits own timeout. That lead to some tests picking too small of a timeout\nand failing spuriously.\n\nWith this change.  all tests will use a new factory. \nGeodeAwaility.await().  rather than Awaitility.await(). This new factory\nsets a default timeout of 5 minutes. It also sets a sensible pollDelay\nand pollInterval.\n\nThe custom timeouts used in all tests have been removed.  in favor of\nthis new factory.  except for a couple of tests that had waits greater\nthan 5 minutes.\n","date":"2018-10-19 08:01:02","modifiedFileCount":"334","status":"M","submitter":"Dan Smith"},{"authorTime":"2018-10-05 06:38:58","codes":[{"authorDate":"2019-08-16 01:19:19","commitOrder":4,"curCode":"  void doTestPutAndGetMixedServers(String objectType, boolean partitioned, String oldVersion)\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServerAndLocator = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServer2 = host.getVM(oldVersion, 3);\n\n    String regionName = \"aRegion\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    oldServerAndLocator.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(port));\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n\n      invokeRunnableInVMs(invokeCreateCache(props), oldServer2, currentServer1, currentServer2);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putAndVerify(objectType, currentServer1, regionName, 0, 10, currentServer2,\n          oldServerAndLocator, oldServer2);\n      putAndVerify(objectType, oldServerAndLocator, regionName, 5, 15, currentServer1,\n          currentServer2, oldServer2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeCloseCache(), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n    }\n  }\n","date":"2019-08-16 01:19:19","endLine":295,"groupId":"35414","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestPutAndGetMixedServers","params":"(StringobjectType@booleanpartitioned@StringoldVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/8e/a06f2aacfc511e28a0c5c38c85d40145fc1af8.src","preCode":"  void doTestPutAndGetMixedServers(String objectType, boolean partitioned, String oldVersion)\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServerAndLocator = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServer2 = host.getVM(oldVersion, 3);\n\n    String regionName = \"aRegion\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    DistributedTestUtils.deleteLocatorStateFile(port);\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n\n      invokeRunnableInVMs(invokeCreateCache(props), oldServer2, currentServer1, currentServer2);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putAndVerify(objectType, currentServer1, regionName, 0, 10, currentServer2,\n          oldServerAndLocator, oldServer2);\n      putAndVerify(objectType, oldServerAndLocator, regionName, 5, 15, currentServer1,\n          currentServer2, oldServer2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeCloseCache(), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgrade2DUnitTestBase.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"M"},{"authorDate":"2018-10-05 06:38:58","commitOrder":4,"curCode":"  void doTestQueryMixedServers(boolean partitioned, String oldVersion) throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServer = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServerAndLocator = host.getVM(oldVersion, 3);\n\n    String regionName = \"cqs\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n      invokeRunnableInVMs(invokeCreateCache(props), currentServer1, currentServer2, oldServer);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServer, oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putDataSerializableAndVerify(currentServer1, regionName, 0, 100, currentServer2, oldServer,\n          oldServerAndLocator);\n      query(\"Select * from /\" + regionName + \" p where p.timeout > 0L\", 99, currentServer1,\n          currentServer2, oldServer, oldServerAndLocator);\n\n    } finally {\n      invokeRunnableInVMs(invokeCloseCache(), currentServer1, currentServer2, oldServer,\n          oldServerAndLocator);\n    }\n  }\n","date":"2018-10-19 08:01:02","endLine":349,"groupId":"35413","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"doTestQueryMixedServers","params":"(booleanpartitioned@StringoldVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/3b/ff442b8192a8da2979054d98844d6e38a28a72.src","preCode":"  void doTestQueryMixedServers(boolean partitioned, String oldVersion) throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServer = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServerAndLocator = host.getVM(oldVersion, 3);\n\n    String regionName = \"cqs\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n      invokeRunnableInVMs(invokeCreateCache(props), currentServer1, currentServer2, oldServer);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServer, oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putDataSerializableAndVerify(currentServer1, regionName, 0, 100, currentServer2, oldServer,\n          oldServerAndLocator);\n      query(\"Select * from /\" + regionName + \" p where p.timeout > 0L\", 99, currentServer1,\n          currentServer2, oldServer, oldServerAndLocator);\n\n    } finally {\n      invokeRunnableInVMs(invokeCloseCache(), currentServer1, currentServer2, oldServer,\n          oldServerAndLocator);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgrade2DUnitTestBase.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":292,"status":"N"}],"commitId":"86fd74db98b5dff0e92ea4985651f3955c1a3420","commitMessage":"@@@GEODE-7072 CI Failure: WANRollingUpgradeEventProcessingMixedSiteOneCurrentSiteTwo (#3908)\n\n* GEODE-7072 CI Failure: WANRollingUpgradeEventProcessingMixedSiteOneCurrentSiteTwo\n\nA number of tests were attempting to delete old locator state files\ncontaining membership views in order to ensure that artifacts from\npreviously run tests were not around to infect the current test.\n\nUnfortunately the calls to DistributedTestUtils.deleteLocatorStateFile()\nwere being made from the wrong working directory.  Instead of looking\nfor the file(s) in the directory that the test's locator would use they\nwere looking in the unit test VMs working directory.\n\n* adding another test\n","date":"2019-08-16 01:19:19","modifiedFileCount":"26","status":"M","submitter":"Bruce Schuchardt"},{"authorTime":"2019-09-10 03:24:30","codes":[{"authorDate":"2019-09-10 03:24:30","commitOrder":5,"curCode":"  void doTestPutAndGetMixedServers(String objectType, boolean partitioned, String oldVersion)\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServerAndLocator = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServer2 = host.getVM(oldVersion, 3);\n\n    String regionName = \"aRegion\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    oldServerAndLocator.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(port));\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n\n      invokeRunnableInVMs(invokeCreateCache(props), oldServer2, currentServer1, currentServer2);\n\n      currentServer1\n          .invoke(invokeAssertVersion(VersionManager.getInstance().getCurrentVersionOrdinal()));\n      currentServer2\n          .invoke(invokeAssertVersion(VersionManager.getInstance().getCurrentVersionOrdinal()));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putAndVerify(objectType, currentServer1, regionName, 0, 10, currentServer2,\n          oldServerAndLocator, oldServer2);\n      putAndVerify(objectType, oldServerAndLocator, regionName, 5, 15, currentServer1,\n          currentServer2, oldServer2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeCloseCache(), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n    }\n  }\n","date":"2019-09-10 03:24:30","endLine":296,"groupId":"11497","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestPutAndGetMixedServers","params":"(StringobjectType@booleanpartitioned@StringoldVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/9d/d2e597d575d0ee62b9730b999558d347ea4561.src","preCode":"  void doTestPutAndGetMixedServers(String objectType, boolean partitioned, String oldVersion)\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServerAndLocator = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServer2 = host.getVM(oldVersion, 3);\n\n    String regionName = \"aRegion\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    oldServerAndLocator.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(port));\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n\n      invokeRunnableInVMs(invokeCreateCache(props), oldServer2, currentServer1, currentServer2);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putAndVerify(objectType, currentServer1, regionName, 0, 10, currentServer2,\n          oldServerAndLocator, oldServer2);\n      putAndVerify(objectType, oldServerAndLocator, regionName, 5, 15, currentServer1,\n          currentServer2, oldServer2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeCloseCache(), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgrade2DUnitTestBase.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":234,"status":"M"},{"authorDate":"2019-09-10 03:24:30","commitOrder":5,"curCode":"  void doTestQueryMixedServers(boolean partitioned, String oldVersion) throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServer = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServerAndLocator = host.getVM(oldVersion, 3);\n\n    String regionName = \"cqs\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n      invokeRunnableInVMs(invokeCreateCache(props), currentServer1, currentServer2, oldServer);\n\n      currentServer1\n          .invoke(invokeAssertVersion(VersionManager.getInstance().getCurrentVersionOrdinal()));\n      currentServer2\n          .invoke(invokeAssertVersion(VersionManager.getInstance().getCurrentVersionOrdinal()));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServer, oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putDataSerializableAndVerify(currentServer1, regionName, 0, 100, currentServer2, oldServer,\n          oldServerAndLocator);\n      query(\"Select * from /\" + regionName + \" p where p.timeout > 0L\", 99, currentServer1,\n          currentServer2, oldServer, oldServerAndLocator);\n\n    } finally {\n      invokeRunnableInVMs(invokeCloseCache(), currentServer1, currentServer2, oldServer,\n          oldServerAndLocator);\n    }\n  }\n","date":"2019-09-10 03:24:30","endLine":357,"groupId":"11498","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"doTestQueryMixedServers","params":"(booleanpartitioned@StringoldVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/9d/d2e597d575d0ee62b9730b999558d347ea4561.src","preCode":"  void doTestQueryMixedServers(boolean partitioned, String oldVersion) throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServer = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServerAndLocator = host.getVM(oldVersion, 3);\n\n    String regionName = \"cqs\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n      invokeRunnableInVMs(invokeCreateCache(props), currentServer1, currentServer2, oldServer);\n\n      currentServer1.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n      currentServer2.invoke(invokeAssertVersion(Version.CURRENT_ORDINAL));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServer, oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putDataSerializableAndVerify(currentServer1, regionName, 0, 100, currentServer2, oldServer,\n          oldServerAndLocator);\n      query(\"Select * from /\" + regionName + \" p where p.timeout > 0L\", 99, currentServer1,\n          currentServer2, oldServer, oldServerAndLocator);\n\n    } finally {\n      invokeRunnableInVMs(invokeCloseCache(), currentServer1, currentServer2, oldServer,\n          oldServerAndLocator);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgrade2DUnitTestBase.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":298,"status":"M"}],"commitId":"6ee6d961da4774dc2662edc362e241a02f31452c","commitMessage":"@@@GEODE-7090 Remove dependency on DataSerializer from membership classes\n\nDataSerializableFixedID is used by most internal classes for\nserialization.  Membership.  in particular.  was constrained in its\nimplementation to use only \"fixed\" serialization identifiers because our\nother serialization mechanisms (DataSerialiable.  PDX) are dependent on\nmembership and messaging.\n\nThis PR moves serialization of DataSerializableFixedID to a new\nsub-project.  geode-serialization in support of also separating\nmembership into its own sub-project.\n\nMany files are touched by this PR.  The vast majority are due to a\nchange in the serialization interface that introduces a new parameter in\nDataSerializableFixedID's toData and fromData methods.  This parameter\ngives access to the serializer and to the Version of the\nsource/destination.  This parameter was added to begin moving from a\n\"static\" based serialization service to an instance based service.\n\nSerialization code concerning \"DSFID\"s has been moved from\nInternalDataSerializer to the new class DSFIDSerialzerImpl.\nInternalDataSerializer holds on to an instance of this class and\ndelegates DSFID serialization to it.\n\nInternalDataSerializer also effects registration of Geode's DSFID\nclasses with this serializer.  Membership \"Services\" handles\nregistration of its own DSFID classes with the service.  as do other\nsub-projects like geode-web.\n\nHeapDataOutputStream has been used by most of our serialization code to\nprovide a DataOutput for our toData methods.  Over the years this class\nhas accumulated a lot of adornments for PDX serialization that aren't\nappropriate for a geode-serialization sub-project.  Consequently I've\nmoved much of its code into a superclass.  BufferDataOutputStream.  that\nprovides most of its functionality w/o needing to reference other geode-\ncore classes.\n\nVersion.java has been repackaged in this PR.  moving it into a\n\"serialization\" package.  This affected some rolling-upgrade and\nbackward-compatibility tests that were referring to\nVersion.CURRENT_ORDINAL.  These have been modified to get the \"current\nversion ordinal\" from VersionManager.\n\nFinally.  InternalDataSerializer injects a serializer into the new\nsub-project that provideds an API for handling other types of\nserializable objects like PDX.  This serializer is available in the\nDataSerializableFixedID toData/fromData context parameter and is used by\nmembership services when serializing Geode DistributionMessages.\n","date":"2019-09-10 03:24:30","modifiedFileCount":"646","status":"M","submitter":"Bruce Schuchardt"},{"authorTime":"2020-05-29 00:37:39","codes":[{"authorDate":"2019-09-10 03:24:30","commitOrder":6,"curCode":"  void doTestPutAndGetMixedServers(String objectType, boolean partitioned, String oldVersion)\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServerAndLocator = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServer2 = host.getVM(oldVersion, 3);\n\n    String regionName = \"aRegion\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    oldServerAndLocator.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(port));\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n\n      invokeRunnableInVMs(invokeCreateCache(props), oldServer2, currentServer1, currentServer2);\n\n      currentServer1\n          .invoke(invokeAssertVersion(VersionManager.getInstance().getCurrentVersionOrdinal()));\n      currentServer2\n          .invoke(invokeAssertVersion(VersionManager.getInstance().getCurrentVersionOrdinal()));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putAndVerify(objectType, currentServer1, regionName, 0, 10, currentServer2,\n          oldServerAndLocator, oldServer2);\n      putAndVerify(objectType, oldServerAndLocator, regionName, 5, 15, currentServer1,\n          currentServer2, oldServer2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeCloseCache(), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n    }\n  }\n","date":"2019-09-10 03:24:30","endLine":296,"groupId":"1038","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"doTestPutAndGetMixedServers","params":"(StringobjectType@booleanpartitioned@StringoldVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/9d/d2e597d575d0ee62b9730b999558d347ea4561.src","preCode":"  void doTestPutAndGetMixedServers(String objectType, boolean partitioned, String oldVersion)\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServerAndLocator = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServer2 = host.getVM(oldVersion, 3);\n\n    String regionName = \"aRegion\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    oldServerAndLocator.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(port));\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n\n      invokeRunnableInVMs(invokeCreateCache(props), oldServer2, currentServer1, currentServer2);\n\n      currentServer1\n          .invoke(invokeAssertVersion(VersionManager.getInstance().getCurrentVersionOrdinal()));\n      currentServer2\n          .invoke(invokeAssertVersion(VersionManager.getInstance().getCurrentVersionOrdinal()));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putAndVerify(objectType, currentServer1, regionName, 0, 10, currentServer2,\n          oldServerAndLocator, oldServer2);\n      putAndVerify(objectType, oldServerAndLocator, regionName, 5, 15, currentServer1,\n          currentServer2, oldServer2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeCloseCache(), currentServer1, currentServer2,\n          oldServerAndLocator, oldServer2);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgrade2DUnitTestBase.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":234,"status":"N"},{"authorDate":"2020-05-29 00:37:39","commitOrder":6,"curCode":"  void doTestQueryMixedServers(boolean partitioned, String oldVersion) throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServer = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServerAndLocator = host.getVM(oldVersion, 3);\n\n    String regionName = \"cqs\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n      invokeRunnableInVMs(invokeCreateCache(props), currentServer1, currentServer2, oldServer);\n\n      currentServer1\n          .invoke(invokeAssertVersion(VersionManager.getInstance().getCurrentVersionOrdinal()));\n      currentServer2\n          .invoke(invokeAssertVersion(VersionManager.getInstance().getCurrentVersionOrdinal()));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServer, oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putDataSerializableAndVerify(currentServer1, regionName, 0, 100, currentServer2, oldServer,\n          oldServerAndLocator);\n      query(\"Select * from \" + SEPARATOR + regionName + \" p where p.timeout > 0L\", 99,\n          currentServer1,\n          currentServer2, oldServer, oldServerAndLocator);\n\n    } finally {\n      invokeRunnableInVMs(invokeCloseCache(), currentServer1, currentServer2, oldServer,\n          oldServerAndLocator);\n    }\n  }\n","date":"2020-05-29 00:37:39","endLine":359,"groupId":"1038","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"doTestQueryMixedServers","params":"(booleanpartitioned@StringoldVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/06/7c8c75c031ffa3d9fbfe1c1f410ec7d36a018d.src","preCode":"  void doTestQueryMixedServers(boolean partitioned, String oldVersion) throws Exception {\n    final Host host = Host.getHost(0);\n    VM currentServer1 = host.getVM(VersionManager.CURRENT_VERSION, 0);\n    VM oldServer = host.getVM(oldVersion, 1);\n    VM currentServer2 = host.getVM(VersionManager.CURRENT_VERSION, 2);\n    VM oldServerAndLocator = host.getVM(oldVersion, 3);\n\n    String regionName = \"cqs\";\n\n    RegionShortcut shortcut = RegionShortcut.REPLICATE;\n    if (partitioned) {\n      shortcut = RegionShortcut.PARTITION;\n    }\n\n    String serverHostName = NetworkUtils.getServerHostName();\n    int port = AvailablePortHelper.getRandomAvailableTCPPort();\n    try {\n      Properties props = getSystemProperties();\n      props.remove(DistributionConfig.LOCATORS_NAME);\n      invokeRunnableInVMs(invokeStartLocatorAndServer(serverHostName, port, props),\n          oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      props.put(DistributionConfig.LOCATORS_NAME, serverHostName + \"[\" + port + \"]\");\n      invokeRunnableInVMs(invokeCreateCache(props), currentServer1, currentServer2, oldServer);\n\n      currentServer1\n          .invoke(invokeAssertVersion(VersionManager.getInstance().getCurrentVersionOrdinal()));\n      currentServer2\n          .invoke(invokeAssertVersion(VersionManager.getInstance().getCurrentVersionOrdinal()));\n\n      \r\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut), currentServer1, currentServer2,\n          oldServer, oldServerAndLocator);\n\n      \r\n      \r\n      oldServerAndLocator.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      putDataSerializableAndVerify(currentServer1, regionName, 0, 100, currentServer2, oldServer,\n          oldServerAndLocator);\n      query(\"Select * from /\" + regionName + \" p where p.timeout > 0L\", 99, currentServer1,\n          currentServer2, oldServer, oldServerAndLocator);\n\n    } finally {\n      invokeRunnableInVMs(invokeCloseCache(), currentServer1, currentServer2, oldServer,\n          oldServerAndLocator);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgrade2DUnitTestBase.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":299,"status":"M"}],"commitId":"0fd56e418752c14ed8ebebe5a370164034aafc39","commitMessage":"@@@GEODE-7846: Replace all uses of hardcoded / with Region.SEPARATOR (#5157)\n\nAuthored-by: Donal Evans <doevans@pivotal.io>","date":"2020-05-29 00:37:39","modifiedFileCount":"489","status":"M","submitter":"Donal Evans"}]
