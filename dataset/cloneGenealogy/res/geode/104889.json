[{"authorTime":"2018-07-18 03:54:18","codes":[{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testRangeQuery() throws Exception {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  distinct p.status  from /pos p  where  p.createTime > 0 AND p.createTime <11 AND  p.ID IN  SET( 0) \"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n    qs.createIndex(\"Status\", IndexType.FUNCTIONAL, \"status\", \"/pos\");\n    qs.createIndex(\"Type\", IndexType.FUNCTIONAL, \"\\\"type\\\"\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true};\n    final boolean[] actualIndexUsed = new boolean[] {false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false};\n    final boolean[] actualProjectionCallback = new boolean[] {false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n    final List indexesUsed = new ArrayList();\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class)};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n        indexesUsed.add(index);\n      }\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n    }\n    assertEquals(indexesUsed.size(), 1);\n    assertEquals(((Index) indexesUsed.iterator().next()).getName(), \"PortFolioID\");\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2018-07-18 03:54:18","endLine":763,"groupId":"5099","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/40/31085d84b8a831198ca195fcea9ff6ba0312fb.src","preCode":"  public void testRangeQuery() throws Exception {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  distinct p.status  from /pos p  where  p.createTime > 0 AND p.createTime <11 AND  p.ID IN  SET( 0) \"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n    qs.createIndex(\"Status\", IndexType.FUNCTIONAL, \"status\", \"/pos\");\n    qs.createIndex(\"Type\", IndexType.FUNCTIONAL, \"\\\"type\\\"\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true};\n    final boolean[] actualIndexUsed = new boolean[] {false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false};\n    final boolean[] actualProjectionCallback = new boolean[] {false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n    final List indexesUsed = new ArrayList();\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class)};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n        indexesUsed.add(index);\n      }\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n    }\n    assertEquals(indexesUsed.size(), 1);\n    assertEquals(((Index) indexesUsed.iterator().next()).getName(), \"PortFolioID\");\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":689,"status":"B"},{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testProjectionEvaluationOnORJunction_NOT_IMPLEMENTED() throws Exception {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 10000; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  distinct p.status  from /pos p  where  p.createTime IN SET( 10l ) OR  p.status IN SET( 'active') OR p.ID >  0\"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n    final List indexUsed = new ArrayList();\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n    qs.createIndex(\"Status\", IndexType.FUNCTIONAL, \"status\", \"/pos\");\n    qs.createIndex(\"Type\", IndexType.FUNCTIONAL, \"\\\"type\\\"\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true};\n    final boolean[] actualIndexUsed = new boolean[] {false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false};\n    final boolean[] actualProjectionCallback = new boolean[] {false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class)};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n        indexUsed.add(index);\n      }\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n    }\n    assertEquals(indexUsed.size(), 3);\n    assertEquals(((Index) indexUsed.iterator().next()).getName(), \"CreateTime\");\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2018-07-18 03:54:18","endLine":1156,"groupId":"10813","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testProjectionEvaluationOnORJunction_NOT_IMPLEMENTED","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/40/31085d84b8a831198ca195fcea9ff6ba0312fb.src","preCode":"  public void testProjectionEvaluationOnORJunction_NOT_IMPLEMENTED() throws Exception {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 10000; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  distinct p.status  from /pos p  where  p.createTime IN SET( 10l ) OR  p.status IN SET( 'active') OR p.ID >  0\"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n    final List indexUsed = new ArrayList();\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n    qs.createIndex(\"Status\", IndexType.FUNCTIONAL, \"status\", \"/pos\");\n    qs.createIndex(\"Type\", IndexType.FUNCTIONAL, \"\\\"type\\\"\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true};\n    final boolean[] actualIndexUsed = new boolean[] {false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false};\n    final boolean[] actualProjectionCallback = new boolean[] {false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class)};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n        indexUsed.add(index);\n      }\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n    }\n    assertEquals(indexUsed.size(), 3);\n    assertEquals(((Index) indexUsed.iterator().next()).getName(), \"CreateTime\");\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":1082,"status":"B"}],"commitId":"cb202f25b93e0a56f4776813da0bf6dcbba231cd","commitMessage":"@@@GEODE-5363: Moves all non-unit tests into specific isolated source sets. (#2126)\n\n* Creates integrationTest source set.\n* Creates distributedTest source set.\n* Creates acceptanceTest source set.\n* Creates uiTest source set.\n* Removes old categories.","date":"2018-07-18 03:54:18","modifiedFileCount":"697","status":"B","submitter":"Jacob Barrett"},{"authorTime":"2019-01-12 07:53:54","codes":[{"authorDate":"2019-01-12 07:53:54","commitOrder":2,"curCode":"  public void testRangeQuery() throws Exception {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  distinct p.status  from /pos p  where  p.createTime > 0 AND p.createTime <11 AND  p.ID IN  SET( 0) \"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n    qs.createIndex(\"Status\", IndexType.FUNCTIONAL, \"status\", \"/pos\");\n    qs.createIndex(\"Type\", IndexType.FUNCTIONAL, \"\\\"type\\\"\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true};\n    final boolean[] actualIndexUsed = new boolean[] {false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false};\n    final boolean[] actualProjectionCallback = new boolean[] {false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n    final List indexesUsed = new ArrayList();\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class)};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      @Override\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      @Override\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n        indexesUsed.add(index);\n      }\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n    }\n    assertEquals(indexesUsed.size(), 1);\n    assertEquals(((Index) indexesUsed.iterator().next()).getName(), \"PortFolioID\");\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2019-01-12 07:53:54","endLine":807,"groupId":"30916","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/65/0f871d11683b4bcdf26d574094790209e53a1a.src","preCode":"  public void testRangeQuery() throws Exception {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  distinct p.status  from /pos p  where  p.createTime > 0 AND p.createTime <11 AND  p.ID IN  SET( 0) \"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n    qs.createIndex(\"Status\", IndexType.FUNCTIONAL, \"status\", \"/pos\");\n    qs.createIndex(\"Type\", IndexType.FUNCTIONAL, \"\\\"type\\\"\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true};\n    final boolean[] actualIndexUsed = new boolean[] {false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false};\n    final boolean[] actualProjectionCallback = new boolean[] {false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n    final List indexesUsed = new ArrayList();\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class)};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n        indexesUsed.add(index);\n      }\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n    }\n    assertEquals(indexesUsed.size(), 1);\n    assertEquals(((Index) indexesUsed.iterator().next()).getName(), \"PortFolioID\");\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":728,"status":"M"},{"authorDate":"2019-01-12 07:53:54","commitOrder":2,"curCode":"  public void testProjectionEvaluationOnORJunction_NOT_IMPLEMENTED() throws Exception {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 10000; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  distinct p.status  from /pos p  where  p.createTime IN SET( 10l ) OR  p.status IN SET( 'active') OR p.ID >  0\"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n    final List indexUsed = new ArrayList();\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n    qs.createIndex(\"Status\", IndexType.FUNCTIONAL, \"status\", \"/pos\");\n    qs.createIndex(\"Type\", IndexType.FUNCTIONAL, \"\\\"type\\\"\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true};\n    final boolean[] actualIndexUsed = new boolean[] {false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false};\n    final boolean[] actualProjectionCallback = new boolean[] {false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class)};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      @Override\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      @Override\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n        indexUsed.add(index);\n      }\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n    }\n    assertEquals(indexUsed.size(), 3);\n    assertEquals(((Index) indexUsed.iterator().next()).getName(), \"CreateTime\");\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2019-01-12 07:53:54","endLine":1226,"groupId":"10813","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testProjectionEvaluationOnORJunction_NOT_IMPLEMENTED","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/65/0f871d11683b4bcdf26d574094790209e53a1a.src","preCode":"  public void testProjectionEvaluationOnORJunction_NOT_IMPLEMENTED() throws Exception {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 10000; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  distinct p.status  from /pos p  where  p.createTime IN SET( 10l ) OR  p.status IN SET( 'active') OR p.ID >  0\"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n    final List indexUsed = new ArrayList();\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n    qs.createIndex(\"Status\", IndexType.FUNCTIONAL, \"status\", \"/pos\");\n    qs.createIndex(\"Type\", IndexType.FUNCTIONAL, \"\\\"type\\\"\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true};\n    final boolean[] actualIndexUsed = new boolean[] {false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false};\n    final boolean[] actualProjectionCallback = new boolean[] {false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class)};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n        indexUsed.add(index);\n      }\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n    }\n    assertEquals(indexUsed.size(), 3);\n    assertEquals(((Index) indexUsed.iterator().next()).getName(), \"CreateTime\");\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":1147,"status":"M"}],"commitId":"9d737c9e95a77cb4db05a258f318908e7899bd6c","commitMessage":"@@@GEODE-4391: Add `@Override` where missing. (#3069)\n\n* GEODE-4391: Add `@Override` where missing.\n\n* Restart Concourse.  I think that was flaky.\n","date":"2019-01-12 07:53:54","modifiedFileCount":"1582","status":"M","submitter":"Galen O'Sullivan"},{"authorTime":"2020-05-29 00:37:39","codes":[{"authorDate":"2020-05-29 00:37:39","commitOrder":3,"curCode":"  public void testRangeQuery() throws Exception {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(SEPARATOR + \"pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  distinct p.status  from \" + SEPARATOR\n            + \"pos p  where  p.createTime > 0 AND p.createTime <11 AND  p.ID IN  SET( 0) \"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", SEPARATOR + \"pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", SEPARATOR + \"pos\");\n    qs.createIndex(\"Status\", IndexType.FUNCTIONAL, \"status\", SEPARATOR + \"pos\");\n    qs.createIndex(\"Type\", IndexType.FUNCTIONAL, \"\\\"type\\\"\", SEPARATOR + \"pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true};\n    final boolean[] actualIndexUsed = new boolean[] {false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false};\n    final boolean[] actualProjectionCallback = new boolean[] {false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n    final List indexesUsed = new ArrayList();\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class)};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      @Override\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      @Override\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n        indexesUsed.add(index);\n      }\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n    }\n    assertEquals(indexesUsed.size(), 1);\n    assertEquals(((Index) indexesUsed.iterator().next()).getName(), \"PortFolioID\");\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2020-05-29 00:37:39","endLine":822,"groupId":"104889","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testRangeQuery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/7c/31e4770cae87e981fc4d9792943d99d9ac61a4.src","preCode":"  public void testRangeQuery() throws Exception {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  distinct p.status  from /pos p  where  p.createTime > 0 AND p.createTime <11 AND  p.ID IN  SET( 0) \"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n    qs.createIndex(\"Status\", IndexType.FUNCTIONAL, \"status\", \"/pos\");\n    qs.createIndex(\"Type\", IndexType.FUNCTIONAL, \"\\\"type\\\"\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true};\n    final boolean[] actualIndexUsed = new boolean[] {false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false};\n    final boolean[] actualProjectionCallback = new boolean[] {false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n    final List indexesUsed = new ArrayList();\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class)};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      @Override\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      @Override\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n        indexesUsed.add(index);\n      }\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n    }\n    assertEquals(indexesUsed.size(), 1);\n    assertEquals(((Index) indexesUsed.iterator().next()).getName(), \"PortFolioID\");\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":742,"status":"M"},{"authorDate":"2020-05-29 00:37:39","commitOrder":3,"curCode":"  public void testProjectionEvaluationOnORJunction_NOT_IMPLEMENTED() throws Exception {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(SEPARATOR + \"pos\");\n    for (int i = 100; i < 10000; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  distinct p.status  from \" + SEPARATOR\n            + \"pos p  where  p.createTime IN SET( 10l ) OR  p.status IN SET( 'active') OR p.ID >  0\"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n    final List indexUsed = new ArrayList();\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", SEPARATOR + \"pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", SEPARATOR + \"pos\");\n    qs.createIndex(\"Status\", IndexType.FUNCTIONAL, \"status\", SEPARATOR + \"pos\");\n    qs.createIndex(\"Type\", IndexType.FUNCTIONAL, \"\\\"type\\\"\", SEPARATOR + \"pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true};\n    final boolean[] actualIndexUsed = new boolean[] {false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false};\n    final boolean[] actualProjectionCallback = new boolean[] {false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class)};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      @Override\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      @Override\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n        indexUsed.add(index);\n      }\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n    }\n    assertEquals(indexUsed.size(), 3);\n    assertEquals(((Index) indexUsed.iterator().next()).getName(), \"CreateTime\");\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2020-05-29 00:37:39","endLine":1246,"groupId":"104889","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testProjectionEvaluationOnORJunction_NOT_IMPLEMENTED","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/7c/31e4770cae87e981fc4d9792943d99d9ac61a4.src","preCode":"  public void testProjectionEvaluationOnORJunction_NOT_IMPLEMENTED() throws Exception {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 10000; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  distinct p.status  from /pos p  where  p.createTime IN SET( 10l ) OR  p.status IN SET( 'active') OR p.ID >  0\"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n    final List indexUsed = new ArrayList();\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n    qs.createIndex(\"Status\", IndexType.FUNCTIONAL, \"status\", \"/pos\");\n    qs.createIndex(\"Type\", IndexType.FUNCTIONAL, \"\\\"type\\\"\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true};\n    final boolean[] actualIndexUsed = new boolean[] {false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false};\n    final boolean[] actualProjectionCallback = new boolean[] {false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class)};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      @Override\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      @Override\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n        indexUsed.add(index);\n      }\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n    }\n    assertEquals(indexUsed.size(), 3);\n    assertEquals(((Index) indexUsed.iterator().next()).getName(), \"CreateTime\");\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":1166,"status":"M"}],"commitId":"0fd56e418752c14ed8ebebe5a370164034aafc39","commitMessage":"@@@GEODE-7846: Replace all uses of hardcoded / with Region.SEPARATOR (#5157)\n\nAuthored-by: Donal Evans <doevans@pivotal.io>","date":"2020-05-29 00:37:39","modifiedFileCount":"489","status":"M","submitter":"Donal Evans"}]
