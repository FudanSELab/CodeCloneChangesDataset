[{"authorTime":"2019-10-10 15:16:44","codes":[{"authorDate":"2019-09-27 07:15:24","commitOrder":6,"curCode":"  public void testQueueNextTasksOnSuccess() throws Exception\n  {\n    supervisor = getTestableSupervisor(2, 2, true, \"PT1H\", null, null);\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID0))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD0_PARTITION))\n            .anyTimes();\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(4);\n    taskRunner.registerListener(EasyMock.anyObject(TaskRunnerListener.class), EasyMock.anyObject(Executor.class));\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\",\n        SHARD_ID0,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints2 = new TreeMap<>();\n    checkpoints2.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(2);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints2))\n            .times(2);\n\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    \r\n    Capture<Task> newTasksCapture = Capture.newInstance(CaptureType.ALL);\n    Capture<String> shutdownTaskIdCapture = Capture.newInstance();\n    List<Task> imStillRunning = tasks.subList(1, 4);\n    KinesisIndexTask iAmSuccess = (KinesisIndexTask) tasks.get(0);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(imStillRunning).anyTimes();\n    for (Task task : imStillRunning) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.expect(taskStorage.getStatus(iAmSuccess.getId()))\n            .andReturn(Optional.of(TaskStatus.success(iAmSuccess.getId())));\n    EasyMock.expect(taskStorage.getTask(iAmSuccess.getId())).andReturn(Optional.of(iAmSuccess)).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(newTasksCapture))).andReturn(true).times(2);\n    EasyMock.expect(taskClient.stopAsync(EasyMock.capture(shutdownTaskIdCapture), EasyMock.eq(false)))\n            .andReturn(Futures.immediateFuture(true));\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskQueue);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    Assert.assertTrue(shutdownTaskIdCapture.getValue().contains(iAmSuccess.getIOConfig().getBaseSequenceName()));\n  }\n","date":"2019-09-27 07:15:24","endLine":1165,"groupId":"2804","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueueNextTasksOnSuccess","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a9/c182bed796859937f9e962860053e662ecf784.src","preCode":"  public void testQueueNextTasksOnSuccess() throws Exception\n  {\n    supervisor = getTestableSupervisor(2, 2, true, \"PT1H\", null, null);\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID0))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD0_PARTITION))\n            .anyTimes();\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(4);\n    taskRunner.registerListener(EasyMock.anyObject(TaskRunnerListener.class), EasyMock.anyObject(Executor.class));\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\",\n        SHARD_ID0,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints2 = new TreeMap<>();\n    checkpoints2.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(2);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints2))\n            .times(2);\n\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    \r\n    Capture<Task> newTasksCapture = Capture.newInstance(CaptureType.ALL);\n    Capture<String> shutdownTaskIdCapture = Capture.newInstance();\n    List<Task> imStillRunning = tasks.subList(1, 4);\n    KinesisIndexTask iAmSuccess = (KinesisIndexTask) tasks.get(0);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(imStillRunning).anyTimes();\n    for (Task task : imStillRunning) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.expect(taskStorage.getStatus(iAmSuccess.getId()))\n            .andReturn(Optional.of(TaskStatus.success(iAmSuccess.getId())));\n    EasyMock.expect(taskStorage.getTask(iAmSuccess.getId())).andReturn(Optional.of(iAmSuccess)).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(newTasksCapture))).andReturn(true).times(2);\n    EasyMock.expect(taskClient.stopAsync(EasyMock.capture(shutdownTaskIdCapture), EasyMock.eq(false)))\n            .andReturn(Futures.immediateFuture(true));\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskQueue);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    Assert.assertTrue(shutdownTaskIdCapture.getValue().contains(iAmSuccess.getIOConfig().getBaseSequenceName()));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1046,"status":"NB"},{"authorDate":"2019-10-10 15:16:44","commitOrder":6,"curCode":"  private List<Task> testShardMergePhaseOne() throws Exception\n  {\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    TreeMap<Integer, Map<String, String>> checkpoints0 = new TreeMap<>();\n    checkpoints0.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID0,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(1);\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    return tasks;\n  }\n","date":"2019-10-10 15:16:44","endLine":4354,"groupId":"2821","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testShardMergePhaseOne","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/6a/8764aee7836c0c90e0633e2d84c1e5767bc0dc.src","preCode":"  private List<Task> testShardMergePhaseOne() throws Exception\n  {\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    TreeMap<Integer, Map<String, String>> checkpoints0 = new TreeMap<>();\n    checkpoints0.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID0,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(1);\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    return tasks;\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":4266,"status":"B"}],"commitId":"0c387c1d47a56b04c60b642958d7de9b625556c5","commitMessage":"@@@Fix Kinesis resharding issues (#8644)\n\n* Fix Kinesis resharding issues\n\n* PR comments\n\n* Adjust metadata error message\n\n* Remove unused method\n\n* Use sha1 for shard id hashing\n\n* Add metadata sanity check.  add comment\n\n* Only use shard ID hashing for group mapping\n\n* Style fix\n\n* Fix unused import\n\n* update comment\n\n* Fix teamcity inspection\n","date":"2019-10-10 15:16:44","modifiedFileCount":"5","status":"M","submitter":"Jonathan Wei"},{"authorTime":"2020-01-28 03:24:29","codes":[{"authorDate":"2020-01-28 03:24:29","commitOrder":7,"curCode":"  public void testQueueNextTasksOnSuccess() throws Exception\n  {\n    supervisor = getTestableSupervisor(2, 2, true, \"PT1H\", null, null);\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID0))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD0_PARTITION))\n            .anyTimes();\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(4);\n    taskRunner.registerListener(EasyMock.anyObject(TaskRunnerListener.class), EasyMock.anyObject(Executor.class));\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\",\n        SHARD_ID0,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints2 = new TreeMap<>();\n    checkpoints2.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(2);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints2))\n            .times(2);\n\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    \r\n    Capture<Task> newTasksCapture = Capture.newInstance(CaptureType.ALL);\n    Capture<String> shutdownTaskIdCapture = Capture.newInstance();\n    List<Task> imStillRunning = tasks.subList(1, 4);\n    KinesisIndexTask iAmSuccess = (KinesisIndexTask) tasks.get(0);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(imStillRunning).anyTimes();\n    for (Task task : imStillRunning) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.expect(taskStorage.getStatus(iAmSuccess.getId()))\n            .andReturn(Optional.of(TaskStatus.success(iAmSuccess.getId())));\n    EasyMock.expect(taskStorage.getTask(iAmSuccess.getId())).andReturn(Optional.of(iAmSuccess)).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(newTasksCapture))).andReturn(true).times(2);\n    EasyMock.expect(taskClient.stopAsync(EasyMock.capture(shutdownTaskIdCapture), EasyMock.eq(false)))\n            .andReturn(Futures.immediateFuture(true));\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskQueue);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    Assert.assertTrue(shutdownTaskIdCapture.getValue().contains(iAmSuccess.getIOConfig().getBaseSequenceName()));\n  }\n","date":"2020-01-28 03:24:29","endLine":1173,"groupId":"2804","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueueNextTasksOnSuccess","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ad/267e8a1eaa52ef1a024b696bf027db057d33b6.src","preCode":"  public void testQueueNextTasksOnSuccess() throws Exception\n  {\n    supervisor = getTestableSupervisor(2, 2, true, \"PT1H\", null, null);\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID0))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD0_PARTITION))\n            .anyTimes();\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(4);\n    taskRunner.registerListener(EasyMock.anyObject(TaskRunnerListener.class), EasyMock.anyObject(Executor.class));\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\",\n        SHARD_ID0,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints2 = new TreeMap<>();\n    checkpoints2.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(2);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints2))\n            .times(2);\n\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    \r\n    Capture<Task> newTasksCapture = Capture.newInstance(CaptureType.ALL);\n    Capture<String> shutdownTaskIdCapture = Capture.newInstance();\n    List<Task> imStillRunning = tasks.subList(1, 4);\n    KinesisIndexTask iAmSuccess = (KinesisIndexTask) tasks.get(0);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(imStillRunning).anyTimes();\n    for (Task task : imStillRunning) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.expect(taskStorage.getStatus(iAmSuccess.getId()))\n            .andReturn(Optional.of(TaskStatus.success(iAmSuccess.getId())));\n    EasyMock.expect(taskStorage.getTask(iAmSuccess.getId())).andReturn(Optional.of(iAmSuccess)).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(newTasksCapture))).andReturn(true).times(2);\n    EasyMock.expect(taskClient.stopAsync(EasyMock.capture(shutdownTaskIdCapture), EasyMock.eq(false)))\n            .andReturn(Futures.immediateFuture(true));\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskQueue);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    Assert.assertTrue(shutdownTaskIdCapture.getValue().contains(iAmSuccess.getIOConfig().getBaseSequenceName()));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1054,"status":"M"},{"authorDate":"2020-01-28 03:24:29","commitOrder":7,"curCode":"  private List<Task> testShardMergePhaseOne() throws Exception\n  {\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    TreeMap<Integer, Map<String, String>> checkpoints0 = new TreeMap<>();\n    checkpoints0.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID0,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(1);\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    return tasks;\n  }\n","date":"2020-01-28 03:24:29","endLine":4287,"groupId":"2821","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testShardMergePhaseOne","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ad/267e8a1eaa52ef1a024b696bf027db057d33b6.src","preCode":"  private List<Task> testShardMergePhaseOne() throws Exception\n  {\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    TreeMap<Integer, Map<String, String>> checkpoints0 = new TreeMap<>();\n    checkpoints0.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID0,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(1);\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    return tasks;\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":4199,"status":"M"}],"commitId":"b9186f8f9ff2ff52aceda42bc5f24ffd47a7d17e","commitMessage":"@@@Reconcile terminology and method naming to 'used/unused segments'; Rename MetadataSegmentManager to MetadataSegmentsManager (#7306)\n\n* Reconcile terminology and method naming to 'used/unused segments'; Don't use terms 'enable/disable data source'; Rename MetadataSegmentManager to MetadataSegments; Make REST API methods which mark segments as used/unused to return server error instead of an empty response in case of error\n\n* Fix brace\n\n* Import order\n\n* Rename withKillDataSourceWhitelist to withSpecificDataSourcesToKill\n\n* Fix tests\n\n* Fix tests by adding proper methods without interval parameters to IndexerMetadataStorageCoordinator instead of hacking with Intervals.ETERNITY\n\n* More aligned names of DruidCoordinatorHelpers.  rename several CoordinatorDynamicConfig parameters\n\n* Rename ClientCompactTaskQuery to ClientCompactionTaskQuery for consistency with CompactionTask; ClientCompactQueryTuningConfig to ClientCompactionTaskQueryTuningConfig\n\n* More variable and method renames\n\n* Rename MetadataSegments to SegmentsMetadata\n\n* Javadoc update\n\n* Simplify SegmentsMetadata.getUnusedSegmentIntervals().  more javadocs\n\n* Update Javadoc of VersionedIntervalTimeline.iterateAllObjects()\n\n* Reorder imports\n\n* Rename SegmentsMetadata.tryMark... methods to mark... and make them to return boolean and the numbers of segments changed and relay exceptions to callers\n\n* Complete merge\n\n* Add CollectionUtils.newTreeSet(); Refactor DruidCoordinatorRuntimeParams creation in tests\n\n* Remove MetadataSegmentManager\n\n* Rename millisLagSinceCoordinatorBecomesLeaderBeforeCanMarkAsUnusedOvershadowedSegments to leadingTimeMillisBeforeCanMarkAsUnusedOvershadowedSegments\n\n* Fix tests.  refactor DruidCluster creation in tests into DruidClusterBuilder\n\n* Fix inspections\n\n* Fix SQLMetadataSegmentManagerEmptyTest and rename it to SqlSegmentsMetadataEmptyTest\n\n* Rename SegmentsAndMetadata to SegmentsAndCommitMetadata to reduce the similarity with SegmentsMetadata; Rename some methods\n\n* Rename DruidCoordinatorHelper to CoordinatorDuty.  refactor DruidCoordinator\n\n* Unused import\n\n* Optimize imports\n\n* Rename IndexerSQLMetadataStorageCoordinator.getDataSourceMetadata() to retrieveDataSourceMetadata()\n\n* Unused import\n\n* Update terminology in datasource-view.tsx\n\n* Fix label in datasource-view.spec.tsx.snap\n\n* Fix lint errors in datasource-view.tsx\n\n* Doc improvements\n\n* Another attempt to please TSLint\n\n* Another attempt to please TSLint\n\n* Style fixes\n\n* Fix IndexerSQLMetadataStorageCoordinator.createUsedSegmentsSqlQueryForIntervals() (wrong merge)\n\n* Try to fix docs build issue\n\n* Javadoc and spelling fixes\n\n* Rename SegmentsMetadata to SegmentsMetadataManager.  address other comments\n\n* Address more comments\n","date":"2020-01-28 03:24:29","modifiedFileCount":"127","status":"M","submitter":"Roman Leventov"},{"authorTime":"2020-03-17 12:39:53","codes":[{"authorDate":"2020-03-17 12:39:53","commitOrder":8,"curCode":"  public void testQueueNextTasksOnSuccess() throws Exception\n  {\n    supervisor = getTestableSupervisor(2, 2, true, \"PT1H\", null, null);\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID0))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD0_PARTITION))\n            .anyTimes();\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionTimeLag(EasyMock.anyObject()))\n            .andReturn(TIME_LAG)\n            .atLeastOnce();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(4);\n    taskRunner.registerListener(EasyMock.anyObject(TaskRunnerListener.class), EasyMock.anyObject(Executor.class));\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\",\n        SHARD_ID0,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints2 = new TreeMap<>();\n    checkpoints2.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(2);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints2))\n            .times(2);\n\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    \r\n    Capture<Task> newTasksCapture = Capture.newInstance(CaptureType.ALL);\n    Capture<String> shutdownTaskIdCapture = Capture.newInstance();\n    List<Task> imStillRunning = tasks.subList(1, 4);\n    KinesisIndexTask iAmSuccess = (KinesisIndexTask) tasks.get(0);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(imStillRunning).anyTimes();\n    for (Task task : imStillRunning) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.expect(taskStorage.getStatus(iAmSuccess.getId()))\n            .andReturn(Optional.of(TaskStatus.success(iAmSuccess.getId())));\n    EasyMock.expect(taskStorage.getTask(iAmSuccess.getId())).andReturn(Optional.of(iAmSuccess)).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(newTasksCapture))).andReturn(true).times(2);\n    EasyMock.expect(taskClient.stopAsync(EasyMock.capture(shutdownTaskIdCapture), EasyMock.eq(false)))\n            .andReturn(Futures.immediateFuture(true));\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskQueue);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    Assert.assertTrue(shutdownTaskIdCapture.getValue().contains(iAmSuccess.getIOConfig().getBaseSequenceName()));\n  }\n","date":"2020-03-17 12:39:53","endLine":1206,"groupId":"2804","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueueNextTasksOnSuccess","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/94/ca6bf693b0f756794d2354302ba22e8b2b1d8f.src","preCode":"  public void testQueueNextTasksOnSuccess() throws Exception\n  {\n    supervisor = getTestableSupervisor(2, 2, true, \"PT1H\", null, null);\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID0))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD0_PARTITION))\n            .anyTimes();\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(4);\n    taskRunner.registerListener(EasyMock.anyObject(TaskRunnerListener.class), EasyMock.anyObject(Executor.class));\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\",\n        SHARD_ID0,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints2 = new TreeMap<>();\n    checkpoints2.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(2);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints2))\n            .times(2);\n\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    \r\n    Capture<Task> newTasksCapture = Capture.newInstance(CaptureType.ALL);\n    Capture<String> shutdownTaskIdCapture = Capture.newInstance();\n    List<Task> imStillRunning = tasks.subList(1, 4);\n    KinesisIndexTask iAmSuccess = (KinesisIndexTask) tasks.get(0);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(imStillRunning).anyTimes();\n    for (Task task : imStillRunning) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.expect(taskStorage.getStatus(iAmSuccess.getId()))\n            .andReturn(Optional.of(TaskStatus.success(iAmSuccess.getId())));\n    EasyMock.expect(taskStorage.getTask(iAmSuccess.getId())).andReturn(Optional.of(iAmSuccess)).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(newTasksCapture))).andReturn(true).times(2);\n    EasyMock.expect(taskClient.stopAsync(EasyMock.capture(shutdownTaskIdCapture), EasyMock.eq(false)))\n            .andReturn(Futures.immediateFuture(true));\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskQueue);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    Assert.assertTrue(shutdownTaskIdCapture.getValue().contains(iAmSuccess.getIOConfig().getBaseSequenceName()));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1084,"status":"M"},{"authorDate":"2020-03-17 12:39:53","commitOrder":8,"curCode":"  private List<Task> testShardMergePhaseOne() throws Exception\n  {\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionTimeLag(EasyMock.anyObject()))\n            .andReturn(TIME_LAG)\n            .atLeastOnce();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    TreeMap<Integer, Map<String, String>> checkpoints0 = new TreeMap<>();\n    checkpoints0.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID0,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(1);\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    return tasks;\n  }\n","date":"2020-03-17 12:39:53","endLine":4386,"groupId":"2821","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testShardMergePhaseOne","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/94/ca6bf693b0f756794d2354302ba22e8b2b1d8f.src","preCode":"  private List<Task> testShardMergePhaseOne() throws Exception\n  {\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    TreeMap<Integer, Map<String, String>> checkpoints0 = new TreeMap<>();\n    checkpoints0.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID0,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(1);\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    return tasks;\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":4295,"status":"M"}],"commitId":"142742f291daaf1ac9afea319cacbbe2a3077952","commitMessage":"@@@add kinesis lag metric (#9509)\n\n* add kinesis lag metric\n\n* fixes\n\n* heh\n\n* do it right this time\n\n* more test\n\n* split out supervisor report lags into lagMillis.  remove latest offsets from kinesis supervisor report since always null.  review stuffs","date":"2020-03-17 12:39:53","modifiedFileCount":"17","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-05-17 05:09:39","codes":[{"authorDate":"2020-05-17 05:09:39","commitOrder":9,"curCode":"  public void testQueueNextTasksOnSuccess() throws Exception\n  {\n    supervisor = getTestableSupervisor(2, 2, true, \"PT1H\", null, null);\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID0))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD0_PARTITION))\n            .anyTimes();\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(4);\n    taskRunner.registerListener(EasyMock.anyObject(TaskRunnerListener.class), EasyMock.anyObject(Executor.class));\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\",\n        SHARD_ID0,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints2 = new TreeMap<>();\n    checkpoints2.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(2);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints2))\n            .times(2);\n\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    \r\n    Capture<Task> newTasksCapture = Capture.newInstance(CaptureType.ALL);\n    Capture<String> shutdownTaskIdCapture = Capture.newInstance();\n    List<Task> imStillRunning = tasks.subList(1, 4);\n    KinesisIndexTask iAmSuccess = (KinesisIndexTask) tasks.get(0);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(imStillRunning).anyTimes();\n    for (Task task : imStillRunning) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.expect(taskStorage.getStatus(iAmSuccess.getId()))\n            .andReturn(Optional.of(TaskStatus.success(iAmSuccess.getId())));\n    EasyMock.expect(taskStorage.getTask(iAmSuccess.getId())).andReturn(Optional.of(iAmSuccess)).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(newTasksCapture))).andReturn(true).times(2);\n    EasyMock.expect(taskClient.stopAsync(EasyMock.capture(shutdownTaskIdCapture), EasyMock.eq(false)))\n            .andReturn(Futures.immediateFuture(true));\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskQueue);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    Assert.assertTrue(shutdownTaskIdCapture.getValue().contains(iAmSuccess.getIOConfig().getBaseSequenceName()));\n  }\n","date":"2020-05-17 05:09:39","endLine":1235,"groupId":"2804","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueueNextTasksOnSuccess","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f3/a21d9b2278abf9369dd4760fda54ee8e78a8af.src","preCode":"  public void testQueueNextTasksOnSuccess() throws Exception\n  {\n    supervisor = getTestableSupervisor(2, 2, true, \"PT1H\", null, null);\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID0))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD0_PARTITION))\n            .anyTimes();\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionTimeLag(EasyMock.anyObject()))\n            .andReturn(TIME_LAG)\n            .atLeastOnce();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(4);\n    taskRunner.registerListener(EasyMock.anyObject(TaskRunnerListener.class), EasyMock.anyObject(Executor.class));\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\",\n        SHARD_ID0,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints2 = new TreeMap<>();\n    checkpoints2.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(2);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints2))\n            .times(2);\n\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    \r\n    Capture<Task> newTasksCapture = Capture.newInstance(CaptureType.ALL);\n    Capture<String> shutdownTaskIdCapture = Capture.newInstance();\n    List<Task> imStillRunning = tasks.subList(1, 4);\n    KinesisIndexTask iAmSuccess = (KinesisIndexTask) tasks.get(0);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(imStillRunning).anyTimes();\n    for (Task task : imStillRunning) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.expect(taskStorage.getStatus(iAmSuccess.getId()))\n            .andReturn(Optional.of(TaskStatus.success(iAmSuccess.getId())));\n    EasyMock.expect(taskStorage.getTask(iAmSuccess.getId())).andReturn(Optional.of(iAmSuccess)).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(newTasksCapture))).andReturn(true).times(2);\n    EasyMock.expect(taskClient.stopAsync(EasyMock.capture(shutdownTaskIdCapture), EasyMock.eq(false)))\n            .andReturn(Futures.immediateFuture(true));\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskQueue);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    Assert.assertTrue(shutdownTaskIdCapture.getValue().contains(iAmSuccess.getIOConfig().getBaseSequenceName()));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1116,"status":"M"},{"authorDate":"2020-05-17 05:09:39","commitOrder":9,"curCode":"  private List<Task> testShardMergePhaseOne() throws Exception\n  {\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    TreeMap<Integer, Map<String, String>> checkpoints0 = new TreeMap<>();\n    checkpoints0.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID0,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(1);\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    return tasks;\n  }\n","date":"2020-05-17 05:09:39","endLine":4365,"groupId":"2821","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testShardMergePhaseOne","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f3/a21d9b2278abf9369dd4760fda54ee8e78a8af.src","preCode":"  private List<Task> testShardMergePhaseOne() throws Exception\n  {\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionTimeLag(EasyMock.anyObject()))\n            .andReturn(TIME_LAG)\n            .atLeastOnce();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    TreeMap<Integer, Map<String, String>> checkpoints0 = new TreeMap<>();\n    checkpoints0.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID0,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(1);\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    return tasks;\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":4277,"status":"M"}],"commitId":"2e9548d93d5a27e824cc93293e1de55af63d158f","commitMessage":"@@@refactor SeekableStreamSupervisor usage of RecordSupplier (#9819)\n\n* refactor SeekableStreamSupervisor usage of RecordSupplier to reduce contention between background threads and main thread.  refactor KinesisRecordSupplier.  refactor Kinesis lag metric collection and emitting\n\n* fix style and test\n\n* cleanup.  refactor.  javadocs.  test\n\n* fixes\n\n* keep collecting current offsets and lag if unhealthy in background reporting thread\n\n* review stuffs\n\n* add comment","date":"2020-05-17 05:09:39","modifiedFileCount":"13","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-06-19 00:47:07","codes":[{"authorDate":"2020-06-19 00:47:07","commitOrder":10,"curCode":"  public void testQueueNextTasksOnSuccess() throws Exception\n  {\n    supervisor = getTestableSupervisor(2, 2, true, \"PT1H\", null, null);\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID0))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD0_PARTITION))\n            .anyTimes();\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.emptyList()).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(4);\n    taskRunner.registerListener(EasyMock.anyObject(TaskRunnerListener.class), EasyMock.anyObject(Executor.class));\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\",\n        SHARD_ID0,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints2 = new TreeMap<>();\n    checkpoints2.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(2);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints2))\n            .times(2);\n\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    \r\n    Capture<Task> newTasksCapture = Capture.newInstance(CaptureType.ALL);\n    Capture<String> shutdownTaskIdCapture = Capture.newInstance();\n    List<Task> imStillRunning = tasks.subList(1, 4);\n    KinesisIndexTask iAmSuccess = (KinesisIndexTask) tasks.get(0);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(imStillRunning).anyTimes();\n    for (Task task : imStillRunning) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.expect(taskStorage.getStatus(iAmSuccess.getId()))\n            .andReturn(Optional.of(TaskStatus.success(iAmSuccess.getId())));\n    EasyMock.expect(taskStorage.getTask(iAmSuccess.getId())).andReturn(Optional.of(iAmSuccess)).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(newTasksCapture))).andReturn(true).times(2);\n    EasyMock.expect(taskClient.stopAsync(EasyMock.capture(shutdownTaskIdCapture), EasyMock.eq(false)))\n            .andReturn(Futures.immediateFuture(true));\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskQueue);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    Assert.assertTrue(shutdownTaskIdCapture.getValue().contains(iAmSuccess.getIOConfig().getBaseSequenceName()));\n  }\n","date":"2020-06-19 00:47:07","endLine":1235,"groupId":"102302","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueueNextTasksOnSuccess","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/6b/d309c8b7d36589c3bce8ef8067d38a0e5f58d2.src","preCode":"  public void testQueueNextTasksOnSuccess() throws Exception\n  {\n    supervisor = getTestableSupervisor(2, 2, true, \"PT1H\", null, null);\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID0))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD0_PARTITION))\n            .anyTimes();\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(4);\n    taskRunner.registerListener(EasyMock.anyObject(TaskRunnerListener.class), EasyMock.anyObject(Executor.class));\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\",\n        SHARD_ID0,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints2 = new TreeMap<>();\n    checkpoints2.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(2);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints2))\n            .times(2);\n\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    \r\n    Capture<Task> newTasksCapture = Capture.newInstance(CaptureType.ALL);\n    Capture<String> shutdownTaskIdCapture = Capture.newInstance();\n    List<Task> imStillRunning = tasks.subList(1, 4);\n    KinesisIndexTask iAmSuccess = (KinesisIndexTask) tasks.get(0);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(imStillRunning).anyTimes();\n    for (Task task : imStillRunning) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.expect(taskStorage.getStatus(iAmSuccess.getId()))\n            .andReturn(Optional.of(TaskStatus.success(iAmSuccess.getId())));\n    EasyMock.expect(taskStorage.getTask(iAmSuccess.getId())).andReturn(Optional.of(iAmSuccess)).anyTimes();\n    EasyMock.expect(taskQueue.add(EasyMock.capture(newTasksCapture))).andReturn(true).times(2);\n    EasyMock.expect(taskClient.stopAsync(EasyMock.capture(shutdownTaskIdCapture), EasyMock.eq(false)))\n            .andReturn(Futures.immediateFuture(true));\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskQueue);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    Assert.assertTrue(shutdownTaskIdCapture.getValue().contains(iAmSuccess.getIOConfig().getBaseSequenceName()));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1116,"status":"M"},{"authorDate":"2020-06-19 00:47:07","commitOrder":10,"curCode":"  private List<Task> testShardMergePhaseOne() throws Exception\n  {\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.emptyList()).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    TreeMap<Integer, Map<String, String>> checkpoints0 = new TreeMap<>();\n    checkpoints0.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID0,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(1);\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    return tasks;\n  }\n","date":"2020-06-19 00:47:07","endLine":4365,"groupId":"102302","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testShardMergePhaseOne","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/6b/d309c8b7d36589c3bce8ef8067d38a0e5f58d2.src","preCode":"  private List<Task> testShardMergePhaseOne() throws Exception\n  {\n    supervisorRecordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(EasyMock.anyObject())).andReturn(\"100\").anyTimes();\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> captured = Capture.newInstance(CaptureType.ALL);\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            null\n        )\n    ).anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(captured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.start();\n    supervisor.runInternal();\n    verifyAll();\n\n    List<Task> tasks = captured.getValues();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    TreeMap<Integer, Map<String, String>> checkpoints0 = new TreeMap<>();\n    checkpoints0.put(0, ImmutableMap.of(\n        SHARD_ID1,\n        \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpoints1 = new TreeMap<>();\n    checkpoints1.put(0, ImmutableMap.of(\n        SHARD_ID0,\n        \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpoints1))\n            .times(1);\n\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(tasks).anyTimes();\n    for (Task task : tasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    return tasks;\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":4277,"status":"M"}],"commitId":"2c384b61ff47f858a0adb6f8b389c84f2acc84d1","commitMessage":"@@@IntelliJ inspection and checkstyle rule for \"Collection.EMPTY_* field accesses replaceable with Collections.empty*()\" (#9690)\n\n* IntelliJ inspection and checkstyle rule for \"Collection.EMPTY_* field accesses replaceable with Collections.empty*()\"\n\n* Reverted checkstyle rule\n\n* Added tests to pass CI\n\n* Codestyle","date":"2020-06-19 00:47:07","modifiedFileCount":"33","status":"M","submitter":"Aleksey Plekhanov"}]
