[{"authorTime":"2017-05-19 14:52:34","codes":[{"authorDate":"2017-05-10 11:28:26","commitOrder":2,"curCode":"  @Test public void testMatchRecognizeSubset2() {\n    final String sql = \"select *\\n\"\n        + \"  from t match_recognize\\n\"\n        + \"  (\\n\"\n        + \"   measures STRT.ts as start_ts,\"\n        + \"   LAST(DOWN.ts) as bottom_ts,\"\n        + \"   AVG(stdn.price) as stdn_avg\"\n        + \"    pattern (strt down+ up+)\\n\"\n        + \"    subset stdn = (strt, down)\\n\"\n        + \"    define\\n\"\n        + \"      down as down.price < PREV(down.price),\\n\"\n        + \"      up as up.price > prev(up.price)\\n\"\n        + \"  ) mr\";\n    final String expected = \"SELECT *\\n\"\n        + \"FROM `T` MATCH_RECOGNIZE(\\n\"\n        + \"MEASURES `STRT`.`TS` AS `START_TS`, \"\n        + \"LAST(`DOWN`.`TS`, 0) AS `BOTTOM_TS`, \"\n        + \"AVG(`STDN`.`PRICE`) AS `STDN_AVG`\\n\"\n        + \"PATTERN (((`STRT` (`DOWN` +)) (`UP` +)))\\n\"\n        + \"SUBSET (`STDN` = (`STRT`, `DOWN`))\\n\"\n        + \"DEFINE `DOWN` AS (`DOWN`.`PRICE` < PREV(`DOWN`.`PRICE`, 1)), \"\n        + \"`UP` AS (`UP`.`PRICE` > PREV(`UP`.`PRICE`, 1))\"\n        + \") AS `MR`\";\n    sql(sql).ok(expected);\n  }\n","date":"2017-05-16 10:33:38","endLine":7806,"groupId":"9095","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchRecognizeSubset2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d6/e8d759409c7f5fa65b969c8931aad3cfe3d86e.src","preCode":"  @Test public void testMatchRecognizeSubset2() {\n    final String sql = \"select *\\n\"\n        + \"  from t match_recognize\\n\"\n        + \"  (\\n\"\n        + \"   measures STRT.ts as start_ts,\"\n        + \"   LAST(DOWN.ts) as bottom_ts,\"\n        + \"   AVG(stdn.price) as stdn_avg\"\n        + \"    pattern (strt down+ up+)\\n\"\n        + \"    subset stdn = (strt, down)\\n\"\n        + \"    define\\n\"\n        + \"      down as down.price < PREV(down.price),\\n\"\n        + \"      up as up.price > prev(up.price)\\n\"\n        + \"  ) mr\";\n    final String expected = \"SELECT *\\n\"\n        + \"FROM `T` MATCH_RECOGNIZE(\\n\"\n        + \"MEASURES `STRT`.`TS` AS `START_TS`, \"\n        + \"LAST(`DOWN`.`TS`, 0) AS `BOTTOM_TS`, \"\n        + \"AVG(`STDN`.`PRICE`) AS `STDN_AVG`\\n\"\n        + \"PATTERN (((`STRT` (`DOWN` +)) (`UP` +)))\\n\"\n        + \"SUBSET (`STDN` = (`STRT`, `DOWN`))\\n\"\n        + \"DEFINE `DOWN` AS (`DOWN`.`PRICE` < PREV(`DOWN`.`PRICE`, 1)), \"\n        + \"`UP` AS (`UP`.`PRICE` > PREV(`UP`.`PRICE`, 1))\"\n        + \") AS `MR`\";\n    sql(sql).ok(expected);\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":7782,"status":"NB"},{"authorDate":"2017-05-19 14:52:34","commitOrder":2,"curCode":"  @Test public void testMatchRecognizeRowsPerMatch2() {\n    final String sql = \"select *\\n\"\n        + \"  from t match_recognize\\n\"\n        + \"  (\\n\"\n        + \"   measures STRT.ts as start_ts,\"\n        + \"   LAST(DOWN.ts) as bottom_ts,\"\n        + \"   AVG(stdn.price) as stdn_avg\"\n        + \"   ALL ROWS PER MATCH\"\n        + \"    pattern (strt down+ up+)\\n\"\n        + \"    subset stdn = (strt, down), stdn2 = (strt, down)\\n\"\n        + \"    define\\n\"\n        + \"      down as down.price < PREV(down.price),\\n\"\n        + \"      up as up.price > prev(up.price)\\n\"\n        + \"  ) mr\";\n    final String expected = \"SELECT *\\n\"\n        + \"FROM `T` MATCH_RECOGNIZE(\\n\"\n        + \"MEASURES `STRT`.`TS` AS `START_TS`, \"\n        + \"LAST(`DOWN`.`TS`, 0) AS `BOTTOM_TS`, \"\n        + \"AVG(`STDN`.`PRICE`) AS `STDN_AVG`\\n\"\n        + \"ALL ROWS PER MATCH\\n\"\n        + \"PATTERN (((`STRT` (`DOWN` +)) (`UP` +)))\\n\"\n        + \"SUBSET (`STDN` = (`STRT`, `DOWN`)), (`STDN2` = (`STRT`, `DOWN`))\\n\"\n        + \"DEFINE `DOWN` AS (`DOWN`.`PRICE` < PREV(`DOWN`.`PRICE`, 1)), \"\n        + \"`UP` AS (`UP`.`PRICE` > PREV(`UP`.`PRICE`, 1))\"\n        + \") AS `MR`\";\n    sql(sql).ok(expected);\n  }\n","date":"2017-05-24 02:28:41","endLine":7888,"groupId":"16855","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMatchRecognizeRowsPerMatch2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/bb/74daac0265cee44fab84dfc3034ddc293707ec.src","preCode":"  @Test public void testMatchRecognizeRowsPerMatch2() {\n    final String sql = \"select *\\n\"\n        + \"  from t match_recognize\\n\"\n        + \"  (\\n\"\n        + \"   measures STRT.ts as start_ts,\"\n        + \"   LAST(DOWN.ts) as bottom_ts,\"\n        + \"   AVG(stdn.price) as stdn_avg\"\n        + \"   ALL ROWS PER MATCH\"\n        + \"    pattern (strt down+ up+)\\n\"\n        + \"    subset stdn = (strt, down), stdn2 = (strt, down)\\n\"\n        + \"    define\\n\"\n        + \"      down as down.price < PREV(down.price),\\n\"\n        + \"      up as up.price > prev(up.price)\\n\"\n        + \"  ) mr\";\n    final String expected = \"SELECT *\\n\"\n        + \"FROM `T` MATCH_RECOGNIZE(\\n\"\n        + \"MEASURES `STRT`.`TS` AS `START_TS`, \"\n        + \"LAST(`DOWN`.`TS`, 0) AS `BOTTOM_TS`, \"\n        + \"AVG(`STDN`.`PRICE`) AS `STDN_AVG`\\n\"\n        + \"ALL ROWS PER MATCH\\n\"\n        + \"PATTERN (((`STRT` (`DOWN` +)) (`UP` +)))\\n\"\n        + \"SUBSET (`STDN` = (`STRT`, `DOWN`)), (`STDN2` = (`STRT`, `DOWN`))\\n\"\n        + \"DEFINE `DOWN` AS (`DOWN`.`PRICE` < PREV(`DOWN`.`PRICE`, 1)), \"\n        + \"`UP` AS (`UP`.`PRICE` > PREV(`UP`.`PRICE`, 1))\"\n        + \") AS `MR`\";\n    sql(sql).ok(expected);\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":7862,"status":"B"}],"commitId":"e117c10cef192ca4ab10ffec2132b7dbd34319fa","commitMessage":"@@@[CALCITE-1645] In MATCH_RECOGNIZE clause.  support ONE ROW PER MATCH and ALL ROWS PER MATCH (Zhiqiang-He)\n\nClose apache/calcite#452\n","date":"2017-05-24 02:28:41","modifiedFileCount":"9","status":"M","submitter":"Zhiqiang-He"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":3,"curCode":"  @Test void testMatchRecognizeSubset2() {\n    final String sql = \"select *\\n\"\n        + \"  from t match_recognize\\n\"\n        + \"  (\\n\"\n        + \"   measures STRT.ts as start_ts,\"\n        + \"   LAST(DOWN.ts) as bottom_ts,\"\n        + \"   AVG(stdn.price) as stdn_avg\"\n        + \"    pattern (strt down+ up+)\\n\"\n        + \"    subset stdn = (strt, down)\\n\"\n        + \"    define\\n\"\n        + \"      down as down.price < PREV(down.price),\\n\"\n        + \"      up as up.price > prev(up.price)\\n\"\n        + \"  ) mr\";\n    final String expected = \"SELECT *\\n\"\n        + \"FROM `T` MATCH_RECOGNIZE(\\n\"\n        + \"MEASURES `STRT`.`TS` AS `START_TS`, \"\n        + \"LAST(`DOWN`.`TS`, 0) AS `BOTTOM_TS`, \"\n        + \"AVG(`STDN`.`PRICE`) AS `STDN_AVG`\\n\"\n        + \"PATTERN (((`STRT` (`DOWN` +)) (`UP` +)))\\n\"\n        + \"SUBSET (`STDN` = (`STRT`, `DOWN`))\\n\"\n        + \"DEFINE `DOWN` AS (`DOWN`.`PRICE` < PREV(`DOWN`.`PRICE`, 1)), \"\n        + \"`UP` AS (`UP`.`PRICE` > PREV(`UP`.`PRICE`, 1))\"\n        + \") AS `MR`\";\n    sql(sql).ok(expected);\n  }\n","date":"2020-04-06 04:57:49","endLine":8171,"groupId":"10925","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchRecognizeSubset2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/df/6c18087114449f5c2ca4ff32ab24aa6a84eed3.src","preCode":"  @Test public void testMatchRecognizeSubset2() {\n    final String sql = \"select *\\n\"\n        + \"  from t match_recognize\\n\"\n        + \"  (\\n\"\n        + \"   measures STRT.ts as start_ts,\"\n        + \"   LAST(DOWN.ts) as bottom_ts,\"\n        + \"   AVG(stdn.price) as stdn_avg\"\n        + \"    pattern (strt down+ up+)\\n\"\n        + \"    subset stdn = (strt, down)\\n\"\n        + \"    define\\n\"\n        + \"      down as down.price < PREV(down.price),\\n\"\n        + \"      up as up.price > prev(up.price)\\n\"\n        + \"  ) mr\";\n    final String expected = \"SELECT *\\n\"\n        + \"FROM `T` MATCH_RECOGNIZE(\\n\"\n        + \"MEASURES `STRT`.`TS` AS `START_TS`, \"\n        + \"LAST(`DOWN`.`TS`, 0) AS `BOTTOM_TS`, \"\n        + \"AVG(`STDN`.`PRICE`) AS `STDN_AVG`\\n\"\n        + \"PATTERN (((`STRT` (`DOWN` +)) (`UP` +)))\\n\"\n        + \"SUBSET (`STDN` = (`STRT`, `DOWN`))\\n\"\n        + \"DEFINE `DOWN` AS (`DOWN`.`PRICE` < PREV(`DOWN`.`PRICE`, 1)), \"\n        + \"`UP` AS (`UP`.`PRICE` > PREV(`UP`.`PRICE`, 1))\"\n        + \") AS `MR`\";\n    sql(sql).ok(expected);\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":8147,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":3,"curCode":"  @Test void testMatchRecognizeRowsPerMatch2() {\n    final String sql = \"select *\\n\"\n        + \"  from t match_recognize\\n\"\n        + \"  (\\n\"\n        + \"   measures STRT.ts as start_ts,\"\n        + \"   LAST(DOWN.ts) as bottom_ts,\"\n        + \"   AVG(stdn.price) as stdn_avg\"\n        + \"   ALL ROWS PER MATCH\"\n        + \"    pattern (strt down+ up+)\\n\"\n        + \"    subset stdn = (strt, down), stdn2 = (strt, down)\\n\"\n        + \"    define\\n\"\n        + \"      down as down.price < PREV(down.price),\\n\"\n        + \"      up as up.price > prev(up.price)\\n\"\n        + \"  ) mr\";\n    final String expected = \"SELECT *\\n\"\n        + \"FROM `T` MATCH_RECOGNIZE(\\n\"\n        + \"MEASURES `STRT`.`TS` AS `START_TS`, \"\n        + \"LAST(`DOWN`.`TS`, 0) AS `BOTTOM_TS`, \"\n        + \"AVG(`STDN`.`PRICE`) AS `STDN_AVG`\\n\"\n        + \"ALL ROWS PER MATCH\\n\"\n        + \"PATTERN (((`STRT` (`DOWN` +)) (`UP` +)))\\n\"\n        + \"SUBSET (`STDN` = (`STRT`, `DOWN`)), (`STDN2` = (`STRT`, `DOWN`))\\n\"\n        + \"DEFINE `DOWN` AS (`DOWN`.`PRICE` < PREV(`DOWN`.`PRICE`, 1)), \"\n        + \"`UP` AS (`UP`.`PRICE` > PREV(`UP`.`PRICE`, 1))\"\n        + \") AS `MR`\";\n    sql(sql).ok(expected);\n  }\n","date":"2020-04-06 04:57:49","endLine":8253,"groupId":"10925","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testMatchRecognizeRowsPerMatch2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/df/6c18087114449f5c2ca4ff32ab24aa6a84eed3.src","preCode":"  @Test public void testMatchRecognizeRowsPerMatch2() {\n    final String sql = \"select *\\n\"\n        + \"  from t match_recognize\\n\"\n        + \"  (\\n\"\n        + \"   measures STRT.ts as start_ts,\"\n        + \"   LAST(DOWN.ts) as bottom_ts,\"\n        + \"   AVG(stdn.price) as stdn_avg\"\n        + \"   ALL ROWS PER MATCH\"\n        + \"    pattern (strt down+ up+)\\n\"\n        + \"    subset stdn = (strt, down), stdn2 = (strt, down)\\n\"\n        + \"    define\\n\"\n        + \"      down as down.price < PREV(down.price),\\n\"\n        + \"      up as up.price > prev(up.price)\\n\"\n        + \"  ) mr\";\n    final String expected = \"SELECT *\\n\"\n        + \"FROM `T` MATCH_RECOGNIZE(\\n\"\n        + \"MEASURES `STRT`.`TS` AS `START_TS`, \"\n        + \"LAST(`DOWN`.`TS`, 0) AS `BOTTOM_TS`, \"\n        + \"AVG(`STDN`.`PRICE`) AS `STDN_AVG`\\n\"\n        + \"ALL ROWS PER MATCH\\n\"\n        + \"PATTERN (((`STRT` (`DOWN` +)) (`UP` +)))\\n\"\n        + \"SUBSET (`STDN` = (`STRT`, `DOWN`)), (`STDN2` = (`STRT`, `DOWN`))\\n\"\n        + \"DEFINE `DOWN` AS (`DOWN`.`PRICE` < PREV(`DOWN`.`PRICE`, 1)), \"\n        + \"`UP` AS (`UP`.`PRICE` > PREV(`UP`.`PRICE`, 1))\"\n        + \") AS `MR`\";\n    sql(sql).ok(expected);\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":8227,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"}]
