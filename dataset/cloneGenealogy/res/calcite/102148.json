[{"authorTime":"2014-11-14 10:11:34","codes":[{"authorDate":"2014-11-14 10:11:34","commitOrder":1,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression unionExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (unionExp == null) {\n        unionExp = childExp;\n      } else {\n        unionExp =\n            Expressions.call(\n                unionExp,\n                all\n                    ? BuiltInMethod.CONCAT.method\n                    : BuiltInMethod.UNION.method,\n                childExp);\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(unionExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2014-11-14 10:22:06","endLine":79,"groupId":"10296","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/51/62701fa07d58025d286b433832697796741194.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression unionExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (unionExp == null) {\n        unionExp = childExp;\n      } else {\n        unionExp =\n            Expressions.call(\n                unionExp,\n                all\n                    ? BuiltInMethod.CONCAT.method\n                    : BuiltInMethod.UNION.method,\n                childExp);\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(unionExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUnion.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"B"},{"authorDate":"2014-11-14 10:11:34","commitOrder":1,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(\n                intersectExp,\n                all\n                    ? BuiltInMethod.CONCAT.method\n                    : BuiltInMethod.INTERSECT.method,\n                childExp);\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2014-11-14 10:22:06","endLine":80,"groupId":"14617","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6c/74c17174c79ba43836be5fb824bf2e0de78301.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(\n                intersectExp,\n                all\n                    ? BuiltInMethod.CONCAT.method\n                    : BuiltInMethod.INTERSECT.method,\n                childExp);\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableIntersect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"B"}],"commitId":"a0ba73cd2de76696b96a1cd828d2aa4d3ef9eb55","commitMessage":"@@@[CALCITE-306] Standardize code style for \"import package.*;\"\n\nRename classes and packages and generally fix things up after [CALCITE-296] and [CALCITE-419].\n\nMake many inner classes of EnumerableRules (e.g. EnumerableFilter.  EnumerableFilterRule) top-level classes.\n\nApply a consistent formatting convention for string literals split over multiple lines.\n\nRename generated file org.eigenbase.resource.Resources to org.apache.calcite.runtime.Resources.\n\nChange occurrences of \"optiq\" and \"eigenbase\" in java code to \"calcite\".\n","date":"2014-11-14 10:22:06","modifiedFileCount":"1156","status":"B","submitter":"Julian Hyde"},{"authorTime":"2016-11-21 17:16:31","codes":[{"authorDate":"2016-11-21 17:16:31","commitOrder":2,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression unionExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (unionExp == null) {\n        unionExp = childExp;\n      } else {\n        unionExp = all\n            ? Expressions.call(unionExp, BuiltInMethod.CONCAT.method, childExp)\n            : Expressions.call(unionExp,\n                BuiltInMethod.UNION.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(unionExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2016-11-23 13:26:46","endLine":78,"groupId":"8018","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/2d/f6550d9bbab34f463ee3d472213d1b3a89270e.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression unionExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (unionExp == null) {\n        unionExp = childExp;\n      } else {\n        unionExp =\n            Expressions.call(\n                unionExp,\n                all\n                    ? BuiltInMethod.CONCAT.method\n                    : BuiltInMethod.UNION.method,\n                childExp);\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(unionExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUnion.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"},{"authorDate":"2016-11-21 17:16:31","commitOrder":2,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2016-11-23 13:26:46","endLine":78,"groupId":"0","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/84/62f659c1ad3591c85ba0b6ae33533b08777424.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(\n                intersectExp,\n                all\n                    ? BuiltInMethod.CONCAT.method\n                    : BuiltInMethod.INTERSECT.method,\n                childExp);\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableIntersect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"M"}],"commitId":"ce2122ff2562340333bfa0ba371872fc9a9c6251","commitMessage":"@@@[CALCITE-1501] EnumerableUnion should use array comparator when row format is ARRAY (Dayue Gao)\n\nAlso implement EnumerableIntersect and EnumerableMinus.\n\nClose apache/calcite#326\n","date":"2016-11-23 13:26:46","modifiedFileCount":"9","status":"M","submitter":"gaodayue"},{"authorTime":"2016-11-21 17:16:31","codes":[{"authorDate":"2018-02-12 18:54:06","commitOrder":3,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression unionExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (unionExp == null) {\n        unionExp = childExp;\n      } else {\n        unionExp = all\n            ? Expressions.call(unionExp, BuiltInMethod.CONCAT.method, childExp)\n            : Expressions.call(unionExp,\n                BuiltInMethod.UNION.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n    }\n\n    builder.add(unionExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2018-02-14 13:44:47","endLine":74,"groupId":"8018","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a3/fb07cb2bf3afcdbc662d6997b9c1cdd36ffa13.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression unionExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (unionExp == null) {\n        unionExp = childExp;\n      } else {\n        unionExp = all\n            ? Expressions.call(unionExp, BuiltInMethod.CONCAT.method, childExp)\n            : Expressions.call(unionExp,\n                BuiltInMethod.UNION.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(unionExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUnion.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"},{"authorDate":"2016-11-21 17:16:31","commitOrder":3,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2016-11-23 13:26:46","endLine":78,"groupId":"0","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/84/62f659c1ad3591c85ba0b6ae33533b08777424.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableIntersect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"N"}],"commitId":"bb57919df89cadeac117a966f4e9a74187267887","commitMessage":"@@@[CALCITE-2099] Incorrect code generated for UNION (Zhen Wang)\n\nClose apache/calcite#625\n","date":"2018-02-14 13:44:47","modifiedFileCount":"2","status":"M","submitter":"zhen wang"},{"authorTime":"2019-10-14 15:32:10","codes":[{"authorDate":"2018-02-12 18:54:06","commitOrder":4,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression unionExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (unionExp == null) {\n        unionExp = childExp;\n      } else {\n        unionExp = all\n            ? Expressions.call(unionExp, BuiltInMethod.CONCAT.method, childExp)\n            : Expressions.call(unionExp,\n                BuiltInMethod.UNION.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n    }\n\n    builder.add(unionExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2018-02-14 13:44:47","endLine":74,"groupId":"8018","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a3/fb07cb2bf3afcdbc662d6997b9c1cdd36ffa13.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression unionExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (unionExp == null) {\n        unionExp = childExp;\n      } else {\n        unionExp = all\n            ? Expressions.call(unionExp, BuiltInMethod.CONCAT.method, childExp)\n            : Expressions.call(unionExp,\n                BuiltInMethod.UNION.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n    }\n\n    builder.add(unionExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUnion.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"N"},{"authorDate":"2019-10-14 15:32:10","commitOrder":4,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2019-11-08 02:11:07","endLine":78,"groupId":"11878","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/1f/2b522540491e0dc53e5a0a9413a50ef4aa63d6.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableIntersect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"}],"commitId":"be5238492285ca061d4ddd82262448d3a6cedc5d","commitMessage":"@@@[CALCITE-3408] Add support for enumerable intersect/minus all (Wang Yanlin)\n\nClose #1503\n","date":"2019-11-08 02:11:07","modifiedFileCount":"15","status":"M","submitter":"yanlin-Lynn"},{"authorTime":"2020-09-29 22:09:05","codes":[{"authorDate":"2020-09-29 22:09:05","commitOrder":5,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression unionExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (unionExp == null) {\n        unionExp = childExp;\n      } else {\n        unionExp = all\n            ? Expressions.call(unionExp, BuiltInMethod.CONCAT.method, childExp)\n            : Expressions.call(unionExp,\n                BuiltInMethod.UNION.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n    }\n\n    builder.add(unionExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-10-07 05:42:47","endLine":74,"groupId":"8018","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/70/1cbd2a051d7abba755b4842cf684cee4472459.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression unionExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (unionExp == null) {\n        unionExp = childExp;\n      } else {\n        unionExp = all\n            ? Expressions.call(unionExp, BuiltInMethod.CONCAT.method, childExp)\n            : Expressions.call(unionExp,\n                BuiltInMethod.UNION.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n    }\n\n    builder.add(unionExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUnion.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"},{"authorDate":"2020-09-29 22:09:05","commitOrder":5,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-10-07 05:42:47","endLine":78,"groupId":"11878","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ab/95359709ec73c4073c42763c7c5ddd5d86c344.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableIntersect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"}],"commitId":"66caa54c5e272f8287ca132ca012733898a38768","commitMessage":"@@@[CALCITE-4314] Add missing @Override annotations\n","date":"2020-10-07 05:42:47","modifiedFileCount":"745","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":6,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression unionExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (unionExp == null) {\n        unionExp = childExp;\n      } else {\n        unionExp = all\n            ? Expressions.call(unionExp, BuiltInMethod.CONCAT.method, childExp)\n            : Expressions.call(unionExp,\n                BuiltInMethod.UNION.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n    }\n\n    builder.add(requireNonNull(unionExp, \"unionExp\"));\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-11-30 06:45:33","endLine":76,"groupId":"102148","id":11,"instanceNumber":1,"isCurCommit":1,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5e/53fc2c163f909ceb1c473098794ae014dd0a5e.src","preCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression unionExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (unionExp == null) {\n        unionExp = childExp;\n      } else {\n        unionExp = all\n            ? Expressions.call(unionExp, BuiltInMethod.CONCAT.method, childExp)\n            : Expressions.call(unionExp,\n                BuiltInMethod.UNION.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n    }\n\n    builder.add(unionExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUnion.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":6,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(requireNonNull(intersectExp, \"intersectExp\"));\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-11-30 06:45:33","endLine":80,"groupId":"102148","id":12,"instanceNumber":2,"isCurCommit":1,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e2/0a8ad765eadde08981da8354f2fdb9b594cc5d.src","preCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableIntersect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
