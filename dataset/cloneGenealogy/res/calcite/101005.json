[{"authorTime":"2015-04-01 13:25:15","codes":[{"authorDate":"2015-04-01 13:25:15","commitOrder":1,"curCode":"  @Test public void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($5, $1), <($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" ON \\\"SALGRADE\\\".\\\"LOSAL\\\" < \\\"t\\\".\\\"SAL\\\" AND \\\"SALGRADE\\\".\\\"HISAL\\\" > \\\"t\\\".\\\"SAL\\\"\");\n  }\n","date":"2015-04-01 13:51:12","endLine":125,"groupId":"5665","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonEquiJoinPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/64/0a9332e797a9ada1a3a6d450910fa549e88f21.src","preCode":"  @Test public void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($5, $1), <($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" ON \\\"SALGRADE\\\".\\\"LOSAL\\\" < \\\"t\\\".\\\"SAL\\\" AND \\\"SALGRADE\\\".\\\"HISAL\\\" > \\\"t\\\".\\\"SAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":107,"status":"B"},{"authorDate":"2015-04-01 13:25:15","commitOrder":1,"curCode":"  @Test public void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($1, $5), >=($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" ON \\\"SALGRADE\\\".\\\"LOSAL\\\" <= \\\"t\\\".\\\"SAL\\\" AND \\\"SALGRADE\\\".\\\"HISAL\\\" >= \\\"t\\\".\\\"SAL\\\"\");\n  }\n","date":"2015-04-01 13:51:12","endLine":145,"groupId":"5665","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNonEquiJoinReverseConditionPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/64/0a9332e797a9ada1a3a6d450910fa549e88f21.src","preCode":"  @Test public void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($1, $5), >=($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" ON \\\"SALGRADE\\\".\\\"LOSAL\\\" <= \\\"t\\\".\\\"SAL\\\" AND \\\"SALGRADE\\\".\\\"HISAL\\\" >= \\\"t\\\".\\\"SAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"B"}],"commitId":"a13137dc9a79795e3748d19dd34923ec674f9298","commitMessage":"@@@[CALCITE-631] Push theta joins down to JDBC adapter (Ng Jiunn Jye)\n","date":"2015-04-01 13:51:12","modifiedFileCount":"4","status":"B","submitter":"Julian Hyde"},{"authorTime":"2015-08-20 18:03:49","codes":[{"authorDate":"2015-08-20 18:03:49","commitOrder":2,"curCode":"  @Test public void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($2, $4), <($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\nFROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" > \\\"SALGRADE\\\".\\\"LOSAL\\\" AND \\\"t\\\".\\\"SAL\\\" < \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","date":"2015-08-21 19:02:29","endLine":135,"groupId":"5665","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonEquiJoinPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ea/69cae6602472bdddbecaae8d1736094d9d74cb.src","preCode":"  @Test public void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($5, $1), <($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" ON \\\"SALGRADE\\\".\\\"LOSAL\\\" < \\\"t\\\".\\\"SAL\\\" AND \\\"SALGRADE\\\".\\\"HISAL\\\" > \\\"t\\\".\\\"SAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"M"},{"authorDate":"2015-08-20 18:03:49","commitOrder":2,"curCode":"  @Test public void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($4, $2), >=($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" >= \\\"SALGRADE\\\".\\\"LOSAL\\\" AND \\\"t\\\".\\\"SAL\\\" <= \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","date":"2015-08-21 19:02:29","endLine":155,"groupId":"5665","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testNonEquiJoinReverseConditionPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ea/69cae6602472bdddbecaae8d1736094d9d74cb.src","preCode":"  @Test public void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($1, $5), >=($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" ON \\\"SALGRADE\\\".\\\"LOSAL\\\" <= \\\"t\\\".\\\"SAL\\\" AND \\\"SALGRADE\\\".\\\"HISAL\\\" >= \\\"t\\\".\\\"SAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":137,"status":"M"}],"commitId":"9f1f73d392fbff4f0ac2b29cc9462cf388be645d","commitMessage":"@@@[CALCITE-850] Remove push down expressions from FilterJoinRule and create a new rule for it\n\nClose apache/incubator-calcite#122\n","date":"2015-08-21 19:02:29","modifiedFileCount":"6","status":"M","submitter":"Jesus Camacho Rodriguez"},{"authorTime":"2015-07-26 05:44:20","codes":[{"authorDate":"2015-07-26 05:44:20","commitOrder":3,"curCode":"  @Test public void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($5, $1), <($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" \"\n            + \"ON \\\"SALGRADE\\\".\\\"LOSAL\\\" < \\\"t\\\".\\\"SAL\\\" \"\n            + \"AND \\\"SALGRADE\\\".\\\"HISAL\\\" > \\\"t\\\".\\\"SAL\\\"\");\n  }\n","date":"2016-01-10 16:51:25","endLine":146,"groupId":"5665","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonEquiJoinPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/36/1500384cb46c7be5374a8ccbcd7cdeb900c6ad.src","preCode":"  @Test public void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($2, $4), <($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\nFROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" > \\\"SALGRADE\\\".\\\"LOSAL\\\" AND \\\"t\\\".\\\"SAL\\\" < \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"M"},{"authorDate":"2015-07-26 05:44:20","commitOrder":3,"curCode":"  @Test public void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($1, $5), >=($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" \"\n            + \"ON \\\"SALGRADE\\\".\\\"LOSAL\\\" <= \\\"t\\\".\\\"SAL\\\" \"\n            + \"AND \\\"SALGRADE\\\".\\\"HISAL\\\" >= \\\"t\\\".\\\"SAL\\\"\");\n  }\n","date":"2016-01-10 16:51:25","endLine":168,"groupId":"5665","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testNonEquiJoinReverseConditionPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/36/1500384cb46c7be5374a8ccbcd7cdeb900c6ad.src","preCode":"  @Test public void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($4, $2), >=($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" >= \\\"SALGRADE\\\".\\\"LOSAL\\\" AND \\\"t\\\".\\\"SAL\\\" <= \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"M"}],"commitId":"505a9064b96a6c8399735fc2fa4d0ac9d5f3ed87","commitMessage":"@@@[CALCITE-816] Represent sub-query as a RexNode\n\nReduce 3-value logic to 1- or 2-value logic.\n\nOptimize certain IN and EXISTS to an inner join.\n\nRepresent correlation variables using CorrelationId wherever possible.\n\nIn Join.  replace field \"ImmutableSet<String> variablesStopped\" with\n\"ImmutableSet<CorrelationId> variablesSet\". RelNode.getVariablesSet\nis now preferred to RelNode.getVariablesStopped.\n\nMake Join.joinType final.\n\nVerify in builder that there are no correlation variables where there\nshouldn't be.\n\nRefactor decorrelator.\n\nLogged [CALCITE-1045] for remaining work.\n","date":"2016-01-10 16:51:25","modifiedFileCount":"76","status":"M","submitter":"Julian Hyde"},{"authorTime":"2016-01-07 16:06:19","codes":[{"authorDate":"2016-01-07 16:06:19","commitOrder":4,"curCode":"  @Test public void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($2, $4), <($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\nFROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" > \\\"SALGRADE\\\".\\\"LOSAL\\\" AND \\\"t\\\".\\\"SAL\\\" < \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","date":"2016-01-10 16:51:25","endLine":143,"groupId":"5665","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonEquiJoinPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/51/a4a704a2a820edcff44ee6a16f69747d47b53b.src","preCode":"  @Test public void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($5, $1), <($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" \"\n            + \"ON \\\"SALGRADE\\\".\\\"LOSAL\\\" < \\\"t\\\".\\\"SAL\\\" \"\n            + \"AND \\\"SALGRADE\\\".\\\"HISAL\\\" > \\\"t\\\".\\\"SAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"M"},{"authorDate":"2016-01-07 16:06:19","commitOrder":4,"curCode":"  @Test public void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($4, $2), >=($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" >= \\\"SALGRADE\\\".\\\"LOSAL\\\" AND \\\"t\\\".\\\"SAL\\\" <= \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","date":"2016-01-10 16:51:25","endLine":163,"groupId":"5665","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testNonEquiJoinReverseConditionPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/51/a4a704a2a820edcff44ee6a16f69747d47b53b.src","preCode":"  @Test public void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($1, $5), >=($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" \"\n            + \"ON \\\"SALGRADE\\\".\\\"LOSAL\\\" <= \\\"t\\\".\\\"SAL\\\" \"\n            + \"AND \\\"SALGRADE\\\".\\\"HISAL\\\" >= \\\"t\\\".\\\"SAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":145,"status":"M"}],"commitId":"4b519b9882c861bf366e2c9d9928cd6deb5cc8b9","commitMessage":"@@@[CALCITE-842] Decorrelator gets field offsets confused if fields have been trimmed\n","date":"2016-01-10 16:51:25","modifiedFileCount":"9","status":"M","submitter":"Julian Hyde"},{"authorTime":"2016-03-09 13:31:20","codes":[{"authorDate":"2016-03-09 13:31:20","commitOrder":5,"curCode":"  @Test public void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($5, $1), <($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\nFROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" \"\n            + \"ON \\\"SALGRADE\\\".\\\"LOSAL\\\" < \\\"t\\\".\\\"SAL\\\" \"\n            + \"AND \\\"SALGRADE\\\".\\\"HISAL\\\" > \\\"t\\\".\\\"SAL\\\"\");\n  }\n","date":"2016-07-08 14:44:51","endLine":145,"groupId":"5665","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonEquiJoinPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/97/da6c3708672f32bfe4975b11737ef2c027fb77.src","preCode":"  @Test public void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($2, $4), <($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\nFROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" > \\\"SALGRADE\\\".\\\"LOSAL\\\" AND \\\"t\\\".\\\"SAL\\\" < \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"M"},{"authorDate":"2016-03-09 13:31:20","commitOrder":5,"curCode":"  @Test public void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($1, $5), >=($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\nFROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" \"\n            + \"ON \\\"SALGRADE\\\".\\\"LOSAL\\\" <= \\\"t\\\".\\\"SAL\\\" AND \\\"SALGRADE\\\".\\\"HISAL\\\" >= \\\"t\\\".\\\"SAL\\\"\");\n  }\n","date":"2016-07-08 14:44:51","endLine":165,"groupId":"5665","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testNonEquiJoinReverseConditionPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/97/da6c3708672f32bfe4975b11737ef2c027fb77.src","preCode":"  @Test public void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade \\n\"\n            + \"from scott.emp e inner join scott.salgrade s \\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($4, $2), >=($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" >= \\\"SALGRADE\\\".\\\"LOSAL\\\" AND \\\"t\\\".\\\"SAL\\\" <= \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":147,"status":"M"}],"commitId":"a3bc0d8ea3c1f320b96a4ab9641becee90a388bc","commitMessage":"@@@[CALCITE-1148] Fix RelTrait conversion (e.g. distribution.  collation) (Minji Kim)\n\nIn the current calcite.  trait conversion is not handled properly.  e.g.\ncollation/distribution traits are not converted (shown by the tests).\nThis patch fixes this issue.\n\nFor each RelCollationTrait.  introduce a new API.  canConvert() which\nshould return true if the conversion from a trait to the other is\npossible.\n\nFor each Convention.  introduce two new APIs.  canConvertConvention()\nreturns true if the convernsion is possible.  and useAbstractConverters()\nreturns true if the trait conversion should be handle via\nAbstractConverters.  By default.  both functions return false.\n\nIn RelSet.  when adding a new RelSubset.  if the convention returns false\nfor useAbstractConverters().  we do not add AbstractConverters.  Even if\nconvention.useAbstractConverters() return true.  we only add\nAbstractConverters if the AbstractConverters can convert (i.e. if\nRelCollationTrait.canConvert() returns true) and the conversion is\nneeded (i.e. if RelTrait.satisfies() returns false).\n\nAdded test cases.\n\nClose apache/calcite#210\n","date":"2016-07-08 14:44:51","modifiedFileCount":"14","status":"M","submitter":"Minji Kim"},{"authorTime":"2020-02-29 08:01:52","codes":[{"authorDate":"2020-02-29 08:01:52","commitOrder":6,"curCode":"  @Test public void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($2, $4), <($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" \"\n            + \"ON \\\"t\\\".\\\"SAL\\\" > \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" < \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","date":"2020-03-10 07:14:45","endLine":243,"groupId":"5665","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonEquiJoinPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/4f/421fdd84ebc83a27e4c2f7d945033aea497e2c.src","preCode":"  @Test public void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($5, $1), <($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\nFROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" \"\n            + \"ON \\\"SALGRADE\\\".\\\"LOSAL\\\" < \\\"t\\\".\\\"SAL\\\" \"\n            + \"AND \\\"SALGRADE\\\".\\\"HISAL\\\" > \\\"t\\\".\\\"SAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":224,"status":"M"},{"authorDate":"2020-02-29 08:01:52","commitOrder":6,"curCode":"  @Test public void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($4, $2), >=($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" >= \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" <= \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","date":"2020-03-10 07:14:45","endLine":263,"groupId":"5665","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testNonEquiJoinReverseConditionPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/4f/421fdd84ebc83a27e4c2f7d945033aea497e2c.src","preCode":"  @Test public void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$3], ENAME=[$4], GRADE=[$0])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($1, $5), >=($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \"\n            + \"\\\"SALGRADE\\\".\\\"GRADE\\\"\\nFROM \\\"SCOTT\\\".\\\"SALGRADE\\\"\\n\"\n            + \"INNER JOIN (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\" \"\n            + \"ON \\\"SALGRADE\\\".\\\"LOSAL\\\" <= \\\"t\\\".\\\"SAL\\\" AND \\\"SALGRADE\\\".\\\"HISAL\\\" >= \\\"t\\\".\\\"SAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":245,"status":"M"}],"commitId":"80e6b023d4b92b2b25908c52e10f50792787cef8","commitMessage":"@@@[CALCITE-3753] Remove rule queue importance\n\nSince we are going to execute all the rules anyway.  sorting the rule matches\nwill do more harm than good.\n\nAlso removed ambitious and impatient mode. User could override checkCancel and\nthrow VolcanoTimeoutException when appropriate (i.e. exceed 60 seconds.  exceed\n1000 ticks etc.) so that the VolcanoPlanner will stop exhaustive searching and\nreturn the best plan so far.\n\nClose #1840\n","date":"2020-03-10 07:14:45","modifiedFileCount":"20","status":"M","submitter":"Haisheng Yuan"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":7,"curCode":"  @Test void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($2, $4), <($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" \"\n            + \"ON \\\"t\\\".\\\"SAL\\\" > \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" < \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","date":"2020-04-06 04:57:49","endLine":243,"groupId":"5665","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonEquiJoinPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/93/d9225e24795985dc38bb15e55325e153eec03d.src","preCode":"  @Test public void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($2, $4), <($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" \"\n            + \"ON \\\"t\\\".\\\"SAL\\\" > \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" < \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":224,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":7,"curCode":"  @Test void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($4, $2), >=($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" >= \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" <= \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","date":"2020-04-06 04:57:49","endLine":263,"groupId":"5665","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testNonEquiJoinReverseConditionPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/93/d9225e24795985dc38bb15e55325e153eec03d.src","preCode":"  @Test public void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($4, $2), >=($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" >= \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" <= \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":245,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-06-09 21:16:22","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":8,"curCode":"  @Test void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($2, $4), <($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" \"\n            + \"ON \\\"t\\\".\\\"SAL\\\" > \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" < \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","date":"2020-04-06 04:57:49","endLine":243,"groupId":"5665","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonEquiJoinPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/93/d9225e24795985dc38bb15e55325e153eec03d.src","preCode":"  @Test void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($2, $4), <($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" \"\n            + \"ON \\\"t\\\".\\\"SAL\\\" > \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" < \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":224,"status":"N"},{"authorDate":"2020-06-09 21:16:22","commitOrder":8,"curCode":"  @Test void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(>=($2, $4), <=($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" >= \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" <= \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","date":"2020-06-16 11:11:13","endLine":263,"groupId":"5665","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testNonEquiJoinReverseConditionPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d9/2a45144e4bfcae4b2408dd4450d053b3ff2c4e.src","preCode":"  @Test void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($4, $2), >=($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" >= \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" <= \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":245,"status":"M"}],"commitId":"69f25863f5f4197c17927a39a82cbf1cffd12b80","commitMessage":"@@@[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated. \nRexNode can always be normalized(default true).\n","date":"2020-06-16 11:11:13","modifiedFileCount":"51","status":"M","submitter":"yuzhao.cyz"},{"authorTime":"2020-07-14 15:38:58","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":9,"curCode":"  @Test void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($2, $4), <($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" \"\n            + \"ON \\\"t\\\".\\\"SAL\\\" > \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" < \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","date":"2020-04-06 04:57:49","endLine":243,"groupId":"101005","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testNonEquiJoinPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/93/d9225e24795985dc38bb15e55325e153eec03d.src","preCode":"  @Test void testNonEquiJoinPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on e.sal > s.losal and e.sal < s.hisal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(>($2, $4), <($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" \"\n            + \"ON \\\"t\\\".\\\"SAL\\\" > \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" < \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":224,"status":"N"},{"authorDate":"2020-07-14 15:38:58","commitOrder":9,"curCode":"  @Test void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(<=($4, $2), >=($5, $2))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" >= \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" <= \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","date":"2020-07-17 09:37:23","endLine":266,"groupId":"101005","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testNonEquiJoinReverseConditionPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/67/b39387e65b425eda84e27202f3519d6bb90056.src","preCode":"  @Test void testNonEquiJoinReverseConditionPlan() {\n    CalciteAssert.model(JdbcTest.SCOTT_MODEL)\n        .query(\"select empno, ename, grade\\n\"\n            + \"from scott.emp e inner join scott.salgrade s\\n\"\n            + \"on s.losal <= e.sal and s.hisal >= e.sal\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\\n\"\n            + \"    JdbcJoin(condition=[AND(>=($2, $4), <=($2, $5))], joinType=[inner])\\n\"\n            + \"      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\\n\"\n            + \"        JdbcTableScan(table=[[SCOTT, EMP]])\\n\"\n            + \"      JdbcTableScan(table=[[SCOTT, SALGRADE]])\")\n        .runs()\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)\n        .planHasSql(\"SELECT \\\"t\\\".\\\"EMPNO\\\", \\\"t\\\".\\\"ENAME\\\", \\\"SALGRADE\\\".\\\"GRADE\\\"\\n\"\n            + \"FROM (SELECT \\\"EMPNO\\\", \\\"ENAME\\\", \\\"SAL\\\"\\n\"\n            + \"FROM \\\"SCOTT\\\".\\\"EMP\\\") AS \\\"t\\\"\\n\"\n            + \"INNER JOIN \\\"SCOTT\\\".\\\"SALGRADE\\\" ON \\\"t\\\".\\\"SAL\\\" >= \\\"SALGRADE\\\".\\\"LOSAL\\\" \"\n            + \"AND \\\"t\\\".\\\"SAL\\\" <= \\\"SALGRADE\\\".\\\"HISAL\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":248,"status":"M"}],"commitId":"a4fa05458840cfdd93fb5cba16d102b06197539d","commitMessage":"@@@[CALCITE-4073] Add a new component RexNormalize for more effect rex nodes normalization (part1)\n\n* Add a new component named RexNormalize\n* By default.  we only normalize the RexCalls during planning phrase.  and\nthere is no way to normalize it when constructing the calls now\n* Recover the plan diffs\n* Changes the RexCall#equals to be semantic equivalent.  which i think is\nnot a good design.  we should promote to have a digest abstraction just\nlike RelNode\n","date":"2020-07-17 09:37:23","modifiedFileCount":"10","status":"M","submitter":"yuzhao.cyz"}]
