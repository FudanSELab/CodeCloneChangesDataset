[{"authorTime":"2019-10-18 19:10:43","codes":[{"authorDate":"2019-10-18 19:10:43","commitOrder":1,"curCode":"  @Test public void testColumnUniquenessForIntersectWithConstantColumns() {\n    final RelMetadataQuery mq = RelMetadataQuery.instance();\n    final String sql = \"\"\n        + \"select deptno, sal\\n\"\n        + \"from (select distinct deptno, sal from emp)\\n\"\n        + \"where sal=1000\\n\"\n        + \"intersect all\\n\"\n        + \"select deptno, sal from emp\\n\";\n    final RelNode rel = convertSql(sql);\n    assertThat(rel.getRowType().getFieldNames().toString(),\n        is(\"[DEPTNO, SAL]\"));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n  }\n","date":"2019-10-24 00:40:09","endLine":994,"groupId":"6292","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testColumnUniquenessForIntersectWithConstantColumns","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/78/5ae17c0ea34ea2dbea52bcca849210e78762fb.src","preCode":"  @Test public void testColumnUniquenessForIntersectWithConstantColumns() {\n    final RelMetadataQuery mq = RelMetadataQuery.instance();\n    final String sql = \"\"\n        + \"select deptno, sal\\n\"\n        + \"from (select distinct deptno, sal from emp)\\n\"\n        + \"where sal=1000\\n\"\n        + \"intersect all\\n\"\n        + \"select deptno, sal from emp\\n\";\n    final RelNode rel = convertSql(sql);\n    assertThat(rel.getRowType().getFieldNames().toString(),\n        is(\"[DEPTNO, SAL]\"));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/RelMetadataTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":982,"status":"B"},{"authorDate":"2019-10-18 19:10:43","commitOrder":1,"curCode":"  @Test public void testColumnUniquenessForMinusWithConstantColumns() {\n    final RelMetadataQuery mq = RelMetadataQuery.instance();\n    final String sql = \"\"\n        + \"select deptno, sal\\n\"\n        + \"from (select distinct deptno, sal from emp)\\n\"\n        + \"where sal=1000\\n\"\n        + \"except all\\n\"\n        + \"select deptno, sal from emp\\n\";\n    final RelNode rel = convertSql(sql);\n    assertThat(rel.getRowType().getFieldNames().toString(),\n        is(\"[DEPTNO, SAL]\"));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0)), is(true));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n  }\n","date":"2019-10-24 00:40:09","endLine":1009,"groupId":"6292","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testColumnUniquenessForMinusWithConstantColumns","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/78/5ae17c0ea34ea2dbea52bcca849210e78762fb.src","preCode":"  @Test public void testColumnUniquenessForMinusWithConstantColumns() {\n    final RelMetadataQuery mq = RelMetadataQuery.instance();\n    final String sql = \"\"\n        + \"select deptno, sal\\n\"\n        + \"from (select distinct deptno, sal from emp)\\n\"\n        + \"where sal=1000\\n\"\n        + \"except all\\n\"\n        + \"select deptno, sal from emp\\n\";\n    final RelNode rel = convertSql(sql);\n    assertThat(rel.getRowType().getFieldNames().toString(),\n        is(\"[DEPTNO, SAL]\"));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0)), is(true));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/RelMetadataTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":996,"status":"B"}],"commitId":"f9103e6079f75e3d6b3419d01690447ff0a14265","commitMessage":"@@@[CALCITE-3428] Refine RelMdColumnUniqueness for Filter by considering constant columns (Jin Xing)\n\nWith this rule.  we can simplify\n\n  SELECT DISTINCT x\n  FROM (SELECT DISTINCT x.  y FROM t)\n  WHERE y = 10\n\nto\n\n  SELECT x\n  FROM (SELECT DISTINCT x.  y FROM t)\n  WHERE y = 10\n\nClose apache/calcite#1520\n","date":"2019-10-24 00:40:09","modifiedFileCount":"3","status":"B","submitter":"jinxing"},{"authorTime":"2020-01-13 11:21:08","codes":[{"authorDate":"2020-01-13 11:21:08","commitOrder":2,"curCode":"  @Test public void testColumnUniquenessForIntersectWithConstantColumns() {\n    final String sql = \"\"\n        + \"select deptno, sal\\n\"\n        + \"from (select distinct deptno, sal from emp)\\n\"\n        + \"where sal=1000\\n\"\n        + \"intersect all\\n\"\n        + \"select deptno, sal from emp\\n\";\n    final RelNode rel = convertSql(sql);\n    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n    assertThat(rel.getRowType().getFieldNames().toString(),\n        is(\"[DEPTNO, SAL]\"));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n  }\n","date":"2020-01-13 14:36:19","endLine":1054,"groupId":"11852","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testColumnUniquenessForIntersectWithConstantColumns","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/29/ecb5df55a057f1304fef9ebfdfb6f7153f9d32.src","preCode":"  @Test public void testColumnUniquenessForIntersectWithConstantColumns() {\n    final RelMetadataQuery mq = RelMetadataQuery.instance();\n    final String sql = \"\"\n        + \"select deptno, sal\\n\"\n        + \"from (select distinct deptno, sal from emp)\\n\"\n        + \"where sal=1000\\n\"\n        + \"intersect all\\n\"\n        + \"select deptno, sal from emp\\n\";\n    final RelNode rel = convertSql(sql);\n    assertThat(rel.getRowType().getFieldNames().toString(),\n        is(\"[DEPTNO, SAL]\"));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/RelMetadataTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1042,"status":"M"},{"authorDate":"2020-01-13 11:21:08","commitOrder":2,"curCode":"  @Test public void testColumnUniquenessForMinusWithConstantColumns() {\n    final String sql = \"\"\n        + \"select deptno, sal\\n\"\n        + \"from (select distinct deptno, sal from emp)\\n\"\n        + \"where sal=1000\\n\"\n        + \"except all\\n\"\n        + \"select deptno, sal from emp\\n\";\n    final RelNode rel = convertSql(sql);\n    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n    assertThat(rel.getRowType().getFieldNames().toString(),\n        is(\"[DEPTNO, SAL]\"));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0)), is(true));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n  }\n","date":"2020-01-13 14:36:19","endLine":1069,"groupId":"11852","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testColumnUniquenessForMinusWithConstantColumns","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/29/ecb5df55a057f1304fef9ebfdfb6f7153f9d32.src","preCode":"  @Test public void testColumnUniquenessForMinusWithConstantColumns() {\n    final RelMetadataQuery mq = RelMetadataQuery.instance();\n    final String sql = \"\"\n        + \"select deptno, sal\\n\"\n        + \"from (select distinct deptno, sal from emp)\\n\"\n        + \"where sal=1000\\n\"\n        + \"except all\\n\"\n        + \"select deptno, sal from emp\\n\";\n    final RelNode rel = convertSql(sql);\n    assertThat(rel.getRowType().getFieldNames().toString(),\n        is(\"[DEPTNO, SAL]\"));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0)), is(true));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/RelMetadataTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1056,"status":"M"}],"commitId":"5fc2fda637429d8810692fcab4c2d50c5448288b","commitMessage":"@@@[CALCITE-3725] RelMetadataTest fails with NPE due to unsafe RelMetadataQuery.instance call (Jin Xing)\n","date":"2020-01-13 14:36:19","modifiedFileCount":"1","status":"M","submitter":"jx158167"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":3,"curCode":"  @Test void testColumnUniquenessForIntersectWithConstantColumns() {\n    final String sql = \"\"\n        + \"select deptno, sal\\n\"\n        + \"from (select distinct deptno, sal from emp)\\n\"\n        + \"where sal=1000\\n\"\n        + \"intersect all\\n\"\n        + \"select deptno, sal from emp\\n\";\n    final RelNode rel = convertSql(sql);\n    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n    assertThat(rel.getRowType().getFieldNames().toString(),\n        is(\"[DEPTNO, SAL]\"));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n  }\n","date":"2020-04-06 04:57:49","endLine":1054,"groupId":"101114","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testColumnUniquenessForIntersectWithConstantColumns","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/cf/1ece4728b283bdc8ffdff6174002f52f235fb8.src","preCode":"  @Test public void testColumnUniquenessForIntersectWithConstantColumns() {\n    final String sql = \"\"\n        + \"select deptno, sal\\n\"\n        + \"from (select distinct deptno, sal from emp)\\n\"\n        + \"where sal=1000\\n\"\n        + \"intersect all\\n\"\n        + \"select deptno, sal from emp\\n\";\n    final RelNode rel = convertSql(sql);\n    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n    assertThat(rel.getRowType().getFieldNames().toString(),\n        is(\"[DEPTNO, SAL]\"));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/RelMetadataTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1042,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":3,"curCode":"  @Test void testColumnUniquenessForMinusWithConstantColumns() {\n    final String sql = \"\"\n        + \"select deptno, sal\\n\"\n        + \"from (select distinct deptno, sal from emp)\\n\"\n        + \"where sal=1000\\n\"\n        + \"except all\\n\"\n        + \"select deptno, sal from emp\\n\";\n    final RelNode rel = convertSql(sql);\n    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n    assertThat(rel.getRowType().getFieldNames().toString(),\n        is(\"[DEPTNO, SAL]\"));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0)), is(true));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n  }\n","date":"2020-04-06 04:57:49","endLine":1069,"groupId":"101114","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testColumnUniquenessForMinusWithConstantColumns","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/cf/1ece4728b283bdc8ffdff6174002f52f235fb8.src","preCode":"  @Test public void testColumnUniquenessForMinusWithConstantColumns() {\n    final String sql = \"\"\n        + \"select deptno, sal\\n\"\n        + \"from (select distinct deptno, sal from emp)\\n\"\n        + \"where sal=1000\\n\"\n        + \"except all\\n\"\n        + \"select deptno, sal from emp\\n\";\n    final RelNode rel = convertSql(sql);\n    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n    assertThat(rel.getRowType().getFieldNames().toString(),\n        is(\"[DEPTNO, SAL]\"));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0)), is(true));\n    assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/RelMetadataTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1056,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"}]
