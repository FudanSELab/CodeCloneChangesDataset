[{"authorTime":"2015-08-14 08:05:05","codes":[{"authorDate":"2015-03-27 10:35:34","commitOrder":4,"curCode":"  @Test public void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            FilterMergeRule.INSTANCE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2015-03-27 10:35:34","endLine":494,"groupId":"11637","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testPlanWithExplicitTraitDefs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ff/6094ab5b9ff4cb1733e212bf7b4354fff59c7c.src","preCode":"  @Test public void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            FilterMergeRule.INSTANCE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":472,"status":"NB"},{"authorDate":"2015-08-14 08:05:05","commitOrder":4,"curCode":"  @Test public void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2015-12-01 04:13:25","endLine":572,"groupId":"11637","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testPlanTransformWithRuleNameConflicts","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/01/816df59cc79e4f54bbb2a89a3a1e78c86584c6.src","preCode":"  @Test public void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":522,"status":"B"}],"commitId":"d3c5acd3a95e1926e0985e99a2d802a60e096b32","commitMessage":"@@@[CALCITE-966] VolcanoPlanner should clear ruleNames in order to avoid rule name conflicting error\n\nclose apache/calcite#167\n","date":"2015-12-01 04:13:25","modifiedFileCount":"2","status":"M","submitter":"Jinfeng Ni"},{"authorTime":"2015-08-14 08:05:05","codes":[{"authorDate":"2015-09-11 10:27:49","commitOrder":5,"curCode":"  @Test public void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            FilterMergeRule.INSTANCE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2016-01-10 16:51:24","endLine":499,"groupId":"11637","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testPlanWithExplicitTraitDefs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fa/e8cb9c44f03dfb56fb3288ee677e1dcf600f2a.src","preCode":"  @Test public void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            FilterMergeRule.INSTANCE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":477,"status":"M"},{"authorDate":"2015-08-14 08:05:05","commitOrder":5,"curCode":"  @Test public void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2015-12-01 04:13:25","endLine":572,"groupId":"11637","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testPlanTransformWithRuleNameConflicts","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/01/816df59cc79e4f54bbb2a89a3a1e78c86584c6.src","preCode":"  @Test public void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":522,"status":"N"}],"commitId":"4ae0298688d402484be7c76610e46c6f610a8bc6","commitMessage":"@@@Deprecate some Util methods.  and upgrade last modules to JDK 1.7\n","date":"2016-01-10 16:51:24","modifiedFileCount":"6","status":"M","submitter":"Julian Hyde"},{"authorTime":"2015-07-12 05:56:42","codes":[{"authorDate":"2015-09-11 10:27:49","commitOrder":6,"curCode":"  @Test public void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            FilterMergeRule.INSTANCE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2016-01-10 16:51:24","endLine":499,"groupId":"11637","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testPlanWithExplicitTraitDefs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fa/e8cb9c44f03dfb56fb3288ee677e1dcf600f2a.src","preCode":"  @Test public void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            FilterMergeRule.INSTANCE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":477,"status":"N"},{"authorDate":"2015-07-12 05:56:42","commitOrder":6,"curCode":"  @Test public void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2016-01-10 16:51:25","endLine":574,"groupId":"11637","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testPlanTransformWithRuleNameConflicts","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d6/04938589db87c1b62472c5ec55b5fc12b159f8.src","preCode":"  @Test public void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":524,"status":"M"}],"commitId":"cabdcf44e4aec4d4ceea7f97c8c6fd9e9dbd36b1","commitMessage":"@@@[CALCITE-794] Detect cycles when computing statistics\n\nMake RelMetadataQuery methods non-static. Each active call is\nregistered in the RelMetadataQuery instance; it throws\nCyclicMetadataException when it detects a cycle.  and the caller can\ncatch it to return a sensible default value for the particular kind of\nmetadata.\n\nChange signature of FlatLists.of(Object...) to\nFlatLists.copyOf(Comparable...).\n\nTemporarily disable all failing tests.\n\nAdd metadata for EnumerableLimit.\n","date":"2016-01-10 16:51:25","modifiedFileCount":"122","status":"M","submitter":"Julian Hyde"},{"authorTime":"2019-01-04 02:58:55","codes":[{"authorDate":"2019-01-04 02:58:55","commitOrder":7,"curCode":"  @Test public void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            FilterMergeRule.INSTANCE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2019-01-04 03:21:44","endLine":556,"groupId":"11637","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testPlanWithExplicitTraitDefs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7b/d85b6c07b2bdaa72d19a89d46868aeb6f8a602.src","preCode":"  @Test public void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            FilterMergeRule.INSTANCE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":534,"status":"M"},{"authorDate":"2019-01-04 02:58:55","commitOrder":7,"curCode":"  @Test public void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2019-01-04 03:21:44","endLine":631,"groupId":"11637","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testPlanTransformWithRuleNameConflicts","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7b/d85b6c07b2bdaa72d19a89d46868aeb6f8a602.src","preCode":"  @Test public void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":581,"status":"M"}],"commitId":"b54f6de9d7f87e9853fc9ec01b586555a089b913","commitMessage":"@@@[CALCITE-2768] PlannerTest ignores top-level order by clause (~RootRel.collation)\n","date":"2019-01-04 03:21:44","modifiedFileCount":"2","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-02-07 17:06:16","codes":[{"authorDate":"2020-02-07 17:06:16","commitOrder":8,"curCode":"  @Test public void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            FilterMergeRule.INSTANCE,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2020-02-14 10:24:24","endLine":781,"groupId":"11637","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testPlanWithExplicitTraitDefs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5d/edb3162d1dca61baa746a07f0a95890cfe9982.src","preCode":"  @Test public void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            FilterMergeRule.INSTANCE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":758,"status":"M"},{"authorDate":"2020-02-07 17:06:16","commitOrder":8,"curCode":"  @Test public void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2020-02-14 10:24:24","endLine":858,"groupId":"11637","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testPlanTransformWithRuleNameConflicts","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5d/edb3162d1dca61baa746a07f0a95890cfe9982.src","preCode":"  @Test public void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":807,"status":"M"}],"commitId":"6a322f9fff51362744b326246e49590f850449bb","commitMessage":"@@@[CALCITE-3769] Deprecate TableScanRule\n\n* Deprecate TableScanRule and always invoke RelOptTable#toRel for\nRelBuilder#scan\n* RelOptTableImpl#toRel does not translate to EnumerableTableScan\nanymore.  the EnumerableTableScan conversion logic has been moved to\nEnumerableTableScanRule\n* Remove the BindableTableScanRule from the default prepare ruleset.  we\nonly add it where we really need that\n* Fix the plan change\n","date":"2020-02-14 10:24:24","modifiedFileCount":"21","status":"M","submitter":"yuzhao.cyz"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":9,"curCode":"  @Test void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            FilterMergeRule.INSTANCE,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2020-04-06 04:57:49","endLine":781,"groupId":"11637","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testPlanWithExplicitTraitDefs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e6/ce8a05eee1dbae94fa526e1af77f6e77e09e4d.src","preCode":"  @Test public void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            FilterMergeRule.INSTANCE,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":758,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":9,"curCode":"  @Test void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2020-04-06 04:57:49","endLine":858,"groupId":"11637","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testPlanTransformWithRuleNameConflicts","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e6/ce8a05eee1dbae94fa526e1af77f6e77e09e4d.src","preCode":"  @Test public void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":807,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-07-09 04:45:12","commitOrder":10,"curCode":"  @Test void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            CoreRules.FILTER_MERGE,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2020-07-12 06:58:28","endLine":775,"groupId":"11637","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testPlanWithExplicitTraitDefs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5e/bef0bb4c9f352cd2282c282a04ef3461124a77.src","preCode":"  @Test void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            FilterMergeRule.INSTANCE,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":752,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":10,"curCode":"  @Test void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2020-04-06 04:57:49","endLine":858,"groupId":"11637","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testPlanTransformWithRuleNameConflicts","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e6/ce8a05eee1dbae94fa526e1af77f6e77e09e4d.src","preCode":"  @Test void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":807,"status":"N"}],"commitId":"23b26b6287315cc2cd236e705bb651077488fc5c","commitMessage":"@@@In preparation for [CALCITE-3923] and [CALCITE-4079].  deprecate fields and methods that will be removed between 1.24 and 1.25\n\nAlso.  in RelNode.  change some methods from 'to removed before 2.0'\nto 'to be removed before 1.25'. The methods are sDistinct(). \nisKey(ImmutableBitSet).  getQuery().  getRows().  getVariablesStopped(). \ncomputeSelfCost().  isValid(boolean).  getCollationList().  getChildExps().\n","date":"2020-07-12 06:58:28","modifiedFileCount":"137","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-07-09 05:31:40","codes":[{"authorDate":"2020-07-09 04:45:12","commitOrder":11,"curCode":"  @Test void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            CoreRules.FILTER_MERGE,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2020-07-12 06:58:28","endLine":775,"groupId":"10659","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testPlanWithExplicitTraitDefs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5e/bef0bb4c9f352cd2282c282a04ef3461124a77.src","preCode":"  @Test void testPlanWithExplicitTraitDefs() throws Exception {\n    RuleSet ruleSet =\n        RuleSets.ofList(\n            CoreRules.FILTER_MERGE,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n    final List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n\n    Planner planner = getPlanner(traitDefs, Programs.of(ruleSet));\n\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n            + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":752,"status":"N"},{"authorDate":"2020-07-09 05:31:40","commitOrder":11,"curCode":"  @Test void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = MyProjectFilterRule.config(\"MYRULE\").toRule();\n    RelOptRule rule2 = MyFilterProjectRule.config(\"MYRULE\").toRule();\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","date":"2020-07-29 02:27:24","endLine":829,"groupId":"10659","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testPlanTransformWithRuleNameConflicts","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5d/787e4335f6bd196bd477a970de9367c8603242.src","preCode":"  @Test void testPlanTransformWithRuleNameConflicts() throws Exception {\n    \r\n    RelOptRule rule1 = new RelOptRule(\n        operand(LogicalProject.class,\n            operand(LogicalFilter.class, RelOptRule.any())),\n        \"MYRULE\") {\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RelOptRule rule2 = new RelOptRule(\n        operand(LogicalFilter.class,\n            operand(LogicalProject.class, RelOptRule.any())),\n        \"MYRULE\") {\n\n      @Override public boolean matches(RelOptRuleCall call) {\n        return false;\n      }\n\n      public void onMatch(RelOptRuleCall call) {\n      }\n    };\n\n    RuleSet ruleSet1 =\n        RuleSets.ofList(\n            rule1,\n            EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,\n            EnumerableRules.ENUMERABLE_FILTER_RULE,\n            EnumerableRules.ENUMERABLE_PROJECT_RULE);\n\n    RuleSet ruleSet2 =\n        RuleSets.ofList(\n            rule2);\n\n    Planner planner = getPlanner(null, Programs.of(ruleSet1),\n        Programs.of(ruleSet2));\n    SqlNode parse = planner.parse(\"select * from \\\"emps\\\"\");\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    RelNode transform2 = planner.transform(1, traitSet, transform);\n    assertThat(toString(transform2),\n        equalTo(\n            \"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\\n\"\n                + \"  EnumerableTableScan(table=[[hr, emps]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":800,"status":"M"}],"commitId":"998cd83ebe2fcd7ff3ee565299fed6e199269715","commitMessage":"@@@[CALCITE-3923] Refactor how planner rules are parameterized\n\nCreate operands using a builder interface.  OperandBuilder.  and\ndeprecate methods RelOptRule.operand etc.\n\nThe change is backwards compatible.  in the sense that\nexisting rule constructors are deprecated but still work.\nFrom now on.  to create rules.  call RelOptRule.Config.toRule()\n(which calls the rule's (Config) constructor).\n\nSub-classes of ConverterRule are a little different.  They\ndon't need their own sub-class of Config.  You just need to\ncall Config.withRuleFactory to specify the constructor of the\nsub-class of ConverterRule.\n\nMove rule instances into holder classes such as CoreRules. \nMaterializedViewRules. Deprecate existing rule INSTANCE fields\n(to be removed in 1.25). Deprecate previous rule constructors\n(to be removed in 2.0).\n\nDescribe how to write rules in howto and tutorial.\n\nRemove rule instances marked 'deprecated.  to be removed before\n1.25'.\n\nClose apache/calcite#2024\n","date":"2020-07-29 02:27:24","modifiedFileCount":"191","status":"M","submitter":"Julian Hyde"}]
