[{"authorTime":"2017-04-13 05:44:29","codes":[{"authorDate":"2019-05-18 14:56:22","commitOrder":2,"curCode":"    public boolean get(int bitIndex) {\n        long stamp = rwLock.tryOptimisticRead();\n        boolean isSet = super.get(bitIndex);\n        if (!rwLock.validate(stamp)) {\n            stamp = rwLock.readLock();\n            try {\n                isSet = super.get(bitIndex);\n            } finally {\n                rwLock.unlockRead(stamp);\n            }\n        }\n        return isSet;\n    }\n","date":"2019-05-18 14:56:22","endLine":55,"groupId":"5862","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"get","params":"(intbitIndex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/73/9ad1e393b7e76053ac3be9ddb051ed5dd6a526.src","preCode":"    public boolean get(int bitIndex) {\n        long stamp = rwLock.tryOptimisticRead();\n        boolean isSet = super.get(bitIndex);\n        if (!rwLock.validate(stamp)) {\n            stamp = rwLock.readLock();\n            try {\n                isSet = super.get(bitIndex);\n            } finally {\n                rwLock.unlockRead(stamp);\n            }\n        }\n        return isSet;\n    }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/util/collections/ConcurrentBitSet.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":43,"status":"B"},{"authorDate":"2017-04-13 05:44:29","commitOrder":2,"curCode":"    public boolean isEmpty() {\n        long stamp = rwLock.tryOptimisticRead();\n        boolean isEmpty = heap.isEmpty();\n        if (!rwLock.validate(stamp)) {\n            \r\n            stamp = rwLock.readLock();\n            try {\n                isEmpty = heap.isEmpty();\n            } finally {\n                rwLock.unlockRead(stamp);\n            }\n        }\n\n        return isEmpty;\n    }\n","date":"2017-04-13 05:44:29","endLine":180,"groupId":"14197","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"isEmpty","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/31/6326462ff5d2b30b31785805b535164457a2cb.src","preCode":"    public boolean isEmpty() {\n        long stamp = rwLock.tryOptimisticRead();\n        boolean isEmpty = heap.isEmpty();\n        if (!rwLock.validate(stamp)) {\n            \r\n            stamp = rwLock.readLock();\n            try {\n                isEmpty = heap.isEmpty();\n            } finally {\n                rwLock.unlockRead(stamp);\n            }\n        }\n\n        return isEmpty;\n    }\n","realPath":"managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorContainer.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"NB"}],"commitId":"ce685dc3b359674941f02f81185651645012e80a","commitMessage":"@@@[pulsar-common] add open Concurrent LongPair RangeSet (#3818)\n\n* [pulsar-common] add open Concurrent LongPair RangeSet\n\n* add open-range set methods\n\n* add forEach\n\n* add forEach with consumer\n\n* Fix stamp-lock usage\n\n* Move ConcurrentBitSet to separate class\n","date":"2019-05-18 14:56:22","modifiedFileCount":"0","status":"M","submitter":"Rajan Dhabalia"},{"authorTime":"2020-06-08 19:15:11","codes":[{"authorDate":"2019-05-18 14:56:22","commitOrder":3,"curCode":"    public boolean get(int bitIndex) {\n        long stamp = rwLock.tryOptimisticRead();\n        boolean isSet = super.get(bitIndex);\n        if (!rwLock.validate(stamp)) {\n            stamp = rwLock.readLock();\n            try {\n                isSet = super.get(bitIndex);\n            } finally {\n                rwLock.unlockRead(stamp);\n            }\n        }\n        return isSet;\n    }\n","date":"2019-05-18 14:56:22","endLine":55,"groupId":"10227","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"get","params":"(intbitIndex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/73/9ad1e393b7e76053ac3be9ddb051ed5dd6a526.src","preCode":"    public boolean get(int bitIndex) {\n        long stamp = rwLock.tryOptimisticRead();\n        boolean isSet = super.get(bitIndex);\n        if (!rwLock.validate(stamp)) {\n            stamp = rwLock.readLock();\n            try {\n                isSet = super.get(bitIndex);\n            } finally {\n                rwLock.unlockRead(stamp);\n            }\n        }\n        return isSet;\n    }\n","realPath":"pulsar-common/src/main/java/org/apache/pulsar/common/util/collections/ConcurrentBitSet.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":43,"status":"N"},{"authorDate":"2020-06-08 19:15:11","commitOrder":3,"curCode":"    public boolean isEmpty() {\n        long stamp = rwLock.tryOptimisticRead();\n        boolean isEmpty = cursors.isEmpty();\n        if (!rwLock.validate(stamp)) {\n            \r\n            stamp = rwLock.readLock();\n            try {\n                isEmpty = cursors.isEmpty();\n            } finally {\n                rwLock.unlockRead(stamp);\n            }\n        }\n\n        return isEmpty;\n    }\n","date":"2020-06-08 19:15:11","endLine":198,"groupId":"10227","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"isEmpty","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-pulsar-10-0.7/blobInfo/CC_OUT/blobs/db/887f0b492ebe41c2534654dd004208245b2e5b.src","preCode":"    public boolean isEmpty() {\n        long stamp = rwLock.tryOptimisticRead();\n        boolean isEmpty = heap.isEmpty();\n        if (!rwLock.validate(stamp)) {\n            \r\n            stamp = rwLock.readLock();\n            try {\n                isEmpty = heap.isEmpty();\n            } finally {\n                rwLock.unlockRead(stamp);\n            }\n        }\n\n        return isEmpty;\n    }\n","realPath":"managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorContainer.java","repoName":"pulsar","snippetEndLine":0,"snippetStartLine":0,"startLine":184,"status":"M"}],"commitId":"bcfa7f00554b72314799b2d38a5815d5ee802e5e","commitMessage":"@@@Using Readers still causes backlog quota to be observed (#6787)\n\n\n Motivation\n\nWhen using Readers API.  backlog quotas are still enforced on these ephemeral readers.\n\n\n Modifications\n\nIf a cursor is non-durable then we don't add it to the min-heap we are using keep track of the slowest cursor.  \n\nWe use in the min-heap to access the slowest cursor for backlog and quota calculations.  \n\nIt is also used to determine up to which ledger we can trim.  Thus.  with this change.  reader's ephemeral subscriptions won't be preventing ledgers from being clean up as well which is what you expect the behavior to be.\n\nThere are some caveats to the above.  Since triggering of trimming of ledgers is piggy packed on top of ledger operations.  if there is no new data coming in ledgers will not be trimmed.  The most recently closed ledger we be persisted past any retention.  Perhaps in a subsequent PR.  we implement the trimming to be trigger on a schedule as well.","date":"2020-06-08 19:15:11","modifiedFileCount":"5","status":"M","submitter":"Boyang Jerry Peng"}]
