[{"authorTime":"2019-11-21 07:59:34","codes":[{"authorDate":"2020-06-18 00:57:08","commitOrder":3,"curCode":"  public void testAssignIdsByNameMapping() {\n    Types.StructType structType = Types.StructType.of(\n        required(0, \"id\", Types.LongType.get()),\n        optional(1, \"list_of_maps\",\n            Types.ListType.ofOptional(2, Types.MapType.ofOptional(3, 4,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))),\n        optional(5, \"map_of_lists\",\n            Types.MapType.ofOptional(6, 7,\n                Types.StringType.get(),\n                Types.ListType.ofOptional(8, SUPPORTED_PRIMITIVES))),\n        required(9, \"list_of_lists\",\n            Types.ListType.ofOptional(10, Types.ListType.ofOptional(11, SUPPORTED_PRIMITIVES))),\n        required(12, \"map_of_maps\",\n            Types.MapType.ofOptional(13, 14,\n                Types.StringType.get(),\n                Types.MapType.ofOptional(15, 16,\n                    Types.StringType.get(),\n                    SUPPORTED_PRIMITIVES))),\n        required(17, \"list_of_struct_of_nested_types\", Types.ListType.ofOptional(19, Types.StructType.of(\n            Types.NestedField.required(20, \"m1\", Types.MapType.ofOptional(21, 22,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(23, \"l1\", Types.ListType.ofRequired(24, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.required(25, \"l2\", Types.ListType.ofRequired(26, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(27, \"m2\", Types.MapType.ofOptional(28, 29,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))\n        )))\n    );\n\n    Schema schema = new Schema(TypeUtil.assignFreshIds(structType, new AtomicInteger(0)::incrementAndGet)\n        .asStructType().fields());\n    NameMapping nameMapping = MappingUtil.create(schema);\n    MessageType messageType = ParquetSchemaUtil.convert(schema, \"complex_schema\");\n    MessageType typeWithIdsFromNameMapping = ParquetSchemaUtil.applyNameMapping(messageType, nameMapping);\n    Schema newSchema = ParquetSchemaUtil.convert(typeWithIdsFromNameMapping);\n\n    Assert.assertEquals(schema.asStruct(), newSchema.asStruct());\n  }\n","date":"2020-06-18 00:57:08","endLine":94,"groupId":"2616","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testAssignIdsByNameMapping","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/f6/1ca5ebff5c9b7c2f719bd1afe77c3ccd7dbbf6.src","preCode":"  public void testAssignIdsByNameMapping() {\n    Types.StructType structType = Types.StructType.of(\n        required(0, \"id\", Types.LongType.get()),\n        optional(1, \"list_of_maps\",\n            Types.ListType.ofOptional(2, Types.MapType.ofOptional(3, 4,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))),\n        optional(5, \"map_of_lists\",\n            Types.MapType.ofOptional(6, 7,\n                Types.StringType.get(),\n                Types.ListType.ofOptional(8, SUPPORTED_PRIMITIVES))),\n        required(9, \"list_of_lists\",\n            Types.ListType.ofOptional(10, Types.ListType.ofOptional(11, SUPPORTED_PRIMITIVES))),\n        required(12, \"map_of_maps\",\n            Types.MapType.ofOptional(13, 14,\n                Types.StringType.get(),\n                Types.MapType.ofOptional(15, 16,\n                    Types.StringType.get(),\n                    SUPPORTED_PRIMITIVES))),\n        required(17, \"list_of_struct_of_nested_types\", Types.ListType.ofOptional(19, Types.StructType.of(\n            Types.NestedField.required(20, \"m1\", Types.MapType.ofOptional(21, 22,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(23, \"l1\", Types.ListType.ofRequired(24, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.required(25, \"l2\", Types.ListType.ofRequired(26, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(27, \"m2\", Types.MapType.ofOptional(28, 29,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))\n        )))\n    );\n\n    Schema schema = new Schema(TypeUtil.assignFreshIds(structType, new AtomicInteger(0)::incrementAndGet)\n        .asStructType().fields());\n    NameMapping nameMapping = MappingUtil.create(schema);\n    MessageType messageType = ParquetSchemaUtil.convert(schema, \"complex_schema\");\n    MessageType typeWithIdsFromNameMapping = ParquetSchemaUtil.applyNameMapping(messageType, nameMapping);\n    Schema newSchema = ParquetSchemaUtil.convert(typeWithIdsFromNameMapping);\n\n    Assert.assertEquals(schema.asStruct(), newSchema.asStruct());\n  }\n","realPath":"parquet/src/test/java/org/apache/iceberg/parquet/TestParquetSchemaUtil.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"B"},{"authorDate":"2019-11-21 07:59:34","commitOrder":3,"curCode":"  public void testMixedTypes() throws IOException {\n    StructType structType = StructType.of(\n        required(0, \"id\", LongType.get()),\n        optional(1, \"list_of_maps\",\n            ListType.ofOptional(2, MapType.ofOptional(3, 4,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))),\n        optional(5, \"map_of_lists\",\n            MapType.ofOptional(6, 7,\n                Types.StringType.get(),\n                ListType.ofOptional(8, SUPPORTED_PRIMITIVES))),\n        required(9, \"list_of_lists\",\n            ListType.ofOptional(10, ListType.ofOptional(11, SUPPORTED_PRIMITIVES))),\n        required(12, \"map_of_maps\",\n            MapType.ofOptional(13, 14,\n                Types.StringType.get(),\n                MapType.ofOptional(15, 16,\n                    Types.StringType.get(),\n                    SUPPORTED_PRIMITIVES))),\n        required(17, \"list_of_struct_of_nested_types\", ListType.ofOptional(19, StructType.of(\n            Types.NestedField.required(20, \"m1\", MapType.ofOptional(21, 22,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(23, \"l1\", ListType.ofRequired(24, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.required(25, \"l2\", ListType.ofRequired(26, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(27, \"m2\", MapType.ofOptional(28, 29,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))\n        )))\n    );\n\n    Schema schema = new Schema(TypeUtil.assignFreshIds(structType, new AtomicInteger(0)::incrementAndGet)\n        .asStructType().fields());\n\n    writeAndValidate(schema);\n  }\n","date":"2019-11-21 07:59:34","endLine":169,"groupId":"75","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMixedTypes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/cb/e36f3ad92b73f4ced69944f28903fe91d1d254.src","preCode":"  public void testMixedTypes() throws IOException {\n    StructType structType = StructType.of(\n        required(0, \"id\", LongType.get()),\n        optional(1, \"list_of_maps\",\n            ListType.ofOptional(2, MapType.ofOptional(3, 4,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))),\n        optional(5, \"map_of_lists\",\n            MapType.ofOptional(6, 7,\n                Types.StringType.get(),\n                ListType.ofOptional(8, SUPPORTED_PRIMITIVES))),\n        required(9, \"list_of_lists\",\n            ListType.ofOptional(10, ListType.ofOptional(11, SUPPORTED_PRIMITIVES))),\n        required(12, \"map_of_maps\",\n            MapType.ofOptional(13, 14,\n                Types.StringType.get(),\n                MapType.ofOptional(15, 16,\n                    Types.StringType.get(),\n                    SUPPORTED_PRIMITIVES))),\n        required(17, \"list_of_struct_of_nested_types\", ListType.ofOptional(19, StructType.of(\n            Types.NestedField.required(20, \"m1\", MapType.ofOptional(21, 22,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(23, \"l1\", ListType.ofRequired(24, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.required(25, \"l2\", ListType.ofRequired(26, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(27, \"m2\", MapType.ofOptional(28, 29,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))\n        )))\n    );\n\n    Schema schema = new Schema(TypeUtil.assignFreshIds(structType, new AtomicInteger(0)::incrementAndGet)\n        .asStructType().fields());\n\n    writeAndValidate(schema);\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/avro/AvroDataTest.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":134,"status":"NB"}],"commitId":"5a3cd22e775dfa8bf79deab675390aad48ba79a5","commitMessage":"@@@Parquet: Support name mappings to recover field IDs (#830)\n\n","date":"2020-06-18 00:57:08","modifiedFileCount":"16","status":"M","submitter":"Chen Junjie"},{"authorTime":"2019-11-21 07:59:34","codes":[{"authorDate":"2020-06-24 00:34:40","commitOrder":4,"curCode":"  public void testAssignIdsByNameMapping() {\n    Types.StructType structType = Types.StructType.of(\n        required(0, \"id\", Types.LongType.get()),\n        optional(1, \"list_of_maps\",\n            Types.ListType.ofOptional(2, Types.MapType.ofOptional(3, 4,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))),\n        optional(5, \"map_of_lists\",\n            Types.MapType.ofOptional(6, 7,\n                Types.StringType.get(),\n                Types.ListType.ofOptional(8, SUPPORTED_PRIMITIVES))),\n        required(9, \"list_of_lists\",\n            Types.ListType.ofOptional(10, Types.ListType.ofOptional(11, SUPPORTED_PRIMITIVES))),\n        required(12, \"map_of_maps\",\n            Types.MapType.ofOptional(13, 14,\n                Types.StringType.get(),\n                Types.MapType.ofOptional(15, 16,\n                    Types.StringType.get(),\n                    SUPPORTED_PRIMITIVES))),\n        required(17, \"list_of_struct_of_nested_types\", Types.ListType.ofOptional(19, Types.StructType.of(\n            Types.NestedField.required(20, \"m1\", Types.MapType.ofOptional(21, 22,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(23, \"l1\", Types.ListType.ofRequired(24, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.required(25, \"l2\", Types.ListType.ofRequired(26, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(27, \"m2\", Types.MapType.ofOptional(28, 29,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))\n        )))\n    );\n\n    Schema schema = new Schema(TypeUtil.assignFreshIds(structType, new AtomicInteger(0)::incrementAndGet)\n        .asStructType().fields());\n    NameMapping nameMapping = MappingUtil.create(schema);\n    MessageType messageTypeWithIds = ParquetSchemaUtil.convert(schema, \"parquet_type\");\n    MessageType messageTypeWithIdsFromNameMapping = ParquetSchemaUtil\n        .applyNameMapping(RemoveIds.removeIds(messageTypeWithIds), nameMapping);\n\n    Assert.assertEquals(messageTypeWithIds, messageTypeWithIdsFromNameMapping);\n  }\n","date":"2020-06-24 00:34:40","endLine":94,"groupId":"107","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testAssignIdsByNameMapping","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/80/353f1b265ad362d693b4a49993efb32397a6ba.src","preCode":"  public void testAssignIdsByNameMapping() {\n    Types.StructType structType = Types.StructType.of(\n        required(0, \"id\", Types.LongType.get()),\n        optional(1, \"list_of_maps\",\n            Types.ListType.ofOptional(2, Types.MapType.ofOptional(3, 4,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))),\n        optional(5, \"map_of_lists\",\n            Types.MapType.ofOptional(6, 7,\n                Types.StringType.get(),\n                Types.ListType.ofOptional(8, SUPPORTED_PRIMITIVES))),\n        required(9, \"list_of_lists\",\n            Types.ListType.ofOptional(10, Types.ListType.ofOptional(11, SUPPORTED_PRIMITIVES))),\n        required(12, \"map_of_maps\",\n            Types.MapType.ofOptional(13, 14,\n                Types.StringType.get(),\n                Types.MapType.ofOptional(15, 16,\n                    Types.StringType.get(),\n                    SUPPORTED_PRIMITIVES))),\n        required(17, \"list_of_struct_of_nested_types\", Types.ListType.ofOptional(19, Types.StructType.of(\n            Types.NestedField.required(20, \"m1\", Types.MapType.ofOptional(21, 22,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(23, \"l1\", Types.ListType.ofRequired(24, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.required(25, \"l2\", Types.ListType.ofRequired(26, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(27, \"m2\", Types.MapType.ofOptional(28, 29,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))\n        )))\n    );\n\n    Schema schema = new Schema(TypeUtil.assignFreshIds(structType, new AtomicInteger(0)::incrementAndGet)\n        .asStructType().fields());\n    NameMapping nameMapping = MappingUtil.create(schema);\n    MessageType messageType = ParquetSchemaUtil.convert(schema, \"complex_schema\");\n    MessageType typeWithIdsFromNameMapping = ParquetSchemaUtil.applyNameMapping(messageType, nameMapping);\n    Schema newSchema = ParquetSchemaUtil.convert(typeWithIdsFromNameMapping);\n\n    Assert.assertEquals(schema.asStruct(), newSchema.asStruct());\n  }\n","realPath":"parquet/src/test/java/org/apache/iceberg/parquet/TestParquetSchemaUtil.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2019-11-21 07:59:34","commitOrder":4,"curCode":"  public void testMixedTypes() throws IOException {\n    StructType structType = StructType.of(\n        required(0, \"id\", LongType.get()),\n        optional(1, \"list_of_maps\",\n            ListType.ofOptional(2, MapType.ofOptional(3, 4,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))),\n        optional(5, \"map_of_lists\",\n            MapType.ofOptional(6, 7,\n                Types.StringType.get(),\n                ListType.ofOptional(8, SUPPORTED_PRIMITIVES))),\n        required(9, \"list_of_lists\",\n            ListType.ofOptional(10, ListType.ofOptional(11, SUPPORTED_PRIMITIVES))),\n        required(12, \"map_of_maps\",\n            MapType.ofOptional(13, 14,\n                Types.StringType.get(),\n                MapType.ofOptional(15, 16,\n                    Types.StringType.get(),\n                    SUPPORTED_PRIMITIVES))),\n        required(17, \"list_of_struct_of_nested_types\", ListType.ofOptional(19, StructType.of(\n            Types.NestedField.required(20, \"m1\", MapType.ofOptional(21, 22,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(23, \"l1\", ListType.ofRequired(24, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.required(25, \"l2\", ListType.ofRequired(26, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(27, \"m2\", MapType.ofOptional(28, 29,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))\n        )))\n    );\n\n    Schema schema = new Schema(TypeUtil.assignFreshIds(structType, new AtomicInteger(0)::incrementAndGet)\n        .asStructType().fields());\n\n    writeAndValidate(schema);\n  }\n","date":"2019-11-21 07:59:34","endLine":169,"groupId":"107","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testMixedTypes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/cb/e36f3ad92b73f4ced69944f28903fe91d1d254.src","preCode":"  public void testMixedTypes() throws IOException {\n    StructType structType = StructType.of(\n        required(0, \"id\", LongType.get()),\n        optional(1, \"list_of_maps\",\n            ListType.ofOptional(2, MapType.ofOptional(3, 4,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))),\n        optional(5, \"map_of_lists\",\n            MapType.ofOptional(6, 7,\n                Types.StringType.get(),\n                ListType.ofOptional(8, SUPPORTED_PRIMITIVES))),\n        required(9, \"list_of_lists\",\n            ListType.ofOptional(10, ListType.ofOptional(11, SUPPORTED_PRIMITIVES))),\n        required(12, \"map_of_maps\",\n            MapType.ofOptional(13, 14,\n                Types.StringType.get(),\n                MapType.ofOptional(15, 16,\n                    Types.StringType.get(),\n                    SUPPORTED_PRIMITIVES))),\n        required(17, \"list_of_struct_of_nested_types\", ListType.ofOptional(19, StructType.of(\n            Types.NestedField.required(20, \"m1\", MapType.ofOptional(21, 22,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(23, \"l1\", ListType.ofRequired(24, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.required(25, \"l2\", ListType.ofRequired(26, SUPPORTED_PRIMITIVES)),\n            Types.NestedField.optional(27, \"m2\", MapType.ofOptional(28, 29,\n                Types.StringType.get(),\n                SUPPORTED_PRIMITIVES))\n        )))\n    );\n\n    Schema schema = new Schema(TypeUtil.assignFreshIds(structType, new AtomicInteger(0)::incrementAndGet)\n        .asStructType().fields());\n\n    writeAndValidate(schema);\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/avro/AvroDataTest.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":134,"status":"N"}],"commitId":"8e9bfdd87dab76da70e137a671c8c085f3d6c744","commitMessage":"@@@Remove existing IDs in Parquet name mapping tests (#1128)\n\n","date":"2020-06-24 00:34:40","modifiedFileCount":"1","status":"M","submitter":"Chen Junjie"}]
