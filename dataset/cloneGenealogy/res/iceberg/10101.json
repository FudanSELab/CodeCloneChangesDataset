[{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"    public <T> Boolean notNull(BoundReference<T> ref) {\n      \r\n      \r\n      Integer id = ref.fieldId();\n      Preconditions.checkNotNull(struct.field(id),\n          \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      \r\n      \r\n      \r\n      if (schema.findType(id) instanceof Type.NestedType) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Long valueCount = valueCounts.get(id);\n      if (valueCount == null) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Statistics<?> colStats = stats.get(id);\n      if (colStats != null && valueCount - colStats.getNumNulls() == 0) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","date":"2019-03-21 07:25:05","endLine":180,"groupId":"1306","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"notNull","params":"(BoundReference<T>ref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/9b/66ed812835c91fde9cfc6449838ddf9e306be4.src","preCode":"    public <T> Boolean notNull(BoundReference<T> ref) {\n      \r\n      \r\n      Integer id = ref.fieldId();\n      Preconditions.checkNotNull(struct.field(id),\n          \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      \r\n      \r\n      \r\n      if (schema.findType(id) instanceof Type.NestedType) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Long valueCount = valueCounts.get(id);\n      if (valueCount == null) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Statistics<?> colStats = stats.get(id);\n      if (colStats != null && valueCount - colStats.getNumNulls() == 0) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetMetricsRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"B"},{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"    public <T> Boolean gt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      Long valueCount = valueCounts.get(id);\n      if (valueCount == null) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Statistics<?> colStats = stats.get(id);\n      if (colStats != null && !colStats.isEmpty()) {\n        if (!colStats.hasNonNullValue()) {\n          return ROWS_CANNOT_MATCH;\n        }\n\n        T upper = max(colStats, id);\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp <= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","date":"2019-03-21 07:25:05","endLine":264,"groupId":"1306","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"gt","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/9b/66ed812835c91fde9cfc6449838ddf9e306be4.src","preCode":"    public <T> Boolean gt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      Long valueCount = valueCounts.get(id);\n      if (valueCount == null) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Statistics<?> colStats = stats.get(id);\n      if (colStats != null && !colStats.isEmpty()) {\n        if (!colStats.hasNonNullValue()) {\n          return ROWS_CANNOT_MATCH;\n        }\n\n        T upper = max(colStats, id);\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp <= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetMetricsRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"B"}],"commitId":"c20927801a369104e5ea510470e1cf7c8e28b808","commitMessage":"@@@Rename packages to org.apache.iceberg (#138)\n\n* Move all packages by directory (but don't change references)\n* Rename all references from com.netflix.iceberg to org.apache.iceberg\n* Reorganize all imports due to new package name.\n  Previous commit only did a string find-replace.  which made all the imports out of order. Use an IDE to auto-sort all imports.\n\n","date":"2019-03-21 07:25:05","modifiedFileCount":"0","status":"B","submitter":"mccheah"},{"authorTime":"2019-05-29 03:40:04","codes":[{"authorDate":"2019-05-29 03:40:04","commitOrder":2,"curCode":"    public <T> Boolean notNull(BoundReference<T> ref) {\n      \r\n      \r\n      Integer id = ref.fieldId();\n\n      \r\n      \r\n      \r\n      if (schema.findType(id) instanceof Type.NestedType) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Long valueCount = valueCounts.get(id);\n      if (valueCount == null) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Statistics<?> colStats = stats.get(id);\n      if (colStats != null && valueCount - colStats.getNumNulls() == 0) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","date":"2019-05-29 03:40:04","endLine":180,"groupId":"1306","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"notNull","params":"(BoundReference<T>ref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/88/4ac16c590cca7ff064d328957686cb8739939c.src","preCode":"    public <T> Boolean notNull(BoundReference<T> ref) {\n      \r\n      \r\n      Integer id = ref.fieldId();\n      Preconditions.checkNotNull(struct.field(id),\n          \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      \r\n      \r\n      \r\n      if (schema.findType(id) instanceof Type.NestedType) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Long valueCount = valueCounts.get(id);\n      if (valueCount == null) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Statistics<?> colStats = stats.get(id);\n      if (colStats != null && valueCount - colStats.getNumNulls() == 0) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetMetricsRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"M"},{"authorDate":"2019-05-29 03:40:04","commitOrder":2,"curCode":"    public <T> Boolean gt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n\n      Long valueCount = valueCounts.get(id);\n      if (valueCount == null) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Statistics<?> colStats = stats.get(id);\n      if (colStats != null && !colStats.isEmpty()) {\n        if (!colStats.hasNonNullValue()) {\n          return ROWS_CANNOT_MATCH;\n        }\n\n        T upper = max(colStats, id);\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp <= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","date":"2019-05-29 03:40:04","endLine":258,"groupId":"1306","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"gt","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/88/4ac16c590cca7ff064d328957686cb8739939c.src","preCode":"    public <T> Boolean gt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      Long valueCount = valueCounts.get(id);\n      if (valueCount == null) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Statistics<?> colStats = stats.get(id);\n      if (colStats != null && !colStats.isEmpty()) {\n        if (!colStats.hasNonNullValue()) {\n          return ROWS_CANNOT_MATCH;\n        }\n\n        T upper = max(colStats, id);\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp <= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetMetricsRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"M"}],"commitId":"81f29e2f80cc2e6b3b6f715573893aff696f579a","commitMessage":"@@@Support filtering based on nested struct fields (#123)\n\n","date":"2019-05-29 03:40:04","modifiedFileCount":"9","status":"M","submitter":"Gautam"},{"authorTime":"2020-10-22 08:07:37","codes":[{"authorDate":"2019-05-29 03:40:04","commitOrder":3,"curCode":"    public <T> Boolean notNull(BoundReference<T> ref) {\n      \r\n      \r\n      Integer id = ref.fieldId();\n\n      \r\n      \r\n      \r\n      if (schema.findType(id) instanceof Type.NestedType) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Long valueCount = valueCounts.get(id);\n      if (valueCount == null) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Statistics<?> colStats = stats.get(id);\n      if (colStats != null && valueCount - colStats.getNumNulls() == 0) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","date":"2019-05-29 03:40:04","endLine":180,"groupId":"10101","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"notNull","params":"(BoundReference<T>ref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/88/4ac16c590cca7ff064d328957686cb8739939c.src","preCode":"    public <T> Boolean notNull(BoundReference<T> ref) {\n      \r\n      \r\n      Integer id = ref.fieldId();\n\n      \r\n      \r\n      \r\n      if (schema.findType(id) instanceof Type.NestedType) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Long valueCount = valueCounts.get(id);\n      if (valueCount == null) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Statistics<?> colStats = stats.get(id);\n      if (colStats != null && valueCount - colStats.getNumNulls() == 0) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetMetricsRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"N"},{"authorDate":"2020-10-22 08:07:37","commitOrder":3,"curCode":"    public <T> Boolean gt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n\n      Long valueCount = valueCounts.get(id);\n      if (valueCount == null) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Statistics<?> colStats = stats.get(id);\n      if (colStats != null && !colStats.isEmpty()) {\n        if (hasNonNullButNoMinMax(colStats, valueCount)) {\n          return ROWS_MIGHT_MATCH;\n        }\n\n        if (!colStats.hasNonNullValue()) {\n          return ROWS_CANNOT_MATCH;\n        }\n\n        T upper = max(colStats, id);\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp <= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","date":"2020-10-22 08:07:37","endLine":265,"groupId":"10101","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"gt","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/3a/a266002f7f916173f1ac6303525383683291d1.src","preCode":"    public <T> Boolean gt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n\n      Long valueCount = valueCounts.get(id);\n      if (valueCount == null) {\n        \r\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Statistics<?> colStats = stats.get(id);\n      if (colStats != null && !colStats.isEmpty()) {\n        if (!colStats.hasNonNullValue()) {\n          return ROWS_CANNOT_MATCH;\n        }\n\n        T upper = max(colStats, id);\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp <= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetMetricsRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":238,"status":"M"}],"commitId":"997f571273509270904f4ce7490af0cbe9262190","commitMessage":"@@@Parquet: Fix row group filtering with old CDH stats (#1638)\n\n","date":"2020-10-22 08:07:37","modifiedFileCount":"1","status":"M","submitter":"Russell Spitzer"}]
